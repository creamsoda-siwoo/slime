<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ìŠ¬ë¼ì„ í—Œí„° </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes damage-popup {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }
        .animate-damage-popup {
            animation: damage-popup 1s ease-out forwards;
        }
        @keyframes damage-popup-skill {
            0% { transform: translateY(0) scale(1.2); opacity: 1; }
            100% { transform: translateY(-80px) scale(2.2); opacity: 0; }
        }
        .animate-damage-popup-skill {
            animation: damage-popup-skill 1s ease-out forwards;
        }
        @keyframes damage-popup-crit {
            0% { transform: translateY(0) scale(1.5) rotate(-5deg); opacity: 1; text-shadow: 0 0 10px #fff, 0 0 20px #fff; }
            100% { transform: translateY(-100px) scale(2.8) rotate(10deg); opacity: 0; }
        }
        .animate-damage-popup-crit {
            animation: damage-popup-crit 1s ease-out forwards;
        }
        @keyframes damage-popup-elemental {
            0% { transform: translateY(0) scale(1.5); opacity: 1; text-shadow: 0 0 5px #fff, 0 0 10px #ff00ff, 0 0 15px #00ffff, 0 0 20px #ffff00; }
            100% { transform: translateY(-120px) scale(3.2); opacity: 0; }
        }
        .animate-damage-popup-elemental {
            animation: damage-popup-elemental 1.2s ease-out forwards;
        }
        @keyframes damage-popup-resist {
            0% { transform: translateY(0) scale(0.8); opacity: 0.9; }
            100% { transform: translateY(-30px) scale(0.7); opacity: 0; }
        }
        .animate-damage-popup-resist {
            animation: damage-popup-resist 1s ease-out forwards;
        }


        @keyframes screen-shake {
            0% { transform: translate(0, 0) rotate(0); }
            25% { transform: translate(0.5px, -0.5px) rotate(-0.1deg); }
            50% { transform: translate(-0.5px, 0.5px) rotate(0.1deg); }
            75% { transform: translate(0.5px, 0.5px) rotate(-0.1deg); }
            100% { transform: translate(0, 0) rotate(0); }
        }
        .animate-screen-shake {
            animation: screen-shake 0.1s linear;
        }

        /* Rarity Colors */
        .text-rarity-COMMON { color: #ffffff; }
        .text-rarity-UNCOMMON { color: #1eff00; }
        .text-rarity-RARE { color: #0070dd; }
        .text-rarity-EPIC { color: #a335ee; }
        .text-rarity-LEGENDARY { color: #ff8000; }
        .text-rarity-MYTHIC { color: #2dd4bf; text-shadow: 0 0 8px #2dd4bf; }


        .border-rarity-COMMON { border-color: #6b7280; }
        .border-rarity-UNCOMMON { border-color: #16a34a; }
        .border-rarity-RARE { border-color: #2563eb; }
        .border-rarity-EPIC { border-color: #9333ea; }
        .border-rarity-LEGENDARY { border-color: #d97706; }
        .border-rarity-MYTHIC { border-color: #14b8a6; box-shadow: 0 0 10px #2dd4bf; }

        .crit-icon { color: #facc15; }

        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 240px;
            background-color: #1f2937;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 50;
            bottom: 125%;
            left: 50%;
            margin-left: -120px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #4b5563;
            pointer-events: none;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        @keyframes slime-pop {
            0% { transform: translateY(80%) scale(0.8); }
            70% { transform: translateY(-10%) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }
        .animate-slime-pop {
            animation: slime-pop 0.3s ease-out;
        }
    </style>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel for JSX and TypeScript transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
  <body class="bg-gray-900 text-white antialiased">
    <div id="root"></div>
    <script type="text/babel" data-presets="react,typescript">
// Use global React and ReactDOM loaded from CDN, and destructure hooks for convenience.
const { useState, useEffect, useCallback, useRef, useMemo } = React;

// --- CONFIG ---
const LEVEL_EXPERIENCE_BASE = 20;
const LEVEL_EXPERIENCE_MULTIPLIER = 1.15;
const MONSTER_HP_BASE = 20;
const MONSTER_HP_MULTIPLIER = 1.16;
const MONSTER_REWARD_BASE = 5;
const MONSTER_REWARD_MULTIPLIER = 1.1;
const BOSS_LEVEL_INTERVAL = 10;
const BOSS_HP_MULTIPLIER = 4.0;
const BOSS_REWARD_MULTIPLIER = 3;
const BOSS_DROP_CHANCE_BOOST = 0.2;

const CLICK_UPGRADE_COST_BASE = 50;
const CLICK_UPGRADE_COST_MULTIPLIER = 1.25;
const AUTO_ATTACK_UPGRADE_COST_BASE = 120;
const AUTO_ATTACK_UPGRADE_COST_MULTIPLIER = 1.32;
const CRIT_CHANCE_UPGRADE_COST_BASE = 300;
const CRIT_CHANCE_UPGRADE_COST_MULTIPLIER = 1.48;
const CRIT_CHANCE_UPGRADE_INCREASE = 1;
const CRIT_DAMAGE_UPGRADE_COST_BASE = 500;
const CRIT_DAMAGE_UPGRADE_COST_MULTIPLIER = 1.45;
const CRIT_DAMAGE_UPGRADE_INCREASE = 5;

const GOLD_GAIN_UPGRADE_COST_BASE = 600;
const GOLD_GAIN_UPGRADE_COST_MULTIPLIER = 1.55;
const XP_GAIN_UPGRADE_COST_BASE = 1000;
const XP_GAIN_UPGRADE_COST_MULTIPLIER = 1.65;

const ATTACK_SPEED_UPGRADE_COST_BASE = 1200;
const ATTACK_SPEED_UPGRADE_COST_MULTIPLIER = 1.48;
const HASTE_UPGRADE_COST_BASE = 2500;
const HASTE_UPGRADE_COST_MULTIPLIER = 1.70;
const LUCK_UPGRADE_COST_BASE = 2000;
const LUCK_UPGRADE_COST_MULTIPLIER = 1.60;

const SKILL_DAMAGE_UPGRADE_COST_BASE = 1800;
const SKILL_DAMAGE_UPGRADE_COST_MULTIPLIER = 1.68;

const BOSS_DAMAGE_UPGRADE_COST_BASE = 2200;
const BOSS_DAMAGE_UPGRADE_COST_MULTIPLIER = 1.62;

const ARTIFACT_POWER_UPGRADE_COST_BASE = 25000;
const ARTIFACT_POWER_UPGRADE_COST_MULTIPLIER = 1.80;

const FINAL_DAMAGE_UPGRADE_COST_BASE = 8000;
const FINAL_DAMAGE_UPGRADE_COST_MULTIPLIER = 1.85;

const SKILL_DURATION_UPGRADE_COST_BASE = 5000;
const SKILL_DURATION_UPGRADE_COST_MULTIPLIER = 1.75;

const ELEMENTAL_POWER_UPGRADE_COST_BASE = 6000;
const ELEMENTAL_POWER_UPGRADE_COST_MULTIPLIER = 1.82;
const OFFLINE_REWARDS_UPGRADE_COST_BASE = 10000;
const OFFLINE_REWARDS_UPGRADE_COST_MULTIPLIER = 1.90;
const TREASURE_GOLEM_CHANCE_UPGRADE_COST_BASE = 15000;
const TREASURE_GOLEM_CHANCE_UPGRADE_COST_MULTIPLIER = 2.0;

const LIBERATION_COST_BASE = 10000;
const LIBERATION_COST_MULTIPLIER = 100;

const BASE_SKILL_COOLDOWN = 30000; // 30 seconds

const EQUIPMENT_DROP_CHANCE_BASE = 0.15;
const EQUIPMENT_GACHA_COST_BASE = 100;
const EQUIPMENT_GACHA_COST_LEVEL_MULTIPLIER = 20;

const REBIRTH_LEVEL_REQUIREMENT = 40;
const REBIRTH_ALL_STAT_BONUS = 10; // All stats +10%

const TREASURE_GOLEM_SPAWN_CHANCE = 0.02; // 2% chance
const TREASURE_GOLEM_TIMER = 30; // 30 seconds

const SAVED_GAME_KEY = 'slimeHunterSaveData';

// --- ELEMENTAL DATA ---
const ELEMENT_TYPES = {
    FIRE: { name: 'ë¶ˆ', icon: (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="text-red-500" {...props}><path d="M12 2.25c.991 1.726 2.5 3.013 2.5 4.75 0 1.933-1.567 3.5-3.5 3.5-1.933 0-3.5-1.567-3.5-3.5 0-1.737 1.509-3.024 2.5-4.75z M12 21.75c-3.314 0-6-2.686-6-6 0-3.314 2.686-6 6-6s6 2.686 6 6c0 3.314-2.686 6-6 6z M12 11.25c-2.485 0-4.5 2.015-4.5 4.5s2.015 4.5 4.5 4.5 4.5-2.015 4.5-4.5-2.015-4.5-4.5-4.5z"/></svg> },
    WATER: { name: 'ë¬¼', icon: (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="text-blue-500" {...props}><path d="M12 2c-5.523 0-10 4.477-10 10 0 5.523 4.477 10 10 10s10-4.477 10-10c0-5.523-4.477-10-10-10z M12 20c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z M12 6c-3.309 0-6 2.691-6 6s2.691 6 6 6 6-2.691 6-6-2.691-6-6-6z M12 16c-2.206 0-4-1.794-4-4s1.794-4 4-4 4 1.794 4 4-1.794 4-4 4z"/></svg> },
    EARTH: { name: 'ë•…', icon: (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="text-yellow-700" {...props}><path d="M12 2L2 12l10 10 10-10L12 2z m0 17.172L4.828 12 12 4.828 19.172 12 12 19.172z"/></svg> },
    WIND: { name: 'ë°”ëŒ', icon: (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="text-gray-400" {...props}><path d="M12 2c-5.523 0-10 4.477-10 10s4.477 10 10 10c2.761 0 5.261-1.121 7.071-2.929l-1.414-1.414c-1.569 1.569-3.71 2.343-5.657 2.343-4.411 0-8-3.589-8-8s3.589-8 8-8c1.947 0 3.788 0.774 5.146 2.059l-1.146 1.146h5v-5l-1.464 1.464c-1.85-1.85-4.408-2.669-6.936-2.669z"/></svg> },
};
const ELEMENTAL_RELATIONSHIPS = {
    FIRE: { weak: 'WIND', strong: 'WATER' },
    WATER: { weak: 'FIRE', strong: 'EARTH' },
    EARTH: { weak: 'WATER', strong: 'WIND' },
    WIND: { weak: 'EARTH', strong: 'FIRE' },
};
const ELEMENTAL_ADVANTAGE_MULTIPLIER = 1.25;
const ELEMENTAL_DISADVANTAGE_MULTIPLIER = 1.0;

// --- DIFFICULTY DATA ---
const DIFFICULTIES = {
    EASY: {
        name: 'ì‰¬ì›€',
        description: 'ëŠê¸‹í•˜ê²Œ ì¦ê¸°ëŠ” ëª¨í—˜. ëª¬ìŠ¤í„°ê°€ ì•½í•˜ê³  ì„±ì¥ì´ ë¹ ë¦…ë‹ˆë‹¤.',
        multipliers: { monsterHp: 0.75, monsterReward: 1.25, upgradeCost: 0.8 }
    },
    NORMAL: {
        name: 'ë³´í†µ',
        description: 'ê· í˜• ì¡íŒ ë„ì „. í‘œì¤€ì ì¸ ê²Œì„ í”Œë ˆì´ë¥¼ ê²½í—˜í•˜ì„¸ìš”.',
        multipliers: { monsterHp: 1.0, monsterReward: 1.0, upgradeCost: 1.0 }
    },
    HARD: {
        name: 'ì–´ë ¤ì›€',
        description: 'ì§„ì •í•œ í—Œí„°ë¥¼ ìœ„í•œ ì‹œë ¨. ëª¬ìŠ¤í„°ê°€ ê°•ë ¥í•˜ì§€ë§Œ, ë³´ìƒì´ ë” í½ë‹ˆë‹¤.',
        multipliers: { monsterHp: 1.5, monsterReward: 1.2, upgradeCost: 1.2 }
    }
};

// --- JOB DATA ---
const JOBS = {
    WARRIOR: {
        name: 'ì „ì‚¬',
        description: 'ê°•ë ¥í•œ í´ë¦­ ê³µê²©ê³¼ ì§€ì†ì ì¸ ì „íˆ¬ì— íŠ¹í™”ë˜ì—ˆìŠµë‹ˆë‹¤.',
        passive: 'í´ë¦­ ë°ë¯¸ì§€ +25%, ìë™ ê³µê²© ë°ë¯¸ì§€ +10%',
        skill: { name: 'ì†Œìš©ëŒì´', description: '5ì´ˆ ë™ì•ˆ ë§¤ì´ˆ ìë™ ê³µê²©ë ¥ì˜ 300%ì— í•´ë‹¹í•˜ëŠ” í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.' },
        skill2: { name: 'ì••ë„', description: 'ë‹¤ìŒ 5íšŒì˜ í´ë¦­ ê³µê²©ì´ 200%ì˜ ì¶”ê°€ í”¼í•´ë¥¼ ì…íˆê³ , ë§ˆì§€ë§‰ íƒ€ê²©ì€ ëª¬ìŠ¤í„°ë¥¼ 1.5ì´ˆê°„ ê¸°ì ˆì‹œí‚µë‹ˆë‹¤.', cooldown: 25000 },
        skill3: { name: 'ëŒ€ì§€ ë¶„ì‡„', description: 'ìë™ ê³µê²© ë°ë¯¸ì§€ì˜ 800%ì— í•´ë‹¹í•˜ëŠ” í”¼í•´ë¥¼ ì£¼ê³ , ëª¬ìŠ¤í„°ë¥¼ 1ì´ˆê°„ ê¸°ì ˆì‹œí‚µë‹ˆë‹¤.', cooldown: 60000 },
        bonuses: { clickDamage: 0.25, autoAttackDamage: 0.10, critChance: 0, critDamage: 0, skillEffect: 0 },
        icon: (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" /></svg>
    },
    ARCHER: {
        name: 'ê¶ìˆ˜',
        description: 'ì¹˜ëª…íƒ€ë¥¼ í™œìš©í•˜ì—¬ í­ë°œì ì¸ ë°ë¯¸ì§€ë¥¼ ì…í™ë‹ˆë‹¤.',
        passive: 'í¬ë¦¬í‹°ì»¬ í™•ë¥  +10%p, í¬ë¦¬í‹°ì»¬ ë°ë¯¸ì§€ +50%p',
        skill: { name: 'ì§‘ì¤‘ì˜ ì‹œê°„', description: 'ì¦‰ì‹œ ìë™ ê³µê²©ë ¥ì˜ 300% í”¼í•´ë¥¼ ì£¼ê³ , 10ì´ˆê°„ ê³µê²© ì†ë„ê°€ 50% ì¦ê°€í•˜ë©° ëª¨ë“  ê³µê²©ì´ í¬ë¦¬í‹°ì»¬ë¡œ ì ì¤‘í•©ë‹ˆë‹¤.' },
        skill2: { name: 'ì €ê²©', description: 'ëŒ€ìƒì˜ ìƒì€ ì²´ë ¥ 15%ì— í•´ë‹¹í•˜ëŠ” í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤ (ìµœëŒ€ ìë™ ê³µê²©ë ¥ì˜ 20ë°°). ì´ ê³µê²©ì€ í•­ìƒ í¬ë¦¬í‹°ì»¬ë¡œ ì ìš©ë©ë‹ˆë‹¤.', cooldown: 45000 },
        skill3: { name: 'ì•½ì  íƒìƒ‰', description: 'ì¦‰ì‹œ ìë™ ê³µê²©ë ¥ì˜ 500% í”¼í•´ë¥¼ ì£¼ê³ , 15ì´ˆê°„ í¬ë¦¬í‹°ì»¬ í™•ë¥ ì´ 20%p, í¬ë¦¬í‹°ì»¬ ë°ë¯¸ì§€ê°€ 30%p ì¦ê°€í•©ë‹ˆë‹¤.', cooldown: 75000 },
        bonuses: { clickDamage: 0, autoAttackDamage: 0, critChance: 10, critDamage: 50, skillEffect: 0 },
        icon: (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z" /></svg>
    },
    MAGE: {
        name: 'ë§ˆë²•ì‚¬',
        description: 'ê°•ë ¥í•œ ìŠ¤í‚¬ë¡œ ì „ì¥ì„ ì§€ë°°í•©ë‹ˆë‹¤.',
        passive: 'ìŠ¤í‚¬ ë°ë¯¸ì§€ +50%, ìŠ¤í‚¬ ì¿¨íƒ€ì„ ê°ì†Œ íš¨ê³¼ +25%',
        skill: { name: 'ìš´ì„ ë‚™í•˜', description: 'ì´ ê³µê²©ë ¥ì˜ 25ë°° í”¼í•´ë¥¼ ì£¼ê³ , ëª¬ìŠ¤í„°ê°€ ì•½ì  ì›ì†Œì¼ ê²½ìš° 3ì´ˆê°„ ë¹™ê²°ì‹œí‚µë‹ˆë‹¤.' },
        skill2: { name: 'ì‹œê°„ ì™œê³¡', description: 'ì´ ê³µê²©ë ¥ì˜ 500% í”¼í•´ë¥¼ ì£¼ê³ , 10ì´ˆê°„ ëª¨ë“  ìŠ¤í‚¬ ì¿¨íƒ€ì„ì´ 2ë°° ë¹ ë¥´ê²Œ ê°ì†Œí•˜ë©° ëª¬ìŠ¤í„° ì²˜ì¹˜ ì‹œ ê³¨ë“œ íšë“ëŸ‰ì´ 50% ì¦ê°€í•©ë‹ˆë‹¤.', cooldown: 90000 },
        skill3: { name: 'ë§ˆë ¥ í­í’', description: 'ì´ ê³µê²©ë ¥ì˜ 15ë°°ì— í•´ë‹¹í•˜ëŠ” í”¼í•´ë¥¼ ì£¼ê³ , 5ì´ˆê°„ ëª¬ìŠ¤í„°ê°€ ë°›ëŠ” ëª¨ë“  í”¼í•´ê°€ 20% ì¦ê°€í•˜ëŠ” ë””ë²„í”„ë¥¼ ê²ë‹ˆë‹¤.', cooldown: 80000 },
        bonuses: { clickDamage: 0, autoAttackDamage: 0, critChance: 0, critDamage: 0, skillEffect: 0.5 },
        icon: (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M15.362 5.214A8.252 8.252 0 0112 21 8.25 8.25 0 016.038 7.048 8.287 8.287 0 009 9.6a8.983 8.983 0 013.362-3.797z" /></svg>
    }
};

const MISSION_TYPES = {
    DEFEAT_MONSTERS: 'ëª¬ìŠ¤í„° ì²˜ì¹˜',
    DEFEAT_BOSSES: 'ë³´ìŠ¤ ì²˜ì¹˜',
    UPGRADE_TIMES: 'ê°•í™” ì‹œë„',
    EARN_GOLD: 'ê³¨ë“œ íšë“',
};

// --- EQUIPMENT DATA ---
const EQUIPMENT_TYPES = {
    WEAPON: { name: 'ë¬´ê¸°', icon: (props) => <SwordIcon {...props}/> },
    ARMOR: { name: 'ë°©ì–´êµ¬', icon: (props) => <ArmorIcon {...props}/> },
    AMULET: { name: 'ì¥ì‹ êµ¬', icon: (props) => <AmuletIcon {...props}/> },
    HELMET: { name: 'íˆ¬êµ¬', icon: (props) => <HelmetIcon {...props}/> },
    GLOVES: { name: 'ì¥ê°‘', icon: (props) => <GlovesIcon {...props}/> },
    BOOTS: { name: 'ì‹ ë°œ', icon: (props) => <BootsIcon {...props}/> },
    RING: { name: 'ë°˜ì§€', icon: (props) => <RingIcon {...props}/> },
    CLOAK: { name: 'ë§í† ', icon: (props) => <CloakIcon {...props}/> }
};

const RARITY_ORDER = ['COMMON', 'UNCOMMON', 'RARE', 'EPIC', 'LEGENDARY', 'MYTHIC'];
const RARITIES = {
    COMMON: { name: 'ì¼ë°˜', textClass: 'text-rarity-COMMON', borderClass: 'border-rarity-COMMON', statMultiplier: 1 },
    UNCOMMON: { name: 'ê³ ê¸‰', textClass: 'text-rarity-UNCOMMON', borderClass: 'border-rarity-UNCOMMON', statMultiplier: 1.6 },
    RARE: { name: 'í¬ê·€', textClass: 'text-rarity-RARE', borderClass: 'border-rarity-RARE', statMultiplier: 2.8 },
    EPIC: { name: 'ì˜ì›…', textClass: 'text-rarity-EPIC', borderClass: 'border-rarity-EPIC', statMultiplier: 5 },
    LEGENDARY: { name: 'ì „ì„¤', textClass: 'text-rarity-LEGENDARY', borderClass: 'border-rarity-LEGENDARY', statMultiplier: 8 },
    MYTHIC: { name: 'ì‹ í™”', textClass: 'text-rarity-MYTHIC', borderClass: 'border-rarity-MYTHIC', statMultiplier: 15 }
};

// --- ICONS ---
const LevelIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 10l7-7m0 0l7 7m-7-7v18" /> </svg> );
const XPIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 11l7-7 7 7M5 19l7-7 7 7" /> </svg> );
const CoinIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8v1m0 6v1m0-1c-1.11 0-2.08-.402-2.599-1M12 18c1.11 0 2.08-.402-2.599-1M8.999 12H8m8 0h-.001M12 21a9 9 0 110-18 9 9 0 010 18z" /> </svg> );
const SwordIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" /> </svg> );
const DpsIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /> </svg> );
const CritIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block crit-icon" fill="currentColor" viewBox="0 0 24 24" {...props}> <path d="M12 .587l3.668 7.568 8.332 1.151-6.064 5.828 1.48 8.279-7.416-3.967-7.417 3.967 1.481-8.279-6.064-5.828 8.332-1.151z" /> </svg> );
const ArmorIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" /> </svg> );
const AmuletIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v1m6 11h2m-6.5-1.5l3.5 3.5M4 12H2m13.5 1.5L12 17l-3.5-3.5M12 8a4 4 0 100 8 4 4 0 000-8z" /> </svg> );
const GachaIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" /> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2z" /> </svg> );
const AttackSpeedIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> );
const LuckIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> );
const BossIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 1.052A10.952 10.952 0 003.848 5.766L2 12l1.848 6.234A10.952 10.952 0 0012 22.948a10.952 10.952 0 008.152-4.714L22 12l-1.848-6.234A10.952 10.952 0 0012 1.052z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 14s1.5-2 4-2 4 2 4 2" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 9h.01M15 9h.01" /></svg> );
const HelmetIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg> );
const GlovesIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.618 5.984A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.31-.264-2.55-.724-3.682z" /><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z" /></svg> );
const BootsIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" /></svg> );
const RingIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 21a9 9 0 01-9-9 3 3 0 013-3h12a3 3 0 013 3 9 9 0 01-9 9z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9a2 2 0 100-4 2 2 0 000 4z" /></svg> );
const CloakIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v16h16V4H4zm8 4l-4 4h8l-4-4z" /></svg> );
const ArtifactIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16.5 6v.75m0 3v.75m0 3v.75m0 3V18m-9-1.5h10.5a2.25 2.25 0 002.25-2.25V6.75a2.25 2.25 0 00-2.25-2.25H7.5A2.25 2.25 0 005.25 6.75v9.75a2.25 2.25 0 002.25 2.25z" /> </svg> );
const LockIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" {...props}> <path fillRule="evenodd" d="M12 1.5a5.25 5.25 0 00-5.25 5.25v3a3 3 0 00-3 3v6.75a3 3 0 003 3h10.5a3 3 0 003-3v-6.75a3 3 0 00-3-3v-3c0-2.9-2.35-5.25-5.25-5.25zm3.75 8.25v-3a3.75 3.75 0 10-7.5 0v3h7.5z" clipRule="evenodd" /> </svg> );
const ElementIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M15.362 5.214A8.252 8.252 0 0112 21 8.25 8.25 0 016.038 7.048 8.287 8.287 0 009 9.6a8.983 8.983 0 013.362-3.797z" /></svg> );
const OfflineIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> );

// Monster Icons
const GreenSlimeIcon = ({className = '', ...props}) => ( <svg viewBox="0 0 100 80" className={`drop-shadow-lg ${className}`} {...props}> <path d="M 35 25 C 40 20, 50 20, 55 25" fill="rgba(255,255,255,0.5)" stroke="none"></path> <path d="M 50 80 C 10 80, 10 40, 10 40 C 10 10, 40 10, 50 10 C 60 10, 90 10, 90 40 C 90 40, 90 80, 50 80 Z" fill="#22c55e" stroke="#166534" strokeWidth="3"></path> <circle cx="28" cy="50" r="5" fill="#fecaca"></circle> <circle cx="72" cy="50" r="5" fill="#fecaca"></circle> <circle cx="38" cy="45" r="8" fill="white"></circle> <circle cx="62" cy="45" r="8" fill="white"></circle> <circle cx="40" cy="46" r="4" fill="black"></circle> <circle cx="64" cy="46" r="4" fill="black"></circle> <circle cx="37" cy="42" r="2" fill="white"></circle> <circle cx="61" cy="42" r="2" fill="white"></circle> <path d="M 45 60 Q 50 68, 55 60" stroke="black" fill="transparent" strokeWidth="2.5" strokeLinecap="round"></path> </svg> );
const RedSlimeIcon = ({className = '', ...props}) => ( <svg viewBox="0 0 100 80" className={`drop-shadow-lg ${className}`} {...props}> <path d="M 35 25 C 40 20, 50 20, 55 25" fill="rgba(255,255,255,0.5)" stroke="none"></path> <path d="M 50 80 C 10 80, 10 40, 10 40 C 10 10, 40 10, 50 10 C 60 10, 90 10, 90 40 C 90 40, 90 80, 50 80 Z" fill="#ef4444" stroke="#991b1b" strokeWidth="3"></path> <circle cx="38" cy="45" r="7" fill="white"></circle> <circle cx="62" cy="45" r="7" fill="white"></circle> <circle cx="40" cy="47" r="3" fill="black"></circle> <circle cx="64" cy="47" r="3" fill="black"></circle> <path d="M 45 62 Q 50 55, 55 62" stroke="black" fill="transparent" strokeWidth="2.5" strokeLinecap="round"></path> </svg> );
const BlueSlimeIcon = ({className = '', ...props}) => ( <svg viewBox="0 0 100 80" className={`drop-shadow-lg ${className}`} {...props}> <path d="M 35 25 C 40 20, 50 20, 55 25" fill="rgba(255,255,255,0.5)" stroke="none"></path> <path d="M 50 80 C 10 80, 10 40, 10 40 C 10 10, 40 10, 50 10 C 60 10, 90 10, 90 40 C 90 40, 90 80, 50 80 Z" fill="#3b82f6" stroke="#1e3a8a" strokeWidth="3"></path> <path d="M 32 40 C 35 45, 41 45, 44 40" stroke="white" fill="transparent" strokeWidth="3" strokeLinecap="round"></path> <path d="M 56 40 C 59 45, 65 45, 68 40" stroke="white" fill="transparent" strokeWidth="3" strokeLinecap="round"></path> <path d="M 45 60 Q 50 65, 55 60" stroke="black" fill="transparent" strokeWidth="2.5" strokeLinecap="round"></path> </svg> );
const GolemIcon = ({className = '', ...props}) => ( <svg viewBox="0 0 100 100" className={`drop-shadow-lg ${className}`} {...props}> <rect x="20" y="40" width="60" height="50" fill="#6b7280" stroke="#4b5563" strokeWidth="3" rx="5"></rect> <rect x="30" y="20" width="40" height="30" fill="#7f8c9b" stroke="#4b5563" strokeWidth="3" rx="5"></rect> <circle cx="45" cy="35" r="4" fill="#dc2626"></circle> <circle cx="55" cy="35" r="4" fill="#dc2626"></circle> <rect x="10" y="50" width="20" height="30" fill="#6b7280" stroke="#4b5563" strokeWidth="3" rx="5"></rect> <rect x="70" y="50" width="20" height="30" fill="#6b7280" stroke="#4b5563" strokeWidth="3" rx="5"></rect> </svg> );
const KingSlimeIcon = ({className = '', ...props}) => ( <svg viewBox="0 0 100 80" className={`drop-shadow-lg ${className}`} {...props}> <path d="M 25 20 L 30 5 L 50 15 L 70 5 L 75 20 Z" fill="#facc15" stroke="#ca8a04" strokeWidth="2" strokeLinejoin="round"></path> <circle cx="30" cy="7" r="3" fill="#ef4444"></circle> <circle cx="50" cy="17" r="3" fill="#3b82f6"></circle> <circle cx="70" cy="7" r="3" fill="#22c55e"></circle> <path d="M 35 35 C 40 30, 50 30, 55 35" fill="rgba(255,255,255,0.5)" stroke="none"></path> <path d="M 50 80 C 10 80, 10 40, 10 40 C 10 20, 40 20, 50 20 C 60 20, 90 20, 90 40 C 90 40, 90 80, 50 80 Z" fill="#22c55e" stroke="#166534" strokeWidth="3"></path> <circle cx="28" cy="55" r="5" fill="#fecaca"></circle> <circle cx="72" cy="55" r="5" fill="#fecaca"></circle> <circle cx="38" cy="50" r="8" fill="white"></circle> <circle cx="62" cy="50" r="8" fill="white"></circle> <circle cx="40" cy="51" r="4" fill="black"></circle> <circle cx="64" cy="51" r="4" fill="black"></circle> <circle cx="37" cy="47" r="2" fill="white"></circle> <circle cx="61" cy="47" r="2" fill="white"></circle> <path d="M 45 65 Q 50 73, 55 65" stroke="black" fill="transparent" strokeWidth="2.5" strokeLinecap="round"></path> </svg> );
const DragonIcon = ({className = '', ...props}) => ( <svg viewBox="0 0 100 100" className={`drop-shadow-lg ${className}`} {...props}> <path d="M 50 10 C 20 40, 20 80, 50 90 C 80 80, 80 40, 50 10" fill="#b91c1c" stroke="#4a0404" strokeWidth="3"></path> <path d="M 40 20 C 30 30, 30 40, 40 50" fill="none" stroke="#fef2f2" strokeWidth="2"></path> <path d="M 60 20 C 70 30, 70 40, 60 50" fill="none" stroke="#fef2f2" strokeWidth="2"></path> <circle cx="45" cy="35" r="5" fill="#fef08a"></circle> <circle cx="55" cy="35" r="5" fill="#fef08a"></circle> <path d="M 45 70 Q 50 80, 55 70" stroke="white" strokeWidth="2" fill="none"></path> <path d="M 20 50 C 10 60, 10 70, 20 80" fill="#991b1b" stroke="#4a0404" strokeWidth="2"></path> <path d="M 80 50 C 90 60, 90 70, 80 80" fill="#991b1b" stroke="#4a0404" strokeWidth="2"></path> </svg> );
const TreasureGolemIcon = ({className = '', ...props}) => ( <svg viewBox="0 0 100 100" className={`drop-shadow-lg ${className}`} {...props}> <rect x="20" y="40" width="60" height="50" fill="#facc15" stroke="#ca8a04" strokeWidth="3" rx="5"></rect> <rect x="30" y="20" width="40" height="30" fill="#fde047" stroke="#ca8a04" strokeWidth="3" rx="5"></rect> <circle cx="45" cy="35" r="4" fill="#3b82f6"></circle> <circle cx="55" cy="35" r="4" fill="#3b82f6"></circle> <rect x="10" y="50" width="20" height="30" fill="#facc15" stroke="#ca8a04" strokeWidth="3" rx="5"></rect> <rect x="70" y="50" width="20" height="30" fill="#facc15" stroke="#ca8a04" strokeWidth="3" rx="5"></rect> <circle cx="50" cy="65" r="8" fill="#22c55e" stroke="#166534" strokeWidth="2"></circle> </svg> );

// --- MONSTER DATA ---
const MONSTER_TYPES = [
    { name: 'ì´ˆë¡ ìŠ¬ë¼ì„', Icon: GreenSlimeIcon, minLevel: 1 },
    { name: 'ë¹¨ê°„ ìŠ¬ë¼ì„', Icon: RedSlimeIcon, minLevel: 1 },
    { name: 'íŒŒë€ ìŠ¬ë¼ì„', Icon: BlueSlimeIcon, minLevel: 1 },
];
const BOSS_TYPES = [
    { name: 'ê³¨ë ˜', Icon: GolemIcon },
    { name: 'í‚¹ ìŠ¬ë¼ì„', Icon: KingSlimeIcon },
    { name: 'ë“œë˜ê³¤', Icon: DragonIcon },
];
const SPECIAL_MONSTERS = {
    TREASURE_GOLEM: { name: 'ë³´ë¬¼ ê³¨ë ˜', Icon: TreasureGolemIcon, isSpecial: true }
};

// --- ARTIFACT DATA ---
const ARTIFACTS = [
    { id: 'berserkers_blood', name: 'ê´‘ì „ì‚¬ì˜ í”¼', description: 'ë³´ìŠ¤ì—ê²Œ ì£¼ëŠ” ëª¨ë“  í”¼í•´ +25%', icon: BossIcon, effect: { type: 'BOSS_DAMAGE', value: 25 } },
    { id: 'swift_quiver', name: 'ì‹ ì†ì˜ í™”ì‚´í†µ', description: 'ê³µê²© ì†ë„ +10%', icon: AttackSpeedIcon, effect: { type: 'ATTACK_SPEED_MULT', value: 0.1 } },
    { id: 'mana_crystal', name: 'ë§ˆë‚˜ ìˆ˜ì •', description: 'ìŠ¤í‚¬ ì¿¨íƒ€ì„ -15%', icon: DpsIcon, effect: { type: 'HASTE', value: 15 } },
    { id: 'lucky_clover', name: 'í–‰ìš´ì˜ í´ë¡œë²„', description: 'í¬ë¦¬í‹°ì»¬ í™•ë¥  +5%p', icon: LuckIcon, effect: { type: 'CRIT_CHANCE', value: 5 } },
    { id: 'executioners_edge', name: 'ì²˜í˜•ì¸ì˜ ì¹¼ë‚ ', description: 'í¬ë¦¬í‹°ì»¬ ë°ë¯¸ì§€ +50%p', icon: CritIcon, effect: { type: 'CRIT_DAMAGE', value: 50 } },
    { id: 'golden_goblet', name: 'í™©ê¸ˆ ìˆ ì”', description: 'ê³¨ë“œ íšë“ëŸ‰ +20%', icon: CoinIcon, effect: { type: 'GOLD_GAIN', value: 20 } },
    { id: 'sages_stone', name: 'í˜„ìì˜ ëŒ', description: 'ê²½í—˜ì¹˜ íšë“ëŸ‰ +20%', icon: XPIcon, effect: { type: 'XP_GAIN', value: 20 } },
    { id: 'ancient_scope', name: 'ê³ ëŒ€ì˜ ì¡°ì¤€ê²½', description: 'í´ë¦­ ë°ë¯¸ì§€ +25%', icon: SwordIcon, effect: { type: 'CLICK_DAMAGE_MULT', value: 0.25 } },
];

// --- UTILS ---
const formatNumber = (num) => {
    const n = Math.floor(num);
    if (n < 1000) return n.toString();
    if (n < 1000000) return (n / 1000).toFixed(0) + 'K';
    if (n < 1000000000) return (n / 1000000).toFixed(0) + 'M';
    if (n < 1000000000000) return (n / 1000000000).toFixed(0) + 'B';
    return (n / 1000000000000).toFixed(0) + 'T';
};

const formatTime = (seconds) => {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    return [
        h > 0 ? `${h}ì‹œê°„` : '',
        m > 0 ? `${m}ë¶„` : '',
        s > 0 ? `${s}ì´ˆ` : ''
    ].filter(Boolean).join(' ');
};

const getEnhancedItemStats = (item) => {
    if (!item || !item.stats) return { clickDamage: 0, autoAttackDamage: 0, critChance: 0, critDamage: 0, attackSpeedBonus: 0, hasteBonus: 0, goldGainBonus: 0, xpGainBonus: 0, luckBonus: 0 };
    const itemLevel = item.level || 0;
    const multiplier = Math.pow(1.1, itemLevel);
    const bonusStatMultiplier = 1 + (itemLevel * 0.1);
    
    return {
        clickDamage: (item.stats.clickDamage || 0) * multiplier,
        autoAttackDamage: (item.stats.autoAttackDamage || 0) * multiplier,
        critChance: (item.stats.critChance || 0) + (itemLevel * 0.2),
        critDamage: (item.stats.critDamage || 0) + (itemLevel * 2),
        attackSpeedBonus: (item.stats.attackSpeedBonus || 0) * bonusStatMultiplier,
        hasteBonus: (item.stats.hasteBonus || 0) * bonusStatMultiplier,
        goldGainBonus: (item.stats.goldGainBonus || 0) * bonusStatMultiplier,
        xpGainBonus: (item.stats.xpGainBonus || 0) * bonusStatMultiplier,
        luckBonus: (item.stats.luckBonus || 0) * bonusStatMultiplier,
    };
};

const calculateItemStats = (baseLevel, rarityKey, typeKey) => {
    const rarity = RARITIES[rarityKey];
    const rarityIndex = RARITY_ORDER.indexOf(rarityKey);
    const stats = { clickDamage: 0, autoAttackDamage: 0, critChance: 0, critDamage: 0, attackSpeedBonus: 0, hasteBonus: 0, goldGainBonus: 0, xpGainBonus: 0, luckBonus: 0 };
    
    // Add a base value for rarity and reduce randomness to ensure higher rarity is always better.
    const statBudget = (baseLevel * rarity.statMultiplier) + (Math.pow(rarityIndex, 2.5) * 5);
    const randomFactor = 1 + Math.random() * 0.1;

    switch (typeKey) {
        case 'WEAPON': stats.clickDamage = Math.ceil(statBudget * randomFactor); break;
        case 'ARMOR': stats.autoAttackDamage = Math.ceil(statBudget * 0.6 * randomFactor); break;
        case 'AMULET':
            stats.critChance = parseFloat((statBudget * 0.1 * randomFactor).toFixed(1));
            stats.critDamage = Math.ceil(statBudget * 2 * randomFactor);
            break;
        case 'HELMET': stats.xpGainBonus = Math.ceil(statBudget * 0.5 * randomFactor); break;
        case 'GLOVES': stats.attackSpeedBonus = Math.ceil(statBudget * 0.15 * randomFactor); break;
        case 'BOOTS': stats.hasteBonus = Math.ceil(statBudget * 0.15 * randomFactor); break;
        case 'RING': stats.goldGainBonus = Math.ceil(statBudget * 0.4 * randomFactor); stats.luckBonus = Math.ceil(statBudget * 0.1 * randomFactor); break;
        case 'CLOAK': stats.hasteBonus += Math.ceil(statBudget * 0.1 * randomFactor); stats.xpGainBonus += Math.ceil(statBudget * 0.4 * randomFactor); break;
    }
    return stats;
}


// --- COMPONENTS ---
const PlayerStats = ({ stats, playerClass, onNameChange, abilityStats, liberationCount, rebirthCount, onJobChangeClick, difficulty, onDifficultyChangeClick, isAutoDropEnabled, onToggleAutoDrop, onReset }) => (
    <div className="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h2 className="text-2xl font-bold mb-4 text-green-400">í”Œë ˆì´ì–´ ì •ë³´</h2>
        <div className="flex justify-around mb-3 text-center">
             {liberationCount > 0 && ( <div className="font-bold text-yellow-300 text-lg border-2 border-yellow-400 bg-gray-700 p-2 rounded w-1/2 mr-1">í•´ë°© {liberationCount}</div> )}
             {rebirthCount > 0 && ( <div className="font-bold text-purple-400 text-lg border-2 border-purple-500 bg-gray-700 p-2 rounded w-1/2 ml-1">í™˜ìƒ {rebirthCount}</div> )}
        </div>
        <div className="space-y-2">
             <div className="flex justify-between items-center bg-gray-700 p-2 rounded">
                <span className="font-semibold">ì´ë¦„:</span>
                <input type="text" value={stats.playerName} onChange={(e) => onNameChange(e.target.value)} className="bg-gray-600 text-right font-bold text-lg rounded px-2 w-32" />
            </div>
            {playerClass && (
                <div className="flex justify-between items-center bg-gray-700 p-2 rounded">
                    <span className="font-semibold">ì§ì—…:</span>
                    <button onClick={onJobChangeClick} className="font-bold text-lg text-amber-400 hover:text-amber-300 transition-colors" title="ì§ì—… ë³€ê²½">
                        {JOBS[playerClass].name} <span className="text-sm">ğŸ”„</span>
                    </button>
                </div>
            )}
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded">
                <span className="font-semibold">ë‚œì´ë„:</span>
                <button onClick={onDifficultyChangeClick} className="font-bold text-lg text-cyan-400 hover:text-cyan-300 transition-colors" title="ë‚œì´ë„ ë³€ê²½">
                    {DIFFICULTIES[difficulty].name} <span className="text-sm">âš™ï¸</span>
                </button>
            </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded">
                <span className="font-semibold">ì¥ë¹„ ìë™ íŒë§¤:</span>
                <button onClick={onToggleAutoDrop} className={`font-bold text-sm px-3 py-1 rounded-md transition-colors ${isAutoDropEnabled ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-red-600 hover:bg-red-700 text-white'}`}>
                    {isAutoDropEnabled ? 'ON' : 'OFF'}
                </button>
            </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><LevelIcon />ë ˆë²¨:</span> <span className="font-bold text-lg">{stats.level}</span> </div>
            <div className="bg-gray-700 p-2 rounded text-sm">
                <div className="flex justify-between items-center mb-1"> <span className="font-semibold"><XPIcon />ê²½í—˜ì¹˜:</span> <span>{formatNumber(stats.xp)} / {formatNumber(stats.maxXp)}</span> </div>
                <div className="w-full bg-gray-600 rounded-full h-3"> <div className="bg-purple-500 h-3 rounded-full" style={{ width: `${(stats.xp / stats.maxXp) * 100}%` }}></div> </div>
            </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><CoinIcon />ê³¨ë“œ:</span> <span className="font-bold text-lg text-yellow-400">{formatNumber(stats.coins)}</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><SwordIcon />í´ë¦­ ë°ë¯¸ì§€:</span> <span>{formatNumber(stats.clickDamage)}</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><DpsIcon />ìë™ ê³µê²© ë°ë¯¸ì§€:</span> <span>{formatNumber(stats.autoAttackDamage)}</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><AttackSpeedIcon />ê³µê²© ì†ë„:</span> <span>{stats.attackSpeed.toFixed(1)} / s</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><CritIcon />í¬ë¦¬ í™•ë¥ :</span> <span>{Math.round(stats.critChance)}%</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><CritIcon />í¬ë¦¬ ë°ë¯¸ì§€:</span> <span>{Math.round(stats.critDamage)}%</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><LuckIcon />í–‰ìš´:</span> <span>{stats.luck}</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-xs"> <span className="font-semibold text-cyan-400"><CoinIcon />ê³¨ë“œ ë³´ë„ˆìŠ¤:</span> <span className="text-cyan-400">+{Math.round(abilityStats.goldGainBonus)}%</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-xs"> <span className="font-semibold text-purple-400"><XPIcon />ê²½í—˜ì¹˜ ë³´ë„ˆìŠ¤:</span> <span className="text-purple-400">+{Math.round(abilityStats.xpGainBonus)}%</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-xs"> <span className="font-semibold text-red-400"><BossIcon />ë³´ìŠ¤ ë°ë¯¸ì§€:</span> <span className="text-red-400">+{Math.round(abilityStats.bossDamageBonus)}%</span> </div>
        </div>
        <button onClick={onReset} className="mt-4 w-full bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg text-sm shadow-lg">
            ê²Œì„ ì´ˆê¸°í™”
        </button>
    </div>
);


const EquipmentTooltip = ({ item }) => {
    if (!item) return null;
    const rarityInfo = RARITIES[item.rarity];
    const typeInfo = EQUIPMENT_TYPES[item.type];
    const enhancedStats = getEnhancedItemStats(item);

    return (
        <div className="tooltiptext">
            <p className={`font-bold text-lg ${rarityInfo.textClass}`}>{item.name} {item.level > 0 ? `+${item.level}`: ''}</p>
            <p className="text-sm text-gray-400 mb-2"> <span className={rarityInfo.textClass}>[{rarityInfo.name}]</span> <span> {typeInfo.name}</span> </p>
            <hr className="border-gray-600 my-2" />
            <div className="space-y-1 text-sm">
                {enhancedStats.clickDamage > 0 && <p className="flex items-center"><SwordIcon className="h-4 w-4 mr-1.5" /> <span>í´ë¦­ ë°ë¯¸ì§€ +{formatNumber(enhancedStats.clickDamage)}</span></p>}
                {enhancedStats.autoAttackDamage > 0 && <p className="flex items-center"><DpsIcon className="h-4 w-4 mr-1.5" /> <span>ìë™ ê³µê²© +{formatNumber(enhancedStats.autoAttackDamage)}</span></p>}
                {enhancedStats.critChance > 0 && <p className="flex items-center"><CritIcon className="h-4 w-4 mr-1.5" /> <span>í¬ë¦¬ í™•ë¥  +{Math.round(enhancedStats.critChance)}%</span></p>}
                {enhancedStats.critDamage > 0 && <p className="flex items-center"><CritIcon className="h-4 w-4 mr-1.5" /> <span>í¬ë¦¬ ë°ë¯¸ì§€ +{formatNumber(enhancedStats.critDamage)}%</span></p>}
                {enhancedStats.attackSpeedBonus > 0 && <p className="flex items-center"><AttackSpeedIcon className="h-4 w-4 mr-1.5" /> <span>ê³µê²© ì†ë„ +{Math.round(enhancedStats.attackSpeedBonus)}%</span></p>}
                {enhancedStats.hasteBonus > 0 && <p className="flex items-center"><DpsIcon className="h-4 w-4 mr-1.5" /> <span>ê°€ì† +{Math.round(enhancedStats.hasteBonus)}%</span></p>}
                {enhancedStats.goldGainBonus > 0 && <p className="flex items-center"><CoinIcon className="h-4 w-4 mr-1.5" /> <span>ê³¨ë“œ íšë“ +{Math.round(enhancedStats.goldGainBonus)}%</span></p>}
                {enhancedStats.xpGainBonus > 0 && <p className="flex items-center"><XPIcon className="h-4 w-4 mr-1.5" /> <span>ê²½í—˜ì¹˜ íšë“ +{Math.round(enhancedStats.xpGainBonus)}%</span></p>}
                {enhancedStats.luckBonus > 0 && <p className="flex items-center"><LuckIcon className="h-4 w-4 mr-1.5" /> <span>í–‰ìš´ +{Math.round(enhancedStats.luckBonus)}</span></p>}
            </div>
            {item.locked && <p className="mt-2 text-yellow-400 font-bold flex items-center"><LockIcon className="w-4 h-4 mr-1"/> ì ê¸ˆ ìƒíƒœ</p>}
        </div>
    );
};

const EquipmentSlot = ({ item, type, onClick }) => {
    const IconComponent = EQUIPMENT_TYPES[type].icon;
    const rarityInfo = item ? RARITIES[item.rarity] : null;

    return (
        <div className="tooltip" onClick={onClick}>
             <div className={`bg-gray-700 p-2 rounded h-16 flex items-center border-2 ${item ? `${rarityInfo.borderClass} cursor-pointer hover:bg-gray-600` : 'border-gray-600'}`}>
                <IconComponent className="h-8 w-8 text-gray-400 mr-2" />
                {item ? ( <div> <p className={`font-semibold text-sm ${rarityInfo.textClass}`}>{item.name} {item.level > 0 ? `+${item.level}` : ''}</p> <p className="text-xs text-gray-400">{rarityInfo.name}</p> </div> ) : ( <p className="text-gray-500">ë¹„ì–´ìˆìŒ</p> )}
            </div>
            <EquipmentTooltip item={item} />
        </div>
    );
};


const EquipmentPanel = ({ equipment, onSelectItem }) => (
    <div className="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h2 className="text-2xl font-bold mb-4 text-green-400">ì¥ë¹„</h2>
        <div className="grid grid-cols-2 gap-2">
            <EquipmentSlot item={equipment.weapon} type="WEAPON" onClick={() => onSelectItem(equipment.weapon)} />
            <EquipmentSlot item={equipment.helmet} type="HELMET" onClick={() => onSelectItem(equipment.helmet)} />
            <EquipmentSlot item={equipment.armor} type="ARMOR" onClick={() => onSelectItem(equipment.armor)} />
            <EquipmentSlot item={equipment.gloves} type="GLOVES" onClick={() => onSelectItem(equipment.gloves)} />
            <EquipmentSlot item={equipment.amulet} type="AMULET" onClick={() => onSelectItem(equipment.amulet)} />
            <EquipmentSlot item={equipment.boots} type="BOOTS" onClick={() => onSelectItem(equipment.boots)} />
            <EquipmentSlot item={equipment.ring} type="RING" onClick={() => onSelectItem(equipment.ring)} />
            <EquipmentSlot item={equipment.cloak} type="CLOAK" onClick={() => onSelectItem(equipment.cloak)} />
        </div>
    </div>
);

const ElementPanel = ({ playerElement, onOpenModal }) => (
    <div className="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h2 className="text-2xl font-bold mb-4 text-green-400 flex items-center"><ElementIcon className="w-6 h-6 mr-2" /> ì›ì†Œ</h2>
        <div className="flex items-center justify-between bg-gray-700 p-3 rounded-lg">
            {playerElement ? (
                <div className="flex items-center gap-3">
                    {React.createElement(ELEMENT_TYPES[playerElement].icon, { className: 'h-10 w-10' })}
                    <span className="text-xl font-bold">{ELEMENT_TYPES[playerElement].name}</span>
                </div>
            ) : (
                <span className="text-gray-400">ì›ì†Œë¥¼ ì„ íƒí•˜ì„¸ìš”</span>
            )}
            <button onClick={onOpenModal} className="text-sm bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded-md transition-colors">ë³€ê²½</button>
        </div>
    </div>
);

const EquippedArtifactsPanel = ({ equipped, onSlotClick }) => (
    <div className="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h2 className="text-2xl font-bold mb-4 text-green-400 flex items-center"><ArtifactIcon className="w-6 h-6 mr-2" /> ìœ ë¬¼</h2>
        <div className="grid grid-cols-3 gap-2">
            {[0, 1, 2].map(index => {
                const artifactId = equipped[index];
                const artifact = artifactId ? ARTIFACTS.find(a => a.id === artifactId) : null;
                const tooltipText = artifact ? `${artifact.name}: ${artifact.description}` : "ë¹„ì–´ìˆëŠ” ìœ ë¬¼ ìŠ¬ë¡¯ì…ë‹ˆë‹¤. ì˜¤ë¥¸ìª½ 'ìœ ë¬¼' íƒ­ì—ì„œ ì¥ì°©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
                
                return (
                    <div key={index} onClick={onSlotClick} className="tooltip">
                        <div className={`aspect-square flex items-center justify-center p-1 border-2 rounded-md cursor-pointer hover:bg-gray-700 transition-colors ${artifact ? 'border-yellow-400 bg-gray-800' : 'border-gray-600 bg-gray-700'}`}>
                            {artifact ? <artifact.icon className="h-8 w-8 text-yellow-400" /> : <span className="text-gray-500 text-3xl font-bold">?</span>}
                        </div>
                        <span className="tooltiptext">{tooltipText}</span>
                    </div>
                );
            })}
        </div>
    </div>
);

const MonsterDisplay = ({ monster, onClick, damagePopups, treasureGolem, children = null }) => {
    const MonsterIcon = monster.Icon;
    const isTreasureGolem = treasureGolem.isActive;
    const ElementInfo = monster.element ? ELEMENT_TYPES[monster.element] : null;

    return (
        <div className="transition-transform duration-100 flex flex-col items-center">
             <h2 className={`text-3xl font-bold text-center mb-2 flex items-center justify-center gap-2 ${monster.isBoss ? 'text-red-400' : ''} ${isTreasureGolem ? 'text-yellow-400' : ''}`}>
                {ElementInfo && React.createElement(ElementInfo.icon, { className: 'h-8 w-8' })}
                <span>{monster.isBoss ? `[BOSS] ${monster.name}` : monster.name} (Lv.{monster.level})</span>
            </h2>
            {isTreasureGolem && <p className="text-center text-2xl font-bold text-yellow-300 mb-2">ë‚¨ì€ ì‹œê°„: {treasureGolem.timer}ì´ˆ</p>}
            <div className={`w-full max-w-md bg-gray-700 rounded-full h-6 mb-2 border-2 ${monster.isBoss ? 'border-red-400' : 'border-gray-600'}`}>
                <div className="bg-red-500 h-full rounded-full transition-width duration-300" style={{ width: `${(monster.hp / monster.maxHp) * 100}%` }}> </div>
            </div>
            <p className="text-center font-bold text-lg mb-4"> {formatNumber(monster.hp)} / {formatNumber(monster.maxHp)} </p>
            <div className="relative cursor-pointer" onClick={onClick} style={{ userSelect: 'none' }}>
                <MonsterIcon className="w-64 h-64 sm:w-80 sm:h-80 md:w-96 md:h-96 mx-auto" />
                {damagePopups.map(popup => (
                    <div key={popup.id}
                         className={`absolute font-bold text-2xl pointer-events-none 
                            ${popup.type === 'skill' ? 'text-orange-400 animate-damage-popup-skill' : ''}
                            ${popup.type === 'normal' ? 'text-yellow-300 animate-damage-popup' : ''}
                            ${popup.type === 'crit' ? 'text-yellow-200 animate-damage-popup-crit' : ''}
                            ${popup.type === 'elemental' ? 'text-transparent bg-clip-text bg-gradient-to-r from-pink-400 via-purple-400 to-indigo-500 animate-damage-popup-elemental' : ''}
                            ${popup.type === 'resist' ? 'text-gray-400 animate-damage-popup-resist' : ''}
                         `}
                         style={{ left: `${popup.x}%`, top: `${popup.y}%` }}>
                        {popup.prefix}{formatNumber(popup.damage)}
                    </div>
                ))}
            </div>
            {children}
        </div>
    );
};

const UpgradePanel = ({ upgrades, playerCoins, handlers, abilityStats, equipmentGachaCost, onLiberate, liberationCost, liberationCount, onRebirth, playerLevel, rebirthCount }) => (
    <div>
        <h3 className="text-lg font-semibold mb-2 text-green-300">ì „íˆ¬ ëŠ¥ë ¥</h3>
        <div className="space-y-2">
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeClick} disabled={playerCoins < upgrades.clickUpgradeCost} className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    ê²€ ê°•í™” (+{upgrades.clickUpgradeLevel}) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.clickUpgradeCost)}
                </button>
                 <span className="tooltiptext"> <p className="font-bold">í´ë¦­ ë°ë¯¸ì§€ ì¦ê°€</p> <p className="text-sm text-gray-300">í´ë¦­ë‹¹ ê³µê²©ë ¥ì„ ë†’ì—¬ ëª¬ìŠ¤í„°ë¥¼ ë” ë¹ ë¥´ê²Œ ì²˜ì¹˜í•©ë‹ˆë‹¤.</p> </span>
            </div>
             <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeAutoAttack} disabled={playerCoins < upgrades.autoAttackUpgradeCost} className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    ìë™ ê³µê²© ê°•í™” (+{upgrades.autoAttackUpgradeLevel}) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.autoAttackUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">ìë™ ê³µê²© ë°ë¯¸ì§€ ì¦ê°€</p> <p className="text-sm text-gray-300">ìë™ ê³µê²©ì˜ ê¸°ë³¸ ë°ë¯¸ì§€ë¥¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤.</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeAttackSpeed} disabled={playerCoins < upgrades.attackSpeedUpgradeCost} className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    ê³µê²© ì†ë„ ì¦ê°€ (+0.1) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.attackSpeedUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">ê³µê²© ì†ë„ ì¦ê°€</p> <p className="text-sm text-gray-300">ì´ˆë‹¹ ìë™ ê³µê²© íšŸìˆ˜ë¥¼ ëŠ˜ë ¤ DPSë¥¼ ê·¹ëŒ€í™”í•©ë‹ˆë‹¤.</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeCritChance} disabled={playerCoins < upgrades.critChanceUpgradeCost} className="w-full bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    í¬ë¦¬ í™•ë¥  (+{CRIT_CHANCE_UPGRADE_INCREASE}%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.critChanceUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">í¬ë¦¬í‹°ì»¬ í™•ë¥  ì¦ê°€</p> <p className="text-sm text-gray-300">ëª¨ë“  ê³µê²©ì— ì ìš©ë˜ëŠ” ê°•ë ¥í•œ ëŠ¥ë ¥ì¹˜ì…ë‹ˆë‹¤.</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeCritDamage} disabled={playerCoins < upgrades.critDamageUpgradeCost} className="w-full bg-yellow-800 hover:bg-yellow-900 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    í¬ë¦¬ ë°ë¯¸ì§€ (+{CRIT_DAMAGE_UPGRADE_INCREASE}%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.critDamageUpgradeCost)}
                </button>
                 <span className="tooltiptext"> <p className="font-bold">í¬ë¦¬í‹°ì»¬ ë°ë¯¸ì§€ ì¦ê°€</p> <p className="text-sm text-gray-300">í¬ë¦¬í‹°ì»¬ ë°ë¯¸ì§€ ë°°ìœ¨ì„ ì¦ê°€ì‹œí‚µë‹ˆë‹¤.</p> </span>
            </div>
             <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeBossDamage} disabled={playerCoins < upgrades.bossDamageUpgradeCost} className="w-full bg-red-800 hover:bg-red-900 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    ë³´ìŠ¤ ë°ë¯¸ì§€ (+2%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.bossDamageUpgradeCost)}
                </button>
                 <span className="tooltiptext"> <p className="font-bold">ë³´ìŠ¤ ë°ë¯¸ì§€ ì¦ê°€</p> <p className="text-sm text-gray-300">ë³´ìŠ¤ ëª¬ìŠ¤í„°ì—ê²Œ ì£¼ëŠ” ëª¨ë“  í”¼í•´ëŸ‰ì´ ì¦ê°€í•©ë‹ˆë‹¤.</p> <p className="text-sm text-red-300 mt-2">í˜„ì¬: +{Math.round(abilityStats.bossDamageBonus)}%</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeFinalDamage} disabled={playerCoins < upgrades.finalDamageUpgradeCost} className="w-full bg-slate-700 hover:bg-slate-600 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    ìµœì¢… ë°ë¯¸ì§€ (+1%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.finalDamageUpgradeCost)}
                </button>
                <span className="tooltiptext">
                    <p className="font-bold">ìµœì¢… ë°ë¯¸ì§€ ì¦ê°€</p>
                    <p className="text-sm text-gray-300">ëª¨ë“  ë°ë¯¸ì§€ ê³„ì‚°ì´ ëë‚œ í›„ ì¶”ê°€ë¡œ ì ìš©ë˜ëŠ” ê°•ë ¥í•œ ì¦í­ íš¨ê³¼ì…ë‹ˆë‹¤.</p>
                    <p className="text-sm text-slate-300 mt-2">í˜„ì¬: +{Math.round(abilityStats.finalDamageBonus)}%</p>
                </span>
            </div>
        </div>

        <h3 className="text-lg font-semibold mt-4 mb-2 text-green-300">ë³´ì¡° ëŠ¥ë ¥</h3>
        <div className="space-y-2">
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeGoldGain} disabled={playerCoins < upgrades.goldGainUpgradeCost} className="w-full bg-cyan-600 hover:bg-cyan-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    ê³¨ë“œ íšë“ (+5%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.goldGainUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">ê³¨ë“œ íšë“ëŸ‰ ì¦ê°€</p> <p className="text-sm text-gray-300">ë” ë¹ ë¥¸ ì„±ì¥ì„ ìœ„í•œ í•„ìˆ˜ íˆ¬ìì…ë‹ˆë‹¤.</p> <p className="text-sm text-cyan-300 mt-2">í˜„ì¬: +{Math.round(abilityStats.goldGainBonus)}%</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeXpGain} disabled={playerCoins < upgrades.xpGainUpgradeCost} className="w-full bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    ê²½í—˜ì¹˜ íšë“ (+5%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.xpGainUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">ê²½í—˜ì¹˜ íšë“ëŸ‰ ì¦ê°€</p> <p className="text-sm text-gray-300">ë¹ ë¥¸ ë ˆë²¨ì—…ì„ ë•ìŠµë‹ˆë‹¤.</p> <p className="text-sm text-purple-300 mt-2">í˜„ì¬: +{Math.round(abilityStats.xpGainBonus)}%</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeLuck} disabled={playerCoins < upgrades.luckUpgradeCost} className="w-full bg-pink-500 hover:bg-pink-600 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    í–‰ìš´ ì¦ê°€ (+1) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.luckUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">í–‰ìš´ ì¦ê°€</p> <p className="text-sm text-gray-300">ì¥ë¹„ íšë“ í™•ë¥ ê³¼ ë“±ê¸‰ì„ ë†’ì—¬ì¤ë‹ˆë‹¤.</p> <p className="text-sm text-pink-300 mt-2">í˜„ì¬: {abilityStats.luck} í–‰ìš´</p> </span>
            </div>
        </div>

        <h3 className="text-lg font-semibold mt-4 mb-2 text-green-300">ìŠ¤í‚¬ ê°•í™”</h3>
        <div className="space-y-2">
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeSkillDamage} disabled={playerCoins < upgrades.skillDamageUpgradeCost} className="w-full bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    ìŠ¤í‚¬ ê³µê²©ë ¥ (+10%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.skillDamageUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">ìŠ¤í‚¬ ë°ë¯¸ì§€ ê°•í™”</p> <p className="text-sm text-gray-300">ì•¡í‹°ë¸Œ ìŠ¤í‚¬ì˜ íš¨ê³¼ë¥¼ ê°•í™”í•©ë‹ˆë‹¤.</p> <p className="text-sm text-orange-300 mt-2">í˜„ì¬: +{Math.round(abilityStats.skillDamageBonus)}%</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeHaste} disabled={playerCoins < upgrades.hasteUpgradeCost} className="w-full bg-teal-600 hover:bg-teal-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    ê°€ì† (+1%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.hasteUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">ê°€ì† (ì¿¨íƒ€ì„ ê°ì†Œ)</p> <p className="text-sm text-gray-300">ìŠ¤í‚¬ ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ì„ ì¤„ì…ë‹ˆë‹¤.</p> <p className="text-sm text-teal-300 mt-2">í˜„ì¬: ì¿¨íƒ€ì„ -{Math.round(abilityStats.haste)}%</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeSkillDuration} disabled={playerCoins < upgrades.skillDurationUpgradeCost} className="w-full bg-lime-600 hover:bg-lime-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    ìŠ¤í‚¬ ì§€ì†ì‹œê°„ (+2%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.skillDurationUpgradeCost)}
                </button>
                <span className="tooltiptext">
                    <p className="font-bold">ìŠ¤í‚¬ ì§€ì†ì‹œê°„ ì¦ê°€</p>
                    <p className="text-sm text-gray-300">ë²„í”„ ë° ë””ë²„í”„ ìŠ¤í‚¬ì˜ ì§€ì†ì‹œê°„ì„ ëŠ˜ë¦½ë‹ˆë‹¤.</p>
                    <p className="text-sm text-lime-300 mt-2">í˜„ì¬: +{Math.round(abilityStats.skillDurationBonus)}%</p>
                </span>
            </div>
        </div>

        <h3 className="text-lg font-semibold mt-4 mb-2 text-green-300">ì§„í–‰</h3>
        <div className="space-y-2">
             <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeElementalPower} disabled={playerCoins < upgrades.elementalPowerUpgradeCost} className="w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 disabled:from-gray-600 disabled:to-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    <ElementIcon className="inline-block h-4 w-4 -mt-1" /> ì›ì†Œ ê°•í™” (+2%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.elementalPowerUpgradeCost)}
                </button>
                <span className="tooltiptext">
                    <p className="font-bold">ì›ì†Œ ê°•í™”</p>
                    <p className="text-sm text-gray-300">ëª¨ë“  ì›ì†Œì˜ ì§€ì† íš¨ê³¼ì™€ ê³µê²© íš¨ê³¼ë¥¼ ê°•í™”í•©ë‹ˆë‹¤.</p>
                    <p className="text-sm text-purple-300 mt-2">í˜„ì¬: +{Math.round(abilityStats.elementalPowerBonus)}%</p>
                </span>
            </div>
             <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeOfflineRewards} disabled={playerCoins < upgrades.offlineRewardsUpgradeCost} className="w-full bg-gray-500 hover:bg-gray-400 disabled:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    <OfflineIcon className="inline-block h-4 w-4 -mt-1" /> ì˜¤í”„ë¼ì¸ ë³´ìƒ (+2%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.offlineRewardsUpgradeCost)}
                </button>
                <span className="tooltiptext">
                    <p className="font-bold">ì˜¤í”„ë¼ì¸ ë³´ìƒ ê°•í™”</p>
                    <p className="text-sm text-gray-300">ê²Œì„ì„ êº¼ë’€ì„ ë•Œ ë°›ëŠ” ê³¨ë“œì™€ ê²½í—˜ì¹˜ ë³´ìƒì„ ëŠ˜ë¦½ë‹ˆë‹¤.</p>
                    <p className="text-sm text-gray-300 mt-2">í˜„ì¬: +{Math.round(abilityStats.offlineRewardsBonus)}%</p>
                </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeTreasureGolemChance} disabled={playerCoins < upgrades.treasureGolemChanceUpgradeCost} className="w-full bg-yellow-500 hover:bg-yellow-400 disabled:bg-gray-600 text-black font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    <CoinIcon className="inline-block h-4 w-4 -mt-1" /> ë³´ë¬¼ ê³¨ë ˜ í™•ë¥  (+0.1%p) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.treasureGolemChanceUpgradeCost)}
                </button>
                <span className="tooltiptext">
                    <p className="font-bold">ë³´ë¬¼ ê³¨ë ˜ ë“±ì¥ í™•ë¥ </p>
                    <p className="text-sm text-gray-300">ë§‰ëŒ€í•œ ê³¨ë“œë¥¼ ì£¼ëŠ” í¬ê·€ ëª¬ìŠ¤í„°ì˜ ë“±ì¥ í™•ë¥ ì„ ë†’ì…ë‹ˆë‹¤.</p>
                    <p className="text-sm text-yellow-300 mt-2">{(TREASURE_GOLEM_SPAWN_CHANCE + (abilityStats.treasureGolemChanceBonus / 100)).toFixed(2)}%</p>
                </span>
            </div>
        </div>

        <h3 className="text-lg font-semibold mt-4 mb-2 text-green-300">íŠ¹ë³„</h3>
         <div className="space-y-2">
            <div className="tooltip w-full">
                <button onClick={handlers.onEquipmentGacha} disabled={playerCoins < equipmentGachaCost} className="w-full bg-pink-600 hover:bg-pink-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    <GachaIcon className="inline-block h-4 w-4 -mt-1" /> ì¥ë¹„ ë½‘ê¸° | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(equipmentGachaCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">ì¥ë¹„ ë½‘ê¸°</p> <p className="text-sm text-gray-300">ê³¨ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë¬´ì‘ìœ„ ì¥ë¹„ë¥¼ íšë“í•©ë‹ˆë‹¤.</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeArtifactPower} disabled={playerCoins < upgrades.artifactPowerUpgradeCost} className="w-full bg-yellow-500 hover:bg-yellow-600 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    <ArtifactIcon className="inline-block h-4 w-4 -mt-1" /> ìœ ë¬¼ë ¥ ê°•í™” (+1%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.artifactPowerUpgradeCost)}
                </button>
                <span className="tooltiptext">
                    <p className="font-bold">ìœ ë¬¼ë ¥ ê°•í™”</p>
                    <p className="text-sm text-gray-300">ì¥ì°©í•œ ëª¨ë“  ìœ ë¬¼ì˜ íš¨ê³¼ë¥¼ ì¦í­ì‹œí‚µë‹ˆë‹¤.</p>
                    <p className="text-sm text-yellow-300 mt-2">í˜„ì¬: +{Math.round(abilityStats.artifactPowerBonus)}%</p>
                </span>
            </div>
        </div>
        
        <h3 className="text-lg font-semibold mt-4 mb-2 text-green-300">ì´ˆì›”</h3>
        <div className="space-y-2">
            <LiberationButton onLiberate={onLiberate} cost={liberationCost} playerCoins={playerCoins} count={liberationCount} />
            <RebirthButton onRebirth={onRebirth} level={playerLevel} count={rebirthCount} />
        </div>
    </div>
);

const InventoryPanel = ({ inventory, onSelectItem, isSellMode, onToggleSellMode, sellList, onToggleSellItem, onBulkSell, onBulkSellByRarity }) => {
    const [filter, setFilter] = useState('ALL');

    const filteredInventory = useMemo(() => {
        if (filter === 'ALL') return inventory;
        return inventory.filter(item => item.type === filter);
    }, [inventory, filter]);

    const FilterButton = ({ type, children }) => {
        const isActive = filter === type;
        return (
            <button
                onClick={() => setFilter(type)}
                className={`flex-1 p-2 rounded-md text-sm transition-colors ${isActive ? 'bg-green-600 text-white font-bold' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
            >
                {children}
            </button>
        );
    };

    return (
        <div>
            <div className="flex justify-between items-center mb-2">
                 <h3 className="text-lg font-semibold text-green-300">ì¸ë²¤í† ë¦¬</h3>
                 <div className="flex items-center gap-2">
                    <span className="text-sm text-gray-400">{inventory.length}ê°œ</span>
                    <button onClick={onToggleSellMode} className={`text-sm py-1 px-2 rounded ${isSellMode ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-600 hover:bg-gray-500 text-gray-200'}`}>íŒë§¤ ëª¨ë“œ</button>
                 </div>
            </div>
            <div className="grid grid-cols-4 gap-1 mb-2">
                <FilterButton type="ALL" children={'ì „ì²´'} />
                <FilterButton type="WEAPON" children={<SwordIcon className="w-5 h-5 mx-auto"/>} />
                <FilterButton type="ARMOR" children={<ArmorIcon className="w-5 h-5 mx-auto"/>} />
                <FilterButton type="AMULET" children={<AmuletIcon className="w-5 h-5 mx-auto"/>} />
                <FilterButton type="HELMET" children={<HelmetIcon className="w-5 h-5 mx-auto"/>} />
                <FilterButton type="GLOVES" children={<GlovesIcon className="w-5 h-5 mx-auto"/>} />
                <FilterButton type="BOOTS" children={<BootsIcon className="w-5 h-5 mx-auto"/>} />
                <FilterButton type="RING" children={<RingIcon className="w-5 h-5 mx-auto"/>} />
                <FilterButton type="CLOAK" children={<CloakIcon className="w-5 h-5 mx-auto"/>} />
            </div>
            <div className="grid grid-cols-4 gap-2 h-[280px] overflow-y-auto bg-gray-900/50 p-2 rounded">
                {filteredInventory.map(item => {
                    const rarityInfo = RARITIES[item.rarity];
                    const IconComponent = EQUIPMENT_TYPES[item.type].icon;
                    const isSelected = sellList.has(item.id);
                    return (
                        <div key={item.id} className="tooltip" onClick={() => isSellMode ? onToggleSellItem(item) : onSelectItem(item)}>
                            <div className={`relative aspect-square flex items-center justify-center p-1 border-2 ${rarityInfo.borderClass} bg-gray-800 rounded-md cursor-pointer hover:bg-gray-700 transition-colors ${isSelected ? 'ring-2 ring-red-500 ring-offset-2 ring-offset-gray-800' : ''}`}>
                                 <IconComponent className={`h-8 w-8 ${rarityInfo.textClass}`} />
                                 {item.level > 0 && <span className="absolute bottom-0 right-0 text-xs bg-gray-900 px-1 rounded-sm">+{item.level}</span>}
                                 {isSelected && <div className="absolute inset-0 bg-red-500/50 flex items-center justify-center"><CoinIcon className="w-6 h-6 text-white"/></div>}
                                 {item.locked && <LockIcon className="absolute top-1 left-1 h-4 w-4 text-yellow-400" />}
                            </div>
                            <EquipmentTooltip item={item} />
                        </div>
                    );
                })}
            </div>
            {isSellMode ? (
                <div className="mt-2 p-2 bg-gray-900/50 rounded">
                    <p className="text-center mb-2 text-sm text-gray-300">{sellList.size}ê°œ ì•„ì´í…œ ì„ íƒë¨</p>
                    <button
                        onClick={onBulkSell}
                        disabled={sellList.size === 0}
                        className="w-full bg-red-600 hover:bg-red-700 disabled:bg-gray-500 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors"
                    >
                        ì„ íƒ ì•„ì´í…œ íŒë§¤
                    </button>
                </div>
            ) : (
                <div className="mt-2 p-2 bg-gray-900/50 rounded text-center">
                    <p className="text-sm text-gray-400 mb-2">ì¼ê´„ íŒë§¤</p>
                    <div className="grid grid-cols-3 gap-2">
                        <button onClick={() => onBulkSellByRarity('COMMON')} className="bg-gray-600 hover:bg-gray-500 text-xs py-2 px-1 rounded transition-colors">ì¼ë°˜ ë“±ê¸‰</button>
                        <button onClick={() => onBulkSellByRarity('UNCOMMON')} className="bg-green-800 hover:bg-green-700 text-xs py-2 px-1 rounded transition-colors">ê³ ê¸‰ ë“±ê¸‰</button>
                        <button onClick={() => onBulkSellByRarity('RARE')} className="bg-blue-800 hover:bg-blue-700 text-xs py-2 px-1 rounded transition-colors">í¬ê·€ ë“±ê¸‰</button>
                    </div>
                </div>
            )}
        </div>
    );
};


const ForgePanel = ({ selectedItem, handlers, playerCoins }) => {
    const [forgeTab, setForgeTab] = useState('enhance');

    if (!selectedItem) {
        return (
            <div>
                 <h3 className="text-lg font-semibold mb-2 text-green-300">ëŒ€ì¥ê°„</h3>
                 <div className="h-[420px] flex items-center justify-center text-gray-500">
                     <p>ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”.</p>
                 </div>
            </div>
        );
    }
    
    const { onForge, onUpgradeRarity, onReforge } = handlers;
    const rarityInfo = RARITIES[selectedItem.rarity];
    const itemLevel = selectedItem.level || 0;

    const renderStats = (item) => {
        const stats = getEnhancedItemStats(item);
        
        return (
             <div className="space-y-1 text-sm p-2 bg-gray-900/50 rounded">
                {stats.clickDamage > 0 && <p>í´ë¦­ ë°ë¯¸ì§€ +{formatNumber(stats.clickDamage)}</p>}
                {stats.autoAttackDamage > 0 && <p>ìë™ ê³µê²© +{formatNumber(stats.autoAttackDamage)}</p>}
                {stats.critChance > 0 && <p>í¬ë¦¬ í™•ë¥  +{Math.round(stats.critChance)}%</p>}
                {stats.critDamage > 0 && <p>í¬ë¦¬ ë°ë¯¸ì§€ +{formatNumber(stats.critDamage)}%</p>}
                {stats.attackSpeedBonus > 0 && <p>ê³µê²© ì†ë„ +{Math.round(stats.attackSpeedBonus)}%</p>}
                {stats.hasteBonus > 0 && <p>ê°€ì† +{Math.round(stats.hasteBonus)}%</p>}
                {stats.goldGainBonus > 0 && <p>ê³¨ë“œ íšë“ +{Math.round(stats.goldGainBonus)}%</p>}
                {stats.xpGainBonus > 0 && <p>ê²½í—˜ì¹˜ íšë“ +{Math.round(stats.xpGainBonus)}%</p>}
                {stats.luckBonus > 0 && <p>í–‰ìš´ +{Math.round(stats.luckBonus)}</p>}
            </div>
        );
    };
    
    const renderEnhanceTab = () => {
        const upgradeCost = Math.ceil(rarityInfo.statMultiplier * 30 * Math.pow(1.35, itemLevel) * (1 + itemLevel * 0.1));
        return (
            <div className="space-y-3">
                 <div> <p className="font-semibold mb-1">í˜„ì¬ (+{itemLevel})</p> {renderStats(selectedItem)} </div>
                 <div> <p className="font-semibold mb-1">ë‹¤ìŒ (+{itemLevel + 1})</p> {renderStats({ ...selectedItem, level: itemLevel + 1 })} </div>
                <div className="text-center">
                    <p className="mb-2 flex items-center justify-center">ë¹„ìš©: <CoinIcon/> {formatNumber(upgradeCost)}</p>
                    <button onClick={() => onForge(selectedItem)} disabled={playerCoins < upgradeCost} className="w-full bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded">
                        ê°•í™”í•˜ê¸°
                    </button>
                </div>
            </div>
        );
    };

    const renderUpgradeRarityTab = () => {
        const currentRarityIndex = RARITY_ORDER.indexOf(selectedItem.rarity);
        if (currentRarityIndex === -1 || currentRarityIndex >= RARITY_ORDER.length - 1) {
            return <div className="text-center text-gray-400 py-8">ìµœê³  ë“±ê¸‰ ì•„ì´í…œì…ë‹ˆë‹¤.</div>;
        }
        const nextRarityKey = RARITY_ORDER[currentRarityIndex + 1];
        
        const upgradeCost = Math.ceil(Math.pow(8, currentRarityIndex + 1.5) * (selectedItem.baseLevel || 1) * rarityInfo.statMultiplier * 10);
        const canUpgrade = playerCoins >= upgradeCost;

        return (
             <div className="space-y-3 text-center">
                 <p>í˜„ì¬ ë“±ê¸‰: <span className={rarityInfo.textClass}>{rarityInfo.name}</span></p>
                 <p className="text-2xl font-bold my-4">â–¼</p>
                 <p>ë‹¤ìŒ ë“±ê¸‰: <span className={RARITIES[nextRarityKey].textClass}>{RARITIES[nextRarityKey].name}</span></p>
                 <div className="mt-6">
                    <p className="mb-2 flex items-center justify-center">ë¹„ìš©: <CoinIcon/> {formatNumber(upgradeCost)}</p>
                     <button onClick={() => onUpgradeRarity(selectedItem)} disabled={!canUpgrade} className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded">
                        ë“±ê¸‰ ìŠ¹ê¸‰
                    </button>
                 </div>
            </div>
        );
    };

    const renderReforgeTab = () => {
        const cost = Math.ceil(rarityInfo.statMultiplier * 500 * (1 + itemLevel * 0.5) * (selectedItem.baseLevel || 1));
        const canReforge = playerCoins >= cost;
         return (
             <div className="space-y-3">
                 <div> <p className="font-semibold mb-1">í˜„ì¬ ëŠ¥ë ¥ì¹˜</p> {renderStats(selectedItem)} </div>
                 <p className="text-sm text-gray-400 text-center">ì•„ì´í…œì˜ ê¸°ë³¸ ëŠ¥ë ¥ì¹˜ë¥¼ ë¬´ì‘ìœ„ë¡œ ì¬ì„¤ì •í•©ë‹ˆë‹¤.</p>
                 <div className="text-center mt-4">
                    <p className="mb-2 flex items-center justify-center">ë¹„ìš©: <CoinIcon/> {formatNumber(cost)}</p>
                     <button onClick={() => onReforge(selectedItem)} disabled={!canReforge} className="w-full bg-pink-600 hover:bg-pink-700 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded">
                        ëŠ¥ë ¥ì¹˜ ì¬ë ¨
                    </button>
                 </div>
            </div>
        );
    }

    return (
        <div>
            <h3 className="text-lg font-semibold mb-2 text-green-300">ëŒ€ì¥ê°„</h3>
             <div className={`p-2 rounded border-2 ${rarityInfo.borderClass} bg-gray-800 mb-4`}>
                <p className={`font-bold text-lg ${rarityInfo.textClass}`}>{selectedItem.name} {itemLevel > 0 ? `+${itemLevel}` : ''}</p>
            </div>
            <div className="flex border-b border-gray-700 mb-4 text-sm">
                <button onClick={() => setForgeTab('enhance')} className={`flex-1 py-2 text-center font-semibold ${forgeTab === 'enhance' ? 'text-yellow-400 border-b-2 border-yellow-400' : 'text-gray-400'}`}>ê°•í™”</button>
                <button onClick={() => setForgeTab('upgrade')} className={`flex-1 py-2 text-center font-semibold ${forgeTab === 'upgrade' ? 'text-purple-400 border-b-2 border-purple-400' : 'text-gray-400'}`}>ìŠ¹ê¸‰</button>
                <button onClick={() => setForgeTab('reforge')} className={`flex-1 py-2 text-center font-semibold ${forgeTab === 'reforge' ? 'text-pink-400 border-b-2 border-pink-400' : 'text-gray-400'}`}>ì¬ë ¨</button>
            </div>

            {forgeTab === 'enhance' && renderEnhanceTab()}
            {forgeTab === 'upgrade' && renderUpgradeRarityTab()}
            {forgeTab === 'reforge' && renderReforgeTab()}
        </div>
    );
};

const MissionsPanel = ({ missions, onClaim }) => (
    <div>
        <h3 className="text-lg font-semibold mb-2 text-green-300">ì„ë¬´</h3>
        <div className="space-y-3 h-[420px] overflow-y-auto pr-2">
            {missions.length > 0 ? missions.map(mission => (
                <div key={mission.id} className="bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                    <p className="font-semibold text-gray-200">{MISSION_TYPES[mission.type]}</p>
                    <div className="w-full bg-gray-600 rounded-full h-2.5 my-1">
                        <div className="bg-teal-500 h-2.5 rounded-full" style={{ width: `${(mission.progress / mission.target) * 100}%` }}></div>
                    </div>
                    <p className="text-sm text-gray-400 mb-2">{formatNumber(mission.progress)} / {formatNumber(mission.target)}</p>
                    {mission.isCompleted ? (
                        <button onClick={() => onClaim(mission.id)} className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded text-sm transition-colors">
                            ë³´ìƒ ë°›ê¸° (+{formatNumber(mission.reward)} <CoinIcon className="h-4 w-4 inline-block -mt-1"/>)
                        </button>
                    ) : (
                        <p className="text-sm text-yellow-400 text-center">ë³´ìƒ: {formatNumber(mission.reward)} <CoinIcon className="h-4 w-4 inline-block -mt-1"/></p>
                    )}
                </div>
            )) : (
                <div className="h-full flex items-center justify-center text-gray-500">
                     <p>ëª¨ë“  ì„ë¬´ ì™„ë£Œ!</p>
                </div>
            )}
        </div>
    </div>
);

const ArtifactPanel = ({ owned, equipped, onEquip, onUnequip, onGacha, playerCoins }) => {
    const gachaCost = 1000;
    const allArtifactsOwned = owned.length >= ARTIFACTS.length;

    return (
        <div>
            <h3 className="text-lg font-semibold mb-2 text-green-300">ìœ ë¬¼</h3>
            <div className="bg-gray-900/50 p-2 rounded mb-3">
                <h4 className="text-md font-semibold mb-2 text-center text-yellow-300">ì¥ì°©ëœ ìœ ë¬¼</h4>
                <div className="grid grid-cols-3 gap-2">
                    {[0, 1, 2].map(index => {
                        const artifactId = equipped[index];
                        const artifact = artifactId ? ARTIFACTS.find(a => a.id === artifactId) : null;
                        return (
                            <div key={index} onClick={() => artifact && onUnequip(artifact.id)} className={`tooltip aspect-square flex items-center justify-center p-1 border-2 ${artifact ? 'border-yellow-400 bg-gray-800 cursor-pointer' : 'border-gray-600 bg-gray-700'}`}>
                                {artifact ? <artifact.icon className="h-8 w-8 text-yellow-400" /> : <span className="text-gray-500 text-xs">ë¹„ì–´ìˆìŒ</span>}
                                {artifact && <span className="tooltiptext">{artifact.name}: {artifact.description}</span>}
                            </div>
                        );
                    })}
                </div>
            </div>
            <div className="space-y-2 h-[240px] overflow-y-auto pr-2">
                <h4 className="text-md font-semibold text-center text-gray-300">ë³´ìœ í•œ ìœ ë¬¼</h4>
                {owned.length > 0 ? owned.map(id => {
                    const artifact = ARTIFACTS.find(a => a.id === id);
                    if (!artifact) return null;
                    const isEquipped = equipped.includes(id);
                    return (
                        <div key={id} onClick={() => !isEquipped && onEquip(id)} className={`bg-gray-800 p-3 rounded-lg border border-gray-600 flex items-center gap-3 ${isEquipped ? 'opacity-50' : 'cursor-pointer hover:bg-gray-700'}`}>
                            <artifact.icon className="w-8 h-8 text-yellow-400 flex-shrink-0" />
                            <div>
                                <p className="font-semibold text-yellow-400">{artifact.name}</p>
                                <p className="text-xs text-gray-300">{artifact.description}</p>
                            </div>
                        </div>
                    );
                }) : <p className="text-center text-gray-500 mt-8">ë³´ìœ í•œ ìœ ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤.</p>}
            </div>
            <div className="mt-2 pt-2 border-t border-gray-700">
                <h4 className="text-md font-semibold text-center text-green-300 mb-2">ìœ ë¬¼ ë½‘ê¸°</h4>
                <button 
                    onClick={onGacha}
                    disabled={allArtifactsOwned || playerCoins < gachaCost}
                    className="w-full bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 text-white font-bold py-2 px-4 rounded"
                >
                    {allArtifactsOwned ? 'ëª¨ë“  ìœ ë¬¼ íšë“' : (
                        `ë½‘ê¸° | ${formatNumber(gachaCost)}`
                    )}
                </button>
            </div>
        </div>
    );
};

const SlotMachineGame = ({ playerCoins, onSpin }) => {
    const [reels, setReels] = useState(['ğŸ€', 'ğŸ€', 'ğŸ€']);
    const [spinning, setSpinning] = useState(false);
    const [result, setResult] = useState(null);
    const spinIntervalRef = useRef(null);
    const symbols = useMemo(() => ['ğŸ’°', 'âš”ï¸', 'ğŸ’', 'ğŸ€', <GreenSlimeIcon/>, <RedSlimeIcon/>, <BlueSlimeIcon/>], []);
    const symbolKeys = ['COIN', 'SWORD', 'GEM', 'CLOVER', 'G_SLIME', 'R_SLIME', 'B_SLIME'];

    const cost = 100;
    
    const handleSpin = () => {
        if (playerCoins < cost || spinning) return;
        setSpinning(true);
        setResult(null);

        spinIntervalRef.current = setInterval(() => {
            setReels(reels => reels.map(() => symbols[Math.floor(Math.random() * symbols.length)]));
        }, 80);

        onSpin(cost, (newReelKeys, reward) => {
            const newReels = newReelKeys.map(key => symbols[symbolKeys.indexOf(key)]);
            setTimeout(() => {
                clearInterval(spinIntervalRef.current);
                
                let reelIndex = 0;
                const revealInterval = setInterval(() => {
                    setReels(prev => {
                        const next = [...prev];
                        next[reelIndex] = newReels[reelIndex];
                        return next;
                    });
                    reelIndex++;
                    if (reelIndex >= newReels.length) {
                        clearInterval(revealInterval);
                        setSpinning(false);
                        setResult(reward);
                    }
                }, 400);
            }, 1200);
        });
    };

    return (
        <div className="bg-gray-900/50 p-4 rounded-lg">
            <div className="flex justify-center gap-2 sm:gap-4 mb-4 bg-gray-700 p-4 rounded">
                {reels.map((symbol, i) => (
                    <div key={i} className="w-16 h-16 bg-gray-900 rounded-md flex items-center justify-center text-4xl overflow-hidden p-1">
                        {typeof symbol === 'string' ? symbol : React.cloneElement(symbol, { className: 'w-12 h-12' })}
                    </div>
                ))}
            </div>
            <div className="text-center mb-4 h-12">
                {result && (
                    <p className="text-lg font-bold text-yellow-300">{result.message}</p>
                )}
            </div>
            <button onClick={handleSpin} disabled={playerCoins < cost || spinning} className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded">
                {spinning ? 'ëŒì•„ê°€ëŠ” ì¤‘...' : `ëŒë¦¬ê¸° (${formatNumber(cost)} ê³¨ë“œ)`}
            </button>
        </div>
    );
};

const WhackASlimeGame = ({ playerLevel, playerCoins, onStart, onEnd }) => {
    const [gameState, setGameState] = useState({ status: 'idle', score: 0, timeLeft: 15, holes: Array(9).fill(false) });
    const cost = 100;
    const gameTimerRef = useRef(null);
    const slimeTimerRef = useRef(null);

    const handleStart = () => {
        if (playerCoins >= cost && onStart(cost)) {
            setGameState({
                status: 'playing',
                score: 0,
                timeLeft: 15,
                holes: Array(9).fill(false)
            });
        }
    };

    useEffect(() => {
        if (gameState.status === 'playing') {
            gameTimerRef.current = setInterval(() => {
                setGameState(prev => {
                    if (prev.timeLeft <= 1) {
                        clearInterval(gameTimerRef.current);
                        clearInterval(slimeTimerRef.current);
                        onEnd(cost + prev.score * (playerLevel * 0.5));
                        return { ...prev, status: 'ended', timeLeft: 0 };
                    }
                    return { ...prev, timeLeft: prev.timeLeft - 1 };
                });
            }, 1000);

            slimeTimerRef.current = setInterval(() => {
                setGameState(prev => {
                    if (prev.status !== 'playing') return prev;
                    const newHoles = [...prev.holes];
                    const availableHoles = newHoles.map((h, i) => !h ? i : -1).filter(i => i !== -1);
                    if (availableHoles.length > 0) {
                        const randomIndex = availableHoles[Math.floor(Math.random() * availableHoles.length)];
                        newHoles[randomIndex] = true;
                        setTimeout(() => {
                            setGameState(p => {
                                if (p.status !== 'playing') return p;
                                const latestHoles = [...p.holes];
                                latestHoles[randomIndex] = false;
                                return {...p, holes: latestHoles};
                            });
                        }, 700 + Math.random() * 400);
                    }
                    return { ...prev, holes: newHoles };
                });
            }, 450);
        }

        return () => {
            clearInterval(gameTimerRef.current);
            clearInterval(slimeTimerRef.current);
        };
    }, [gameState.status, onEnd, playerLevel, cost]);


    const handleWhack = (index) => {
        if (gameState.holes[index]) {
            setGameState(prev => {
                const newHoles = [...prev.holes];
                newHoles[index] = false;
                return { ...prev, score: prev.score + 1, holes: newHoles };
            });
        }
    };

    if (gameState.status === 'idle' || gameState.status === 'ended') {
        return (
            <div className="bg-gray-900/50 p-4 rounded-lg text-center">
                {gameState.status === 'ended' && <p className="text-xl mb-4">ê²Œì„ ì¢…ë£Œ! ìµœì¢… ì ìˆ˜: <span className="font-bold text-green-400">{gameState.score}</span></p>}
                <p className="mb-4">15ì´ˆ ì•ˆì— ìµœëŒ€í•œ ë§ì€ ìŠ¬ë¼ì„ì„ ì¡ìœ¼ì„¸ìš”!</p>
                <button onClick={handleStart} disabled={playerCoins < cost} className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded">
                    ì‹œì‘í•˜ê¸° ({formatNumber(cost)} ê³¨ë“œ)
                </button>
            </div>
        );
    }

    return (
        <div className="bg-gray-900/50 p-4 rounded-lg">
            <div className="flex justify-between text-xl font-bold mb-4">
                <span>ì ìˆ˜: {gameState.score}</span>
                <span>ì‹œê°„: {gameState.timeLeft}</span>
            </div>
            <div className="grid grid-cols-3 gap-2">
                {gameState.holes.map((isActive, i) => (
                    <div key={i} className="aspect-square bg-yellow-900/70 rounded-full border-4 border-yellow-800 relative overflow-hidden flex items-center justify-center">
                        {isActive && (
                             <div onClick={() => handleWhack(i)} className="w-full h-full cursor-pointer animate-slime-pop">
                                 <GreenSlimeIcon className="w-full h-full" />
                             </div>
                        )}
                    </div>
                ))}
            </div>
        </div>
    );
};

const MinigamePanel = ({ playerLevel, playerCoins, onSlotSpin, onSlimeWhackStart, onSlimeWhackEnd }) => {
    const [activeGame, setActiveGame] = useState('slots');
    return (
        <div>
            <h3 className="text-lg font-semibold mb-2 text-green-300">ë¯¸ë‹ˆê²Œì„</h3>
             <div className="flex border-b border-gray-700 mb-4 text-sm">
                <button onClick={() => setActiveGame('slots')} className={`flex-1 py-2 text-center font-semibold ${activeGame === 'slots' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>í–‰ìš´ì˜ ìŠ¬ë¡¯</button>
                <button onClick={() => setActiveGame('whack')} className={`flex-1 py-2 text-center font-semibold ${activeGame === 'whack' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>ë‘ë”ì§€ ìŠ¬ë¼ì„</button>
            </div>
            {activeGame === 'slots' && <SlotMachineGame playerCoins={playerCoins} onSpin={onSlotSpin} />}
            {activeGame === 'whack' && <WhackASlimeGame playerLevel={playerLevel} playerCoins={playerCoins} onStart={onSlimeWhackStart} onEnd={onSlimeWhackEnd} />}
        </div>
    );
};

const RightPanel = ({ activeTab, setActiveTab, selectedForgeItem, ...props }) => {
    const forgeHandlers = {
        onForge: props.handlers.onForgeItem,
        onUpgradeRarity: props.handlers.onUpgradeRarity,
        onReforge: props.handlers.onReforgeItem,
    };

    return (
        <div className="w-full md:w-1/4 bg-gray-800 p-2 rounded-lg shadow-lg order-3 md:order-3">
            <div className="grid grid-cols-3 text-sm">
                 <button onClick={() => setActiveTab('upgrade')} className={`py-2 text-center font-semibold ${activeTab === 'upgrade' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>ê°•í™”</button>
                 <button onClick={() => setActiveTab('inventory')} className={`py-2 text-center font-semibold ${activeTab === 'inventory' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>ì¸ë²¤í† ë¦¬</button>
                 <button onClick={() => setActiveTab('forge')} className={`py-2 text-center font-semibold ${activeTab === 'forge' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>ëŒ€ì¥ê°„</button>
                 <button onClick={() => setActiveTab('missions')} className={`py-2 text-center font-semibold ${activeTab === 'missions' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>ì„ë¬´</button>
                 <button onClick={() => setActiveTab('artifacts')} className={`py-2 text-center font-semibold ${activeTab === 'artifacts' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>ìœ ë¬¼</button>
                 <button onClick={() => setActiveTab('minigame')} className={`py-2 text-center font-semibold ${activeTab === 'minigame' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>ë¯¸ë‹ˆê²Œì„</button>
            </div>
            <div className="p-2">
            {activeTab === 'upgrade' && <UpgradePanel
                upgrades={props.upgrades}
                playerCoins={props.playerCoins}
                handlers={props.handlers}
                abilityStats={props.abilityStats}
                equipmentGachaCost={props.equipmentGachaCost}
                onLiberate={props.handlers.onLiberate}
                liberationCost={props.liberationCost}
                liberationCount={props.liberationCount}
                onRebirth={props.handlers.onRebirth}
                playerLevel={props.playerLevel}
                rebirthCount={props.rebirthCount}
            />}
            {activeTab === 'inventory' && <InventoryPanel 
                inventory={props.inventory} 
                onSelectItem={props.handlers.onSelectItem}
                isSellMode={props.isSellMode}
                onToggleSellMode={props.handlers.onToggleSellMode}
                sellList={props.sellList}
                onToggleSellItem={props.handlers.onToggleSellItem}
                onBulkSell={props.handlers.onBulkSell}
                onBulkSellByRarity={props.handlers.onBulkSellByRarity}
                 />}
            {activeTab === 'forge' && <ForgePanel selectedItem={selectedForgeItem} handlers={forgeHandlers} playerCoins={props.playerCoins} />}
            {activeTab === 'missions' && <MissionsPanel missions={props.missions} onClaim={props.handlers.onClaimMission} />}
            {activeTab === 'artifacts' && <ArtifactPanel owned={props.ownedArtifacts} equipped={props.equippedArtifacts} onEquip={props.handlers.onEquipArtifact} onUnequip={props.handlers.onUnequipArtifact} onGacha={props.handlers.onArtifactGacha} playerCoins={props.playerCoins} />}
            {activeTab === 'minigame' && <MinigamePanel playerLevel={props.playerLevel} playerCoins={props.playerCoins} onSlotSpin={props.handlers.onSlotSpin} onSlimeWhackStart={props.handlers.onSlimeWhackStart} onSlimeWhackEnd={props.handlers.onSlimeWhackEnd} />}
            </div>
        </div>
    );
};


const LiberationButton = ({ onLiberate, cost, playerCoins, count }) => (
    <div className="w-full">
        <button
            onClick={onLiberate}
            disabled={playerCoins < cost}
            className="w-full bg-gradient-to-r from-yellow-400 via-red-500 to-pink-500 hover:from-yellow-500 hover:to-pink-600 disabled:from-gray-600 disabled:to-gray-700 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg transition-all shadow-lg transform hover:scale-105">
            <span className="text-md drop-shadow-md">í•´ë°© ({count}) - ëª¨ë“  ìŠ¤íƒ¯ x2 | <CoinIcon className="inline-block h-5 w-5 -mt-1"/> {formatNumber(cost)}</span>
        </button>
    </div>
);

const RebirthButton = ({ onRebirth, level, count }) => {
    const canRebirth = level >= REBIRTH_LEVEL_REQUIREMENT;
    return (
        <div className="w-full">
            <button
                onClick={onRebirth}
                disabled={!canRebirth}
                className="w-full bg-gradient-to-r from-purple-500 via-indigo-500 to-blue-500 hover:from-purple-600 hover:to-blue-600 disabled:from-gray-600 disabled:to-gray-700 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg transition-all shadow-lg transform hover:scale-105"
            >
                {canRebirth ? (
                    <span className="text-md drop-shadow-md">í™˜ìƒ | ì˜êµ¬ ìŠ¤íƒ¯ +{REBIRTH_ALL_STAT_BONUS}% ({count}íšŒ)</span>
                ) : (
                    <span className="text-md drop-shadow-md">í™˜ìƒ í•„ìš”: Lv.{REBIRTH_LEVEL_REQUIREMENT} (í˜„ì¬ {level})</span>
                )}
            </button>
        </div>
    );
};


const ActiveSkillButton = ({ skill, onClick, cooldown, maxCooldown }) => {
    const isDisabled = cooldown > 0;
    const cooldownPercentage = (cooldown / maxCooldown) * 100;

    return (
        <button
            onClick={onClick}
            disabled={isDisabled}
            className="relative w-full bg-red-700 hover:bg-red-800 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-2 rounded-lg transition-colors shadow-lg overflow-hidden h-16 flex items-center justify-center">
            {cooldown > 0 && (
                 <div className="absolute top-0 left-0 h-full bg-black opacity-50" style={{ width: `${100 - cooldownPercentage}%` }}></div>
            )}
            <div className="relative z-10 text-center">
                <p className="text-md font-bold">{skill.name}</p>
                <p className="text-xs">{cooldown > 0 ? `${Math.ceil(cooldown / 1000)}ì´ˆ` : `ì‚¬ìš© ê°€ëŠ¥`}</p>
            </div>
        </button>
    );
};

const GameLog = ({ log }) => (
     <div className="w-full bg-gray-800 p-4 rounded-lg shadow-lg order-4 h-40 overflow-y-auto">
        <h3 className="text-lg font-bold mb-2 text-green-400">ê²Œì„ ë¡œê·¸</h3>
        <div className="text-sm space-y-1"> {log.map((entry, index) => ( <p key={index} className="text-gray-300" dangerouslySetInnerHTML={{ __html: entry }}></p> ))} </div>
    </div>
);

const NewItemDropModal = ({ newItem, currentItem, onEquip, onStore }) => {
    if (!newItem) return null;

    const renderItemStats = (item) => {
        if (!item) return <p className="text-gray-400">ì—†ìŒ</p>;
        const rarityInfo = RARITIES[item.rarity];
        const enhancedStats = getEnhancedItemStats(item);
        return (
            <div className={`p-4 rounded-lg border-2 ${rarityInfo.borderClass} bg-gray-800`}>
                <p className={`font-bold text-xl ${rarityInfo.textClass}`}>{item.name} {item.level > 0 ? `+${item.level}` : ''}</p>
                <p className={`text-sm mb-2 ${rarityInfo.textClass}`}>[{rarityInfo.name}]</p>
                <div className="space-y-1">
                    {enhancedStats.clickDamage > 0 && <p><SwordIcon /> í´ë¦­ ë°ë¯¸ì§€ +{formatNumber(enhancedStats.clickDamage)}</p>}
                    {enhancedStats.autoAttackDamage > 0 && <p><DpsIcon /> ìë™ ê³µê²© +{formatNumber(enhancedStats.autoAttackDamage)}</p>}
                    {enhancedStats.critChance > 0 && <p><CritIcon /> í¬ë¦¬ í™•ë¥  +{Math.round(enhancedStats.critChance)}%</p>}
                    {enhancedStats.critDamage > 0 && <p><CritIcon /> í¬ë¦¬ ë°ë¯¸ì§€ +{formatNumber(enhancedStats.critDamage)}%</p>}
                    {enhancedStats.attackSpeedBonus > 0 && <p><AttackSpeedIcon /> ê³µê²© ì†ë„ +{Math.round(enhancedStats.attackSpeedBonus)}%</p>}
                    {enhancedStats.hasteBonus > 0 && <p><DpsIcon /> ê°€ì† +{Math.round(enhancedStats.hasteBonus)}%</p>}
                    {enhancedStats.goldGainBonus > 0 && <p><CoinIcon /> ê³¨ë“œ íšë“ +{Math.round(enhancedStats.goldGainBonus)}%</p>}
                    {enhancedStats.xpGainBonus > 0 && <p><XPIcon /> ê²½í—˜ì¹˜ íšë“ +{Math.round(enhancedStats.xpGainBonus)}%</p>}
                    {enhancedStats.luckBonus > 0 && <p><LuckIcon /> í–‰ìš´ +{Math.round(enhancedStats.luckBonus)}</p>}
                </div>
            </div>
        );
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div className="bg-gray-900 p-6 rounded-lg shadow-2xl w-full max-w-2xl border border-gray-700">
                <h2 className="text-3xl font-bold text-center mb-4 text-green-400">ìƒˆë¡œìš´ ì•„ì´í…œ íšë“!</h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div> <h3 className="text-lg font-semibold mb-2 text-center text-yellow-400">ìƒˆ ì•„ì´í…œ</h3> {renderItemStats(newItem)} </div>
                    <div> <h3 className="text-lg font-semibold mb-2 text-center text-gray-400">í˜„ì¬ ì¥ì°©</h3> {renderItemStats(currentItem)} </div>
                </div>
                <div className="flex justify-center gap-4">
                     <button onClick={onEquip} className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-lg"> ì¥ì°© </button>
                     <button onClick={onStore} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-lg"> ë³´ê´€ </button>
                </div>
            </div>
        </div>
    );
};

const JobSelectionModal = ({ onSelect, onClose }) => {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
            <div className="bg-gray-900 p-8 rounded-lg shadow-2xl w-full max-w-4xl border border-gray-700 text-center relative">
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-white text-3xl font-bold">&times;</button>
                <h2 className="text-4xl font-bold mb-4 text-green-400">ì§ì—…ì„ ì„ íƒí•˜ì„¸ìš”</h2>
                <p className="text-gray-400 mb-8">ì„ íƒí•œ ì§ì—…ì€ ê²Œì„ í”Œë ˆì´ì— í° ì˜í–¥ì„ ë¯¸ì¹©ë‹ˆë‹¤.</p>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                    {Object.keys(JOBS).map(jobKey => {
                        const job = JOBS[jobKey];
                        const Icon = job.icon;
                        return (
                            <div key={jobKey} className="bg-gray-800 p-6 rounded-lg border-2 border-gray-700 hover:border-green-500 transition-all flex flex-col">
                                <Icon className="w-12 h-12 mx-auto mb-4 text-green-400"/>
                                <h3 className="text-2xl font-bold mb-3 text-white">{job.name}</h3>
                                <p className="text-gray-300 mb-4 flex-grow">{job.description}</p>
                                <p className="text-sm text-yellow-400 mb-1"><strong>ì§€ì† íš¨ê³¼:</strong> {job.passive}</p>
                                <p className="text-sm text-orange-400 mb-2"><strong>ìŠ¤í‚¬ 1:</strong> {job.skill.name}</p>
                                <p className="text-sm text-cyan-400 mb-2"><strong>ìŠ¤í‚¬ 2:</strong> {job.skill2.name}</p>
                                <p className="text-sm text-purple-400 mb-6"><strong>ìŠ¤í‚¬ 3:</strong> {job.skill3.name}</p>
                                <button onClick={() => onSelect(jobKey)} className="mt-auto w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                                    {job.name}(ìœ¼)ë¡œ ì„ íƒ
                                </button>
                            </div>
                        );
                    })}
                </div>
            </div>
        </div>
    );
};

const InventoryItemDetailModal = ({ item, currentEquipped, onEquip, onSell, onSelectForge, onToggleLock, onClose }) => {
    if (!item) return null;

    const renderItemStats = (itemToRender, title) => {
        if (!itemToRender) return <div><h3 className="text-lg font-semibold mb-2 text-center text-gray-400">{title}</h3><div className="p-4 rounded-lg border-2 border-gray-600 bg-gray-800 flex items-center justify-center min-h-[160px]"><p className="text-gray-500">ì—†ìŒ</p></div></div>;
        const rarityInfo = RARITIES[itemToRender.rarity];
        const enhancedStats = getEnhancedItemStats(itemToRender);
        return (
            <div>
                 <h3 className="text-lg font-semibold mb-2 text-center text-gray-400">{title}</h3>
                <div className={`p-4 rounded-lg border-2 ${rarityInfo.borderClass} bg-gray-800 min-h-[160px]`}>
                    <p className={`font-bold text-xl ${rarityInfo.textClass}`}>{itemToRender.name} {itemToRender.level > 0 ? `+${itemToRender.level}` : ''}</p>
                    <p className={`text-sm mb-2 ${rarityInfo.textClass}`}>[{rarityInfo.name}]</p>
                    <hr className="border-gray-600 my-1"/>
                    <div className="space-y-1 mt-2">
                        {enhancedStats.clickDamage > 0 && <p><SwordIcon /> í´ë¦­ ë°ë¯¸ì§€ +{formatNumber(enhancedStats.clickDamage)}</p>}
                        {enhancedStats.autoAttackDamage > 0 && <p><DpsIcon /> ìë™ ê³µê²© +{formatNumber(enhancedStats.autoAttackDamage)}</p>}
                        {enhancedStats.critChance > 0 && <p><CritIcon /> í¬ë¦¬ í™•ë¥  +{Math.round(enhancedStats.critChance)}%</p>}
                        {enhancedStats.critDamage > 0 && <p><CritIcon /> í¬ë¦¬ ë°ë¯¸ì§€ +{formatNumber(enhancedStats.critDamage)}%</p>}
                        {enhancedStats.attackSpeedBonus > 0 && <p><AttackSpeedIcon /> ê³µê²© ì†ë„ +{Math.round(enhancedStats.attackSpeedBonus)}%</p>}
                        {enhancedStats.hasteBonus > 0 && <p><DpsIcon /> ê°€ì† +{Math.round(enhancedStats.hasteBonus)}%</p>}
                        {enhancedStats.goldGainBonus > 0 && <p><CoinIcon /> ê³¨ë“œ íšë“ +{Math.round(enhancedStats.goldGainBonus)}%</p>}
                        {enhancedStats.xpGainBonus > 0 && <p><XPIcon /> ê²½í—˜ì¹˜ íšë“ +{Math.round(enhancedStats.xpGainBonus)}%</p>}
                        {enhancedStats.luckBonus > 0 && <p><LuckIcon /> í–‰ìš´ +{Math.round(enhancedStats.luckBonus)}</p>}
                    </div>
                </div>
            </div>
        );
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50" onClick={onClose}>
            <div className="bg-gray-900 p-6 rounded-lg shadow-2xl w-full max-w-2xl border border-gray-700 relative" onClick={e => e.stopPropagation()}>
                <button onClick={onClose} className="absolute top-2 right-3 text-gray-500 hover:text-white text-3xl font-bold">&times;</button>
                <h2 className="text-3xl font-bold text-center mb-4 text-green-400">ì•„ì´í…œ ì •ë³´</h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    {renderItemStats(item, "ì„ íƒí•œ ì•„ì´í…œ")}
                    {renderItemStats(currentEquipped, "í˜„ì¬ ì¥ì°©")}
                </div>
                <div className="flex justify-center gap-2 flex-wrap">
                    <button onClick={() => { onEquip(item); onClose(); }} className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-5 rounded-lg text-lg">ì¥ì°©</button>
                    <button onClick={() => { onToggleLock(item); }} className="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-5 rounded-lg text-lg">{item.locked ? 'ì ê¸ˆ í•´ì œ' : 'ì ê¸ˆ'}</button>
                    <button onClick={() => { onSell(item); onClose(); }} disabled={item.locked} className="bg-red-600 hover:bg-red-700 disabled:bg-gray-500 disabled:cursor-not-allowed text-white font-bold py-3 px-5 rounded-lg text-lg">íŒë§¤</button>
                    <button onClick={() => { onSelectForge(item); onClose(); }} className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-5 rounded-lg text-lg">ëŒ€ì¥ê°„</button>
                </div>
            </div>
        </div>
    );
};

const DifficultySelectionModal = ({ onSelect }) => (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-50">
        <div className="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-4xl border border-gray-700 text-center">
            <h2 className="text-4xl font-bold mb-4 text-green-400">ë‚œì´ë„ ì„ íƒ</h2>
            <p className="text-gray-400 mb-8">ê²Œì„ì„ ì‹œì‘í•˜ê¸° ì „ì— ë‚œì´ë„ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”. ë‚œì´ë„ëŠ” ë‚˜ì¤‘ì— ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {Object.keys(DIFFICULTIES).map(key => {
                    const diff = DIFFICULTIES[key];
                    return (
                        <div key={key} className="bg-gray-700 p-6 rounded-lg border-2 border-gray-600 hover:border-green-500 transition-all flex flex-col">
                            <h3 className="text-2xl font-bold mb-3 text-white">{diff.name}</h3>
                            <p className="text-gray-300 mb-4 flex-grow">{diff.description}</p>
                            <button onClick={() => onSelect(key)} className="mt-auto w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                                {diff.name}ìœ¼ë¡œ ì‹œì‘
                            </button>
                        </div>
                    );
                })}
            </div>
        </div>
    </div>
);

const DifficultyChangeModal = ({ currentDifficulty, onSelect, onClose }) => (
    <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
        <div className="bg-gray-900 p-8 rounded-lg shadow-2xl w-full max-w-4xl border border-gray-700 text-center relative">
            <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-white text-3xl font-bold">&times;</button>
            <h2 className="text-4xl font-bold mb-4 text-green-400">ë‚œì´ë„ ë³€ê²½</h2>
            <p className="text-gray-400 mb-8">ëª¬ìŠ¤í„° ì²´ë ¥ê³¼ ë³´ìƒì— ì¦‰ì‹œ ì˜í–¥ì„ ì¤ë‹ˆë‹¤.</p>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {Object.keys(DIFFICULTIES).map(key => {
                    const diff = DIFFICULTIES[key];
                    const isCurrent = currentDifficulty === key;
                    return (
                        <div key={key} className={`bg-gray-700 p-6 rounded-lg border-2 ${isCurrent ? 'border-green-500' : 'border-gray-600 hover:border-green-400'} transition-all flex flex-col`}>
                            <h3 className="text-2xl font-bold mb-3 text-white">{diff.name}</h3>
                            <p className="text-gray-300 mb-4 flex-grow">{diff.description}</p>
                            <button
                                onClick={() => onSelect(key)}
                                disabled={isCurrent}
                                className={`mt-auto w-full text-white font-bold py-3 px-6 rounded-lg text-lg ${isCurrent ? 'bg-gray-500 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'}`}
                            >
                                {isCurrent ? 'í˜„ì¬ ë‚œì´ë„' : 'ì„ íƒ'}
                            </button>
                        </div>
                    );
                })}
            </div>
        </div>
    </div>
);

const OfflineProgressModal = ({ progress, onClaim }) => {
    if (!progress) return null;
    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
            <div className="bg-gray-900 p-6 rounded-lg shadow-2xl w-full max-w-md border border-gray-700 text-center">
                <h2 className="text-3xl font-bold mb-4 text-green-400">ìë¦¬ ë¹„ì›€ ë³´ìƒ</h2>
                <p className="text-lg text-gray-300 mb-4">{formatTime(progress.time)} ë™ì•ˆ ìë¦¬ë¥¼ ë¹„ì› ìŠµë‹ˆë‹¤.</p>
                <div className="bg-gray-800 p-4 rounded-lg space-y-2">
                    <p className="text-xl flex justify-center items-center"><CoinIcon /> íšë“í•œ ê³¨ë“œ: <span className="font-bold text-yellow-400 ml-2">{formatNumber(progress.gold)}</span></p>
                    <p className="text-xl flex justify-center items-center"><XPIcon /> íšë“í•œ ê²½í—˜ì¹˜: <span className="font-bold text-purple-400 ml-2">{formatNumber(progress.xp)}</span></p>
                </div>
                <button onClick={onClaim} className="mt-6 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-lg w-full">
                    ë³´ìƒ ë°›ê¸°
                </button>
            </div>
        </div>
    );
};

const ElementSelectionModal = ({ currentElement, onSelect, onClose }) => {
    const elements = [
        { key: 'FIRE', passive: '+15% ìŠ¤í‚¬ ë°ë¯¸ì§€', effect: '10% í™•ë¥ ë¡œ 3ì´ˆê°„ í™”ìƒ(ì´ˆë‹¹ ìë™ê³µê²©ë ¥ì˜ 20% í”¼í•´) ë¶€ì—¬' },
        { key: 'WATER', passive: '+15% ê³¨ë“œ & ê²½í—˜ì¹˜ íšë“', effect: '5% í™•ë¥ ë¡œ í´ë¦­ ë°ë¯¸ì§€ì˜ 200% ì¶”ê°€ í”¼í•´' },
        { key: 'EARTH', passive: '+10% í¬ë¦¬í‹°ì»¬ ë°ë¯¸ì§€', effect: 'í¬ë¦¬í‹°ì»¬ ì‹œ 20% í™•ë¥ ë¡œ 0.5ì´ˆ ìŠ¤í„´ (ìŠ¤í„´ ì¤‘ ëª¨ë“  ê³µê²©ì€ í¬ë¦¬í‹°ì»¬)' },
        { key: 'WIND', passive: '+5% ê³µì† & í¬ë¦¬ í™•ë¥ ', effect: 'ê³µê²©ë§ˆë‹¤ ê³µì† 1% ì¦ê°€ (ìµœëŒ€ 20 ì¤‘ì²©), 5ì´ˆ ë¯¸ê³µê²© ì‹œ ì´ˆê¸°í™”' },
    ];
    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
            <div className="bg-gray-900 p-8 rounded-lg shadow-2xl w-full max-w-4xl border border-gray-700 text-center relative">
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-white text-3xl font-bold">&times;</button>
                <h2 className="text-4xl font-bold mb-4 text-green-400">ì›ì†Œ ì„ íƒ</h2>
                <p className="text-gray-400 mb-8">ì „íˆ¬ì— ì ìš©í•  ì›ì†Œ ì¹œí™”ë ¥ì„ ì„ íƒí•˜ì„¸ìš”.</p>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {elements.map(({ key, passive, effect }) => {
                        const elementInfo = ELEMENT_TYPES[key];
                        const isCurrent = currentElement === key;
                        return (
                            <div key={key} className={`bg-gray-800 p-6 rounded-lg border-2 ${isCurrent ? 'border-green-500' : 'border-gray-700 hover:border-green-400'} transition-all flex flex-col`}>
                                <div className="flex items-center gap-3 mb-3">
                                    {React.createElement(elementInfo.icon, { className: 'w-10 h-10' })}
                                    <h3 className="text-2xl font-bold text-white">{elementInfo.name}</h3>
                                </div>
                                <div className="text-left space-y-2 text-sm flex-grow">
                                    <p><strong className="text-yellow-400">ì§€ì† íš¨ê³¼:</strong> {passive}</p>
                                    <p><strong className="text-orange-400">ê³µê²© íš¨ê³¼:</strong> {effect}</p>
                                </div>
                                <button
                                    onClick={() => onSelect(key)}
                                    disabled={isCurrent}
                                    className={`mt-6 w-full text-white font-bold py-3 px-6 rounded-lg text-lg ${isCurrent ? 'bg-gray-500 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'}`}
                                >
                                    {isCurrent ? 'í˜„ì¬ ì›ì†Œ' : 'ì„ íƒ'}
                                </button>
                            </div>
                        );
                    })}
                </div>
            </div>
        </div>
    );
};

// --- DEFAULT STATE ---
const getDefaultState = () => ({
    difficulty: null,
    playerClass: null,
    playerElement: 'FIRE',
    playerStats: {
        playerName: 'ìš©ì‚¬',
        level: 1,
        xp: 0,
        maxXp: LEVEL_EXPERIENCE_BASE,
        coins: 0,
        clickDamage: 1,
        autoAttackDamage: 0,
        attackSpeed: 1.0,
        critChance: 0,
        critDamage: 150,
        luck: 0,
    },
    monsterStats: {
        name: MONSTER_TYPES[0].name,
        Icon: MONSTER_TYPES[0].Icon,
        level: 1,
        hp: MONSTER_HP_BASE,
        maxHp: MONSTER_HP_BASE,
        isBoss: false,
        element: 'FIRE',
    },
    upgrades: {
        clickUpgradeCost: CLICK_UPGRADE_COST_BASE,
        clickUpgradeLevel: 1,
        autoAttackUpgradeCost: AUTO_ATTACK_UPGRADE_COST_BASE,
        autoAttackUpgradeLevel: 1,
        critChanceUpgradeCost: CRIT_CHANCE_UPGRADE_COST_BASE,
        critDamageUpgradeCost: CRIT_DAMAGE_UPGRADE_COST_BASE,
        goldGainUpgradeCost: GOLD_GAIN_UPGRADE_COST_BASE,
        xpGainUpgradeCost: XP_GAIN_UPGRADE_COST_BASE,
        skillDamageUpgradeCost: SKILL_DAMAGE_UPGRADE_COST_BASE,
        attackSpeedUpgradeCost: ATTACK_SPEED_UPGRADE_COST_BASE,
        hasteUpgradeCost: HASTE_UPGRADE_COST_BASE,
        luckUpgradeCost: LUCK_UPGRADE_COST_BASE,
        bossDamageUpgradeCost: BOSS_DAMAGE_UPGRADE_COST_BASE,
        artifactPowerUpgradeCost: ARTIFACT_POWER_UPGRADE_COST_BASE,
        finalDamageUpgradeCost: FINAL_DAMAGE_UPGRADE_COST_BASE,
        skillDurationUpgradeCost: SKILL_DURATION_UPGRADE_COST_BASE,
        elementalPowerUpgradeCost: ELEMENTAL_POWER_UPGRADE_COST_BASE,
        offlineRewardsUpgradeCost: OFFLINE_REWARDS_UPGRADE_COST_BASE,
        treasureGolemChanceUpgradeCost: TREASURE_GOLEM_CHANCE_UPGRADE_COST_BASE,
    },
    equipment: {
        weapon: null, armor: null, amulet: null, helmet: null, gloves: null, boots: null, ring: null, cloak: null,
    },
    gameLog: ["ê²Œì„ ì‹œì‘! ìŠ¬ë¼ì„ì„ ì²˜ì¹˜í•˜ì„¸ìš”."],
    abilityStats: {
        goldGainBonus: 0,
        xpGainBonus: 0,
        haste: 0, // Skill Cooldown Reduction %
        skillDamageBonus: 0,
        bossDamageBonus: 0,
        artifactPowerBonus: 0,
        finalDamageBonus: 0,
        skillDurationBonus: 0,
        elementalPowerBonus: 0,
        offlineRewardsBonus: 0,
        treasureGolemChanceBonus: 0,
    },
    liberationCount: 0,
    rebirthCount: 0,
    inventory: [],
    isAutoDropEnabled: true,
    missions: [],
    ownedArtifacts: [],
    equippedArtifacts: [],
    lastSaveTimestamp: Date.now(),
});


// --- MAIN APP ---
const App = () => {
    // State initialization with robust saved data handling
    const [difficulty, setDifficulty] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return null;
        try { return JSON.parse(saved).difficulty || 'NORMAL'; }
        catch (e) { return null; }
    });
    
    const [playerClass, setPlayerClass] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().playerClass;
        try { return JSON.parse(saved).playerClass || getDefaultState().playerClass; }
        catch (e) { return getDefaultState().playerClass; }
    });

    const [playerElement, setPlayerElement] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().playerElement;
        try { return JSON.parse(saved).playerElement || getDefaultState().playerElement; }
        catch(e) { return getDefaultState().playerElement; }
    });

    const [playerStats, setPlayerStats] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().playerStats;
        try { const savedGame = JSON.parse(saved); return { ...getDefaultState().playerStats, ...savedGame.playerStats }; }
        catch (e) { return getDefaultState().playerStats; }
    });

    const [monsterStats, setMonsterStats] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().monsterStats;
        try {
            const savedGame = JSON.parse(saved); const savedMonster = savedGame.monsterStats;
            if (savedMonster) {
                const monsterData = (savedMonster.isBoss ? BOSS_TYPES.find(b => b.name === savedMonster.name) : MONSTER_TYPES.find(m => m.name === savedMonster.name)) || MONSTER_TYPES[0];
                return { ...getDefaultState().monsterStats, ...savedMonster, Icon: monsterData.Icon };
            }
            return getDefaultState().monsterStats;
        } catch (e) { return getDefaultState().monsterStats; }
    });

    const [upgrades, setUpgrades] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().upgrades;
        try { const savedGame = JSON.parse(saved); return { ...getDefaultState().upgrades, ...savedGame.upgrades }; }
        catch (e) { return getDefaultState().upgrades; }
    });
    
    const [abilityStats, setAbilityStats] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().abilityStats;
        try { const savedGame = JSON.parse(saved); return { ...getDefaultState().abilityStats, ...savedGame.abilityStats }; }
        catch (e) { return getDefaultState().abilityStats; }
    });
    
    const [liberationCount, setLiberationCount] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().liberationCount;
        try { const savedGame = JSON.parse(saved); return savedGame.liberationCount || getDefaultState().liberationCount; }
        catch (e) { return getDefaultState().liberationCount; }
    });
    
    const [rebirthCount, setRebirthCount] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().rebirthCount;
        try { const savedGame = JSON.parse(saved); return savedGame.rebirthCount || getDefaultState().rebirthCount; }
        catch (e) { return getDefaultState().rebirthCount; }
    });

    const [equipment, setEquipment] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().equipment;
        try { const savedGame = JSON.parse(saved); return { ...getDefaultState().equipment, ...savedGame.equipment }; }
        catch (e) { return getDefaultState().equipment; }
    });
    
    const [inventory, setInventory] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().inventory;
        try { const savedGame = JSON.parse(saved); return savedGame.inventory || getDefaultState().inventory; }
        catch (e) { return getDefaultState().inventory; }
    });

    const [gameLog, setGameLog] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().gameLog;
        try { const savedGame = JSON.parse(saved); return savedGame.gameLog || getDefaultState().gameLog; }
        catch (e) { return getDefaultState().gameLog; }
    });
    
    const [isAutoDropEnabled, setIsAutoDropEnabled] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().isAutoDropEnabled;
        try {
            const savedGame = JSON.parse(saved);
            return savedGame.isAutoDropEnabled !== undefined ? savedGame.isAutoDropEnabled : getDefaultState().isAutoDropEnabled;
        } catch (e) { return getDefaultState().isAutoDropEnabled; }
    });

    const [missions, setMissions] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return [];
        try { const savedGame = JSON.parse(saved); return savedGame.missions || []; }
        catch(e) { return []; }
    });

    const [ownedArtifacts, setOwnedArtifacts] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return [];
        try { return JSON.parse(saved).ownedArtifacts || []; }
        catch(e) { return []; }
    });

    const [equippedArtifacts, setEquippedArtifacts] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return [];
        try { return JSON.parse(saved).equippedArtifacts || []; }
        catch(e) { return []; }
    });


    // UI State
    const [activeTab, setActiveTab] = useState('upgrade');
    const [selectedForgeItem, setSelectedForgeItem] = useState(null);
    const [isJobSelectionOpen, setIsJobSelectionOpen] = useState(false);
    const [selectedInventoryItem, setSelectedInventoryItem] = useState(null);
    const [isDifficultyModalOpen, setIsDifficultyModalOpen] = useState(false);
    const [isElementModalOpen, setIsElementModalOpen] = useState(false);
    const [isSellMode, setIsSellMode] = useState(false);
    const [sellList, setSellList] = useState(new Set());
    const [offlineProgress, setOfflineProgress] = useState(null);

    const [activeSkillCooldown, setActiveSkillCooldown] = useState(0);
    const [secondSkillCooldown, setSecondSkillCooldown] = useState(0);
    const [thirdSkillCooldown, setThirdSkillCooldown] = useState(0);
    const [damagePopups, setDamagePopups] = useState([]);
    const [newItemDrop, setNewItemDrop] = useState(null);
    const [isMonsterStunned, setIsMonsterStunned] = useState(false);
    const [treasureGolem, setTreasureGolem] = useState({ isActive: false, timer: 0 });
    const [elementalEffects, setElementalEffects] = useState({ fire_dot: null, wind_stacks: 0 });
    
    // New skill effect states
    const [overwhelmState, setOverwhelmState] = useState({ active: false, clicksLeft: 0 });
    const [focusTimeActive, setFocusTimeActive] = useState(false);
    const [timeWarpActive, setTimeWarpActive] = useState(false);
    const [weaknessFoundActive, setWeaknessFoundActive] = useState(false);
    const [magicStormDebuff, setMagicStormDebuff] = useState({ active: false, expires: 0 });
    const whirlwindIntervalRef = useRef(null);
    const windStackDecayTimer = useRef(null);

    const needsSave = useRef(false);

    const liberationCost = useMemo(() => Math.floor(LIBERATION_COST_BASE * Math.pow(LIBERATION_COST_MULTIPLIER, liberationCount)), [liberationCount]);
    const equipmentGachaCost = useMemo(() => Math.ceil(EQUIPMENT_GACHA_COST_BASE + playerStats.level * EQUIPMENT_GACHA_COST_LEVEL_MULTIPLIER), [playerStats.level]);

    const difficultyMultipliers = useMemo(() => {
        return difficulty ? DIFFICULTIES[difficulty].multipliers : DIFFICULTIES.NORMAL.multipliers;
    }, [difficulty]);
    
    const addLog = useCallback((message) => { setGameLog(prevLog => [message, ...prevLog.slice(0, 19)]); }, []);

    const onRebirth = useCallback(() => {
        if (playerStats.level < REBIRTH_LEVEL_REQUIREMENT) {
            addLog(`<strong class="text-red-400">í™˜ìƒí•˜ë ¤ë©´ ë ˆë²¨ ${REBIRTH_LEVEL_REQUIREMENT}ì´ í•„ìš”í•©ë‹ˆë‹¤.</strong>`);
            return;
        }
        if (confirm(`ì •ë§ë¡œ í™˜ìƒí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\në ˆë²¨, ê³¨ë“œ, ê°•í™” ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì§€ë§Œ ì˜êµ¬ì ì¸ ìŠ¤íƒ¯ ë³´ë„ˆìŠ¤ë¥¼ ì–»ìŠµë‹ˆë‹¤.\n(ì¥ë¹„, í•´ë°©, ìœ ë¬¼, ì§ì—…, ë‚œì´ë„, ì›ì†ŒëŠ” ìœ ì§€ë©ë‹ˆë‹¤)`)) {
            const defaultState = getDefaultState();
            
            const stateToKeep = {
                rebirthCount: rebirthCount + 1,
                liberationCount: liberationCount,
                equipment: equipment,
                inventory: inventory,
                ownedArtifacts: ownedArtifacts,
                equippedArtifacts: equippedArtifacts,
                playerClass: playerClass,
                difficulty: difficulty,
                playerElement: playerElement,
                playerStats: {
                    ...defaultState.playerStats,
                    playerName: playerStats.playerName,
                }
            };
            
            setPlayerStats(stateToKeep.playerStats);
            setMonsterStats(defaultState.monsterStats);
            setUpgrades(defaultState.upgrades);
            setAbilityStats(defaultState.abilityStats);
            setGameLog(["í™˜ìƒí–ˆìŠµë‹ˆë‹¤! ìƒˆë¡œìš´ í˜ê³¼ í•¨ê»˜ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”."]);
            setMissions([]);
            
            setRebirthCount(stateToKeep.rebirthCount);
            setLiberationCount(stateToKeep.liberationCount);
            setEquipment(stateToKeep.equipment);
            setInventory(stateToKeep.inventory);
            setOwnedArtifacts(stateToKeep.ownedArtifacts);
            setEquippedArtifacts(stateToKeep.equippedArtifacts);
            setPlayerClass(stateToKeep.playerClass);
            setDifficulty(stateToKeep.difficulty);
            setPlayerElement(stateToKeep.playerElement);
            
            setActiveSkillCooldown(0);
            setSecondSkillCooldown(0);
            setThirdSkillCooldown(0);
            setElementalEffects({ fire_dot: null, wind_stacks: 0 });
            setFocusTimeActive(false);
            setTimeWarpActive(false);
            setOverwhelmState({ active: false, clicksLeft: 0 });
            if (whirlwindIntervalRef.current) {
                clearInterval(whirlwindIntervalRef.current);
                whirlwindIntervalRef.current = null;
            }

            addLog(`<strong class="text-purple-400">í™˜ìƒ ì™„ë£Œ! ì˜êµ¬ ìŠ¤íƒ¯ì´ ${REBIRTH_ALL_STAT_BONUS}% ì¦ê°€í–ˆìŠµë‹ˆë‹¤.</strong>`);
            needsSave.current = true;
        }
    }, [playerStats, rebirthCount, liberationCount, equipment, inventory, addLog, ownedArtifacts, equippedArtifacts, playerClass, difficulty, playerElement]);

    const updateMissionProgress = useCallback((type, amount) => {
        setMissions(prevMissions => {
            let changed = false;
            const newMissions = prevMissions.map(mission => {
                if (mission.type === type && !mission.isCompleted) {
                    const newProgress = Math.min(mission.target, mission.progress + amount);
                    if (newProgress !== mission.progress) {
                        changed = true;
                        const isCompleted = newProgress >= mission.target;
                        if (isCompleted && !mission.isCompleted) {
                            addLog(`<strong class="text-teal-400">ì„ë¬´ ì™„ë£Œ:</strong> ${MISSION_TYPES[mission.type]}!`);
                        }
                        return { ...mission, progress: newProgress, isCompleted };
                    }
                }
                return mission;
            });
            if (changed) {
                needsSave.current = true;
                return newMissions;
            }
            return prevMissions;
        });
    }, [addLog]);

    const artifactBonuses = useMemo(() => {
        const bonuses = { goldGain: 0, xpGain: 0, bossDamage: 0, haste: 0, critChance: 0, critDamage: 0, clickDamageMult: 0, attackSpeedMult: 0 };
        const powerMultiplier = 1 + (abilityStats.artifactPowerBonus / 100);

        equippedArtifacts.forEach(id => {
            const artifact = ARTIFACTS.find(a => a.id === id);
            if (!artifact) return;
            switch(artifact.effect.type) {
                case 'GOLD_GAIN': bonuses.goldGain += artifact.effect.value * powerMultiplier; break;
                case 'XP_GAIN': bonuses.xpGain += artifact.effect.value * powerMultiplier; break;
                case 'BOSS_DAMAGE': bonuses.bossDamage += artifact.effect.value * powerMultiplier; break;
                case 'HASTE': bonuses.haste += artifact.effect.value * powerMultiplier; break;
                case 'CRIT_CHANCE': bonuses.critChance += artifact.effect.value * powerMultiplier; break;
                case 'CRIT_DAMAGE': bonuses.critDamage += artifact.effect.value * powerMultiplier; break;
                case 'CLICK_DAMAGE_MULT': bonuses.clickDamageMult += artifact.effect.value * powerMultiplier; break;
                case 'ATTACK_SPEED_MULT': bonuses.attackSpeedMult += artifact.effect.value * powerMultiplier; break;
            }
        });
        return bonuses;
    }, [equippedArtifacts, abilityStats.artifactPowerBonus]);

    const elementalBonuses = useMemo(() => {
        const bonuses = { skillDamage: 0, goldGain: 0, xpGain: 0, critDamage: 0, attackSpeed: 0, critChance: 0 };
        if (!playerElement) return bonuses;

        const powerMultiplier = 1 + (abilityStats.elementalPowerBonus / 100);

        switch(playerElement) {
            case 'FIRE': bonuses.skillDamage = 15 * powerMultiplier; break;
            case 'WATER': bonuses.goldGain = 15 * powerMultiplier; bonuses.xpGain = 15 * powerMultiplier; break;
            case 'EARTH': bonuses.critDamage = 10 * powerMultiplier; break;
            case 'WIND': bonuses.attackSpeed = 5 * powerMultiplier; bonuses.critChance = 5 * powerMultiplier; break;
        }
        return bonuses;
    }, [playerElement, abilityStats.elementalPowerBonus]);

    const finalAbilityStats = useMemo(() => {
        let haste = abilityStats.haste;
        let skillDamage = abilityStats.skillDamageBonus + elementalBonuses.skillDamage;
        if (playerClass === 'MAGE') {
            haste *= 1.25;
            skillDamage *= (1 + JOBS.MAGE.bonuses.skillEffect);
        }
        
        const rebirthBonus = rebirthCount * REBIRTH_ALL_STAT_BONUS;
        
        let hasteFromItems = 0;
        let goldBonusFromItems = 0;
        let xpBonusFromItems = 0;

        Object.values(equipment).forEach(item => {
            if (!item) return;
            const enhancedStats = getEnhancedItemStats(item);
            hasteFromItems += enhancedStats.hasteBonus || 0;
            goldBonusFromItems += enhancedStats.goldGainBonus || 0;
            xpBonusFromItems += enhancedStats.xpGainBonus || 0;
        });

        return {
            ...abilityStats,
            luck: playerStats.luck,
            goldGainBonus: abilityStats.goldGainBonus + rebirthBonus + artifactBonuses.goldGain + goldBonusFromItems + elementalBonuses.goldGain,
            xpGainBonus: abilityStats.xpGainBonus + rebirthBonus + artifactBonuses.xpGain + xpBonusFromItems + elementalBonuses.xpGain,
            bossDamageBonus: abilityStats.bossDamageBonus + rebirthBonus + artifactBonuses.bossDamage,
            haste: haste + artifactBonuses.haste + hasteFromItems,
            skillDamageBonus: skillDamage,
            activeSkillCooldown: BASE_SKILL_COOLDOWN * (1 - (haste + artifactBonuses.haste + hasteFromItems) / 100),
        }
    }, [abilityStats, playerClass, rebirthCount, artifactBonuses, equipment, playerStats.luck, elementalBonuses]);

    const finalStats = useMemo(() => {
        let combined = { ...playerStats };
        let attackSpeedBonusFromItems = 0;
        let luckFromItems = 0;

        Object.values(equipment).forEach(item => {
            if (!item) return;
            const enhancedStats = getEnhancedItemStats(item);
            
            combined.clickDamage += enhancedStats.clickDamage || 0;
            combined.autoAttackDamage += enhancedStats.autoAttackDamage || 0;
            combined.critChance += enhancedStats.critChance || 0;
            combined.critDamage += enhancedStats.critDamage || 0;
            attackSpeedBonusFromItems += enhancedStats.attackSpeedBonus || 0;
            luckFromItems += enhancedStats.luckBonus || 0;
        });
        
        combined.luck += luckFromItems;

        if (playerClass && JOBS[playerClass]) {
            const bonuses = JOBS[playerClass].bonuses;
            combined.clickDamage *= (1 + bonuses.clickDamage);
            combined.autoAttackDamage *= (1 + bonuses.autoAttackDamage);
            combined.critChance += bonuses.critChance;
            combined.critDamage += bonuses.critDamage;
        }

        const rebirthMultiplier = 1 + (rebirthCount * REBIRTH_ALL_STAT_BONUS / 100);
        combined.clickDamage *= rebirthMultiplier;
        combined.autoAttackDamage *= rebirthMultiplier;

        combined.critChance += artifactBonuses.critChance + elementalBonuses.critChance;
        combined.critDamage += artifactBonuses.critDamage + elementalBonuses.critDamage;
        combined.clickDamage *= (1 + artifactBonuses.clickDamageMult);
        
        let windAttackSpeedBonus = 0;
        if (playerElement === 'WIND') {
            windAttackSpeedBonus = elementalEffects.wind_stacks;
        }
        combined.attackSpeed = playerStats.attackSpeed * (1 + (artifactBonuses.attackSpeedMult + attackSpeedBonusFromItems + elementalBonuses.attackSpeed + windAttackSpeedBonus) / 100);

        if (weaknessFoundActive) {
            combined.critChance += 20;
            combined.critDamage += 30;
        }

        if (focusTimeActive) {
            combined.attackSpeed *= 1.5;
            combined.critChance = 100;
        }

        const liberationMultiplier = Math.pow(2, liberationCount);
        combined.clickDamage *= liberationMultiplier;
        combined.autoAttackDamage *= liberationMultiplier;

        const finalDamageMultiplier = 1 + (finalAbilityStats.finalDamageBonus / 100);
        combined.clickDamage *= finalDamageMultiplier;
        combined.autoAttackDamage *= finalDamageMultiplier;

        return combined;
    }, [playerStats, equipment, playerClass, focusTimeActive, rebirthCount, liberationCount, artifactBonuses, finalAbilityStats.finalDamageBonus, elementalBonuses, playerElement, elementalEffects.wind_stacks, weaknessFoundActive]);
    
    const saveGame = useCallback(() => {
        try {
            const serializableMonsterStats = { ...monsterStats, Icon: undefined };
            const gameStateToSave = {
                difficulty, playerClass, playerElement, playerStats, monsterStats: serializableMonsterStats,
                upgrades, equipment, gameLog, abilityStats, liberationCount, rebirthCount,
                inventory, isAutoDropEnabled, missions, ownedArtifacts, equippedArtifacts,
                lastSaveTimestamp: Date.now()
            };
            localStorage.setItem(SAVED_GAME_KEY, JSON.stringify(gameStateToSave));
            needsSave.current = false;
        } catch (error) { console.error("Could not save game state", error); }
    }, [difficulty, playerClass, playerElement, playerStats, monsterStats, upgrades, equipment, gameLog, abilityStats, liberationCount, rebirthCount, inventory, isAutoDropEnabled, missions, ownedArtifacts, equippedArtifacts]);

    useEffect(() => { if (needsSave.current) { saveGame(); } });

    const generateMission = useCallback((playerLevel) => {
        const missionKeys = Object.keys(MISSION_TYPES);
        const type = missionKeys[Math.floor(Math.random() * missionKeys.length)];
        let target = 0;
        let reward = 0;
        const baseReward = 50 + playerLevel * 20;

        switch (type) {
            case 'DEFEAT_MONSTERS':
                target = 20 + Math.floor(playerLevel * 5 * (1 + Math.random() * 0.2));
                reward = Math.floor(baseReward * target * 0.8);
                break;
            case 'DEFEAT_BOSSES':
                target = 1 + Math.floor(playerLevel / 20);
                reward = Math.floor(baseReward * target * 50);
                break;
            case 'UPGRADE_TIMES':
                target = 15 + Math.floor(playerLevel * 2 * (1 + Math.random() * 0.2));
                reward = Math.floor(baseReward * target * 0.6);
                break;
            case 'EARN_GOLD':
                target = 1000 + Math.floor(Math.pow(playerLevel, 2) * 100 * (1 + Math.random()));
                reward = Math.floor(target * 0.1);
                break;
        }

        return {
            id: Date.now() + Math.random(),
            type,
            target: Math.ceil(target),
            progress: 0,
            reward: Math.ceil(reward),
            isCompleted: false,
        };
    }, []);

    useEffect(() => {
        if (difficulty && missions.length < 3) {
            setMissions(prev => {
                const newMissions = [...prev];
                while (newMissions.length < 3) {
                    newMissions.push(generateMission(playerStats.level));
                }
                return newMissions;
            });
        }
    }, [difficulty, playerStats.level, missions.length, generateMission]);

    useEffect(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (saved) {
            try {
                const savedGame = JSON.parse(saved);
                const lastSave = savedGame.lastSaveTimestamp || Date.now();
                const offlineTimeSeconds = Math.min(8 * 3600, (Date.now() - lastSave) / 1000); // Max 8 hours

                if (offlineTimeSeconds > 60) {
                    const pLevel = savedGame.playerStats.level || 1;
                    const offlineBonus = (savedGame.abilityStats.offlineRewardsBonus || 0);
                    const goldBonus = (savedGame.abilityStats.goldGainBonus || 0) + ((savedGame.rebirthCount || 0) * REBIRTH_ALL_STAT_BONUS);
                    const xpBonus = (savedGame.abilityStats.xpGainBonus || 0) + ((savedGame.rebirthCount || 0) * REBIRTH_ALL_STAT_BONUS);
                    
                    const autoDps = (savedGame.playerStats.autoAttackDamage || 0) * (savedGame.playerStats.attackSpeed || 1);
                    let goldEarned = 0;
                    let xpEarned = 0;

                    if (autoDps > 0) {
                         const monsterHp = MONSTER_HP_BASE * Math.pow(MONSTER_HP_MULTIPLIER, pLevel - 1);
                         const timeToKill = monsterHp > 0 ? monsterHp / autoDps : Infinity;
                         const monstersPerSec = timeToKill > 0 ? 1 / timeToKill : 0;

                         const baseMonsterGold = MONSTER_REWARD_BASE * Math.pow(MONSTER_REWARD_MULTIPLIER, pLevel - 1);
                         const baseMonsterXp = pLevel * 2.5;

                         const goldPerSec = monstersPerSec * baseMonsterGold * 0.25; // 25% efficiency
                         const xpPerSec = monstersPerSec * baseMonsterXp * 0.25;
                         
                         goldEarned = Math.floor(goldPerSec * offlineTimeSeconds * (1 + goldBonus / 100) * (1 + offlineBonus / 100));
                         xpEarned = Math.floor(xpPerSec * offlineTimeSeconds * (1 + xpBonus / 100) * (1 + offlineBonus / 100));
                    }
                    
                    if (goldEarned > 0 || xpEarned > 0) {
                        setOfflineProgress({ time: offlineTimeSeconds, gold: goldEarned, xp: xpEarned });
                    }
                }
            } catch (e) { console.error("Error calculating offline progress:", e); }
        }
        const saveInterval = setInterval(() => { needsSave.current = true; }, 5000);
        return () => clearInterval(saveInterval);
    }, []);

    const handleSelectDifficulty = (selectedDiff) => {
        const multipliers = DIFFICULTIES[selectedDiff].multipliers;
        const initialUpgrades = { ...getDefaultState().upgrades };
        for (const key in initialUpgrades) {
            if (key.endsWith('Cost')) {
                initialUpgrades[key] = Math.floor(initialUpgrades[key] * multipliers.upgradeCost);
            }
        }
        setUpgrades(initialUpgrades);
        setDifficulty(selectedDiff);
        needsSave.current = true;
    };

    const handleChangeDifficulty = (newDifficulty) => {
        if (difficulty === newDifficulty) {
            setIsDifficultyModalOpen(false);
            return;
        }

        const oldMultipliers = DIFFICULTIES[difficulty].multipliers;
        const newMultipliers = DIFFICULTIES[newDifficulty].multipliers;

        setMonsterStats(prev => {
            const hpRatio = prev.hp / prev.maxHp;
            const newMaxHp = prev.maxHp / oldMultipliers.monsterHp * newMultipliers.monsterHp;
            const newHp = newMaxHp * hpRatio;
            return { ...prev, hp: Math.floor(newHp), maxHp: Math.floor(newMaxHp) };
        });

        setDifficulty(newDifficulty);
        addLog(`<strong class="text-cyan-400">ë‚œì´ë„ë¥¼ '${DIFFICULTIES[newDifficulty].name}'(ìœ¼)ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.</strong>`);
        setIsDifficultyModalOpen(false);
        needsSave.current = true;
    };
    
    const handleJobSelect = (jobKey) => {
        if (playerClass) {
            addLog(`<strong class="text-amber-400">ì§ì—…ì„ ${JOBS[jobKey].name}(ìœ¼)ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤!</strong>`);
        } else {
            addLog(`<strong class="text-amber-400">ë‹¹ì‹ ì€ ì´ì œ ${JOBS[jobKey].name}ì…ë‹ˆë‹¤!</strong>`);
        }
        setPlayerClass(jobKey);
        setIsJobSelectionOpen(false);
        needsSave.current = true;
    };

    const handleSelectElement = (elementKey) => {
        addLog(`<strong style="color: ${ELEMENT_TYPES[elementKey].icon({}).props.className.match(/text-([^ ]+)/)[1]}">ì›ì†Œë¥¼ ${ELEMENT_TYPES[elementKey].name}(ìœ¼)ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤!</strong>`);
        setPlayerElement(elementKey);
        setIsElementModalOpen(false);
        needsSave.current = true;
    };

    const generateRandomItem = useCallback((monsterLevel) => {
        const luckFactor = 1 + (finalStats.luck / 200);
        const rarityRoll = Math.random() / luckFactor;
        let rarityKey = 'COMMON';
        if (rarityRoll < 0.005) rarityKey = 'MYTHIC';
        else if (rarityRoll < 0.02) rarityKey = 'LEGENDARY';
        else if (rarityRoll < 0.10) rarityKey = 'EPIC';
        else if (rarityRoll < 0.30) rarityKey = 'RARE';
        else if (rarityRoll < 0.60) rarityKey = 'UNCOMMON';
    
        const typeKeys = Object.keys(EQUIPMENT_TYPES);
        const typeKey = typeKeys[Math.floor(Math.random() * typeKeys.length)];
    
        const rarity = RARITIES[rarityKey];
        const item = {
            id: Date.now() + Math.random(), type: typeKey, rarity: rarityKey, name: `${rarity.name} ${EQUIPMENT_TYPES[typeKey].name}`,
            level: 0,
            baseLevel: monsterLevel,
            locked: false,
            stats: {}
        };
        item.stats = calculateItemStats(item.baseLevel, item.rarity, item.type);
        return item;
    }, [finalStats.luck]);
    
    const getElementalEffect = useCallback(() => {
        if (!playerElement || !monsterStats.element) return { multiplier: 1, prefix: '', type: 'normal' };
        const relationship = ELEMENTAL_RELATIONSHIPS[playerElement];
        if (relationship.weak === monsterStats.element) {
            return { multiplier: ELEMENTAL_ADVANTAGE_MULTIPLIER, prefix: 'âš¡', type: 'elemental' };
        }
        if (relationship.strong === monsterStats.element) {
            return { multiplier: ELEMENTAL_DISADVANTAGE_MULTIPLIER, prefix: 'ğŸ›¡ï¸', type: 'resist' };
        }
        return { multiplier: 1, prefix: '', type: 'normal' };
    }, [playerElement, monsterStats.element]);

    const createDamagePopup = useCallback((damage, type = 'normal', prefix = '') => {
        const newPopup = { id: Date.now() + Math.random(), damage, prefix, x: 40 + Math.random() * 20, y: 40 + Math.random() * 20, type };
        setDamagePopups(prev => [...prev, newPopup]);
        setTimeout(() => { setDamagePopups(prev => prev.filter(p => p.id !== newPopup.id)); }, 1200);
    }, []);

    const handleMonsterDefeat = useCallback(() => {
        if (whirlwindIntervalRef.current) {
            clearInterval(whirlwindIntervalRef.current);
            whirlwindIntervalRef.current = null;
        }

        let coinsGained = 0;
        let xpGained = 0;
        const currentMonsterLevel = monsterStats.level;

        if (treasureGolem.isActive) {
            coinsGained = Math.floor(monsterStats.maxHp * 5 * (1 + finalAbilityStats.goldGainBonus / 100));
            addLog(`<strong class="text-yellow-400">ë³´ë¬¼ ê³¨ë ˜ ì²˜ì¹˜! +${formatNumber(coinsGained)} ê³¨ë“œ!</strong>`);
            setTreasureGolem({ isActive: false, timer: 0 });
        } else {
            const isBossDefeated = monsterStats.isBoss;
            const rewardMultiplier = (isBossDefeated ? BOSS_REWARD_MULTIPLIER : 1) * difficultyMultipliers.monsterReward;
            xpGained = Math.ceil(currentMonsterLevel * 2.5 * rewardMultiplier * (1 + finalAbilityStats.xpGainBonus / 100));
            coinsGained = Math.ceil(MONSTER_REWARD_BASE * Math.pow(MONSTER_REWARD_MULTIPLIER, currentMonsterLevel - 1) * rewardMultiplier * (1 + finalAbilityStats.goldGainBonus / 100));
            
            if (timeWarpActive) {
                coinsGained *= 1.5;
            }

            addLog(`${isBossDefeated ? `<strong>[BOSS]</strong> ` : ''}${monsterStats.name}(Lv.${currentMonsterLevel}) ì²˜ì¹˜! +${formatNumber(coinsGained)} ê³¨ë“œ, +${formatNumber(xpGained)} ê²½í—˜ì¹˜.`);
            updateMissionProgress('EARN_GOLD', coinsGained);
            updateMissionProgress(isBossDefeated ? 'DEFEAT_BOSSES' : 'DEFEAT_MONSTERS', 1);

            const dropChance = EQUIPMENT_DROP_CHANCE_BASE + (currentMonsterLevel * 0.005) + (isBossDefeated ? BOSS_DROP_CHANCE_BOOST : 0);
            if (Math.random() < dropChance * (1 + finalStats.luck / 100)) {
                const newItem = generateRandomItem(currentMonsterLevel);
                if (isAutoDropEnabled && (newItem.rarity === 'COMMON' || newItem.rarity === 'UNCOMMON')) {
                    const sellPrice = Math.ceil((newItem.baseLevel || 1) * RARITIES[newItem.rarity].statMultiplier * 2);
                    setPlayerStats(prev => ({ ...prev, coins: prev.coins + sellPrice }));
                    addLog(`<span class="${RARITIES[newItem.rarity].textClass}">[${RARITIES[newItem.rarity].name}] ${newItem.name}</span> ìë™ íŒë§¤! +${formatNumber(sellPrice)} <span class="text-yellow-400">ê³¨ë“œ</span>`);
                } else {
                    addLog(`ì•„ì´í…œ íšë“: <span class="${RARITIES[newItem.rarity].textClass}">[${RARITIES[newItem.rarity].name}] ${newItem.name}</span>`);
                    setNewItemDrop(newItem);
                }
            }
        }
        
        let newXp = playerStats.xp + xpGained;
        let newLevel = playerStats.level;
        let newMaxXp = playerStats.maxXp;
        let newClickDamage = playerStats.clickDamage;
        let newAutoAttackDamage = playerStats.autoAttackDamage;
        
        while (newXp >= newMaxXp) {
            newXp -= newMaxXp;
            newLevel++;
            newMaxXp = Math.floor(LEVEL_EXPERIENCE_BASE * Math.pow(LEVEL_EXPERIENCE_MULTIPLIER, newLevel - 1));
            newClickDamage = Math.ceil(newClickDamage * 1.05);
            newAutoAttackDamage = Math.ceil(newAutoAttackDamage * 1.05);
            addLog(`<strong class="text-purple-400">ë ˆë²¨ ì—…! ${newLevel}ë ˆë²¨ ë‹¬ì„±!</strong>`);
        }
        
        setPlayerStats(prev => ({
            ...prev,
            xp: newXp,
            level: newLevel,
            maxXp: newMaxXp,
            coins: prev.coins + coinsGained,
            clickDamage: newClickDamage,
            autoAttackDamage: newAutoAttackDamage,
        }));
        
        const golemSpawnChance = TREASURE_GOLEM_SPAWN_CHANCE + (finalAbilityStats.treasureGolemChanceBonus / 100);
        if (!treasureGolem.isActive && !monsterStats.isBoss && Math.random() < golemSpawnChance) {
            addLog(`<strong class="text-yellow-400">ë³´ë¬¼ ê³¨ë ˜ì´ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!</strong>`);
            setTreasureGolem({ isActive: true, timer: TREASURE_GOLEM_TIMER });
            
            const golemData = SPECIAL_MONSTERS.TREASURE_GOLEM;
            const golemHp = MONSTER_HP_BASE * Math.pow(MONSTER_HP_MULTIPLIER, newLevel - 1) * 2 * difficultyMultipliers.monsterHp;
            
            setMonsterStats({
                name: golemData.name,
                Icon: golemData.Icon,
                level: newLevel,
                hp: Math.ceil(golemHp),
                maxHp: Math.ceil(golemHp),
                isBoss: false,
                element: null,
            });
            needsSave.current = true;
            return;
        }
        
        const nextMonsterLevel = newLevel;
        const isNextBoss = (nextMonsterLevel > 0 && nextMonsterLevel % BOSS_LEVEL_INTERVAL === 0);
        const difficultyMultiplier = difficultyMultipliers.monsterHp;
        const newMonsterHp = isNextBoss
            ? MONSTER_HP_BASE * Math.pow(MONSTER_HP_MULTIPLIER, nextMonsterLevel - 1) * BOSS_HP_MULTIPLIER * difficultyMultiplier
            : MONSTER_HP_BASE * Math.pow(MONSTER_HP_MULTIPLIER, nextMonsterLevel - 1) * difficultyMultiplier;
        
        const availableMonsters = MONSTER_TYPES.filter(m => m.minLevel <= nextMonsterLevel);
        const monsterData = isNextBoss
            ? BOSS_TYPES[Math.floor(Math.random() * BOSS_TYPES.length)]
            : availableMonsters[Math.floor(Math.random() * availableMonsters.length)];
        
        const elementKeys = Object.keys(ELEMENT_TYPES);
        const newElement = elementKeys[Math.floor(Math.random() * elementKeys.length)];

        setMonsterStats({
            name: monsterData.name,
            Icon: monsterData.Icon,
            level: nextMonsterLevel,
            hp: Math.ceil(newMonsterHp),
            maxHp: Math.ceil(newMonsterHp),
            isBoss: isNextBoss,
            element: newElement,
        });
        
        needsSave.current = true;
    }, [playerStats, monsterStats, finalAbilityStats, finalStats.luck, difficultyMultipliers, addLog, generateRandomItem, isAutoDropEnabled, timeWarpActive, treasureGolem.isActive, updateMissionProgress]);


    const handleMonsterClick = () => {
        if (monsterStats.hp <= 0 || newItemDrop || isJobSelectionOpen || selectedInventoryItem) return;
        
        const isStunned = isMonsterStunned;
        const bossMultiplier = monsterStats.isBoss ? (1 + finalAbilityStats.bossDamageBonus / 100) : 1;
        
        let overwhelmMultiplier = 1;
        if (overwhelmState.active) {
            overwhelmMultiplier = 3; // 200% additional damage
            const newClicksLeft = overwhelmState.clicksLeft - 1;
            if (newClicksLeft === 0) {
                if(!isMonsterStunned) {
                    setIsMonsterStunned(true);
                    setTimeout(() => setIsMonsterStunned(false), 1500);
                    addLog('ì••ë„ ë§ˆì§€ë§‰ íƒ€ê²©! ëª¬ìŠ¤í„°ë¥¼ 1.5ì´ˆê°„ ê¸°ì ˆì‹œí‚µë‹ˆë‹¤!');
                }
            }
            setOverwhelmState({ active: newClicksLeft > 0, clicksLeft: newClicksLeft });
        }
        
        const isCrit = isStunned || (Math.random() * 100 < finalStats.critChance);
        const critMultiplier = isCrit ? finalStats.critDamage / 100 : 1;
        const elementalEffect = getElementalEffect();
        let damageDealt = Math.floor(finalStats.clickDamage * critMultiplier * bossMultiplier * elementalEffect.multiplier * overwhelmMultiplier);
        
        if (magicStormDebuff.active && magicStormDebuff.expires > Date.now()) {
            damageDealt = Math.floor(damageDealt * 1.20);
        }

        // Elemental Procs
        const powerMultiplier = 1 + (abilityStats.elementalPowerBonus / 100);
        let bonusDamage = 0;
        let popupType = elementalEffect.type;

        if (playerElement === 'WATER' && Math.random() < (0.05 * powerMultiplier)) {
            bonusDamage = Math.floor(finalStats.clickDamage * 2.0);
            addLog(`<strong class="text-blue-400">ë¬¼ì˜ ì›ì†Œ: ì¶”ê°€ í”¼í•´ +${formatNumber(bonusDamage)}!</strong>`);
        } else if (playerElement === 'EARTH' && isCrit && Math.random() < (0.20 * powerMultiplier)) {
            if(!isMonsterStunned) {
                setIsMonsterStunned(true);
                setTimeout(() => setIsMonsterStunned(false), 500);
                addLog('<strong class="text-yellow-700">ë•…ì˜ ì›ì†Œ: ëª¬ìŠ¤í„° 0.5ì´ˆ ê¸°ì ˆ!</strong>');
            }
        } else if (playerElement === 'FIRE' && Math.random() < (0.10 * powerMultiplier) && !elementalEffects.fire_dot) {
            const dotDamage = finalStats.autoAttackDamage * 0.20 * powerMultiplier;
            setElementalEffects(prev => ({ ...prev, fire_dot: { expires: Date.now() + 3000, damagePerTick: dotDamage } }));
            addLog('<strong class="text-red-500">ë¶ˆì˜ ì›ì†Œ: ëª¬ìŠ¤í„°ì—ê²Œ í™”ìƒ!</strong>');
        }

        if (playerElement === 'WIND') {
            if(windStackDecayTimer.current) clearTimeout(windStackDecayTimer.current);
            windStackDecayTimer.current = setTimeout(() => {
                setElementalEffects(prev => ({...prev, wind_stacks: 0}));
                addLog('<strong class="text-gray-400">ë°”ëŒì˜ ì›ì†Œ: ì¤‘ì²© ì´ˆê¸°í™”.</strong>');
            }, 5000);
            setElementalEffects(prev => ({...prev, wind_stacks: Math.min(20, prev.wind_stacks + 1)}));
        }

        damageDealt += bonusDamage;

        if (bonusDamage > 0) popupType = 'elemental';
        else if (popupType === 'normal' && isCrit) popupType = 'crit';

        createDamagePopup(damageDealt, popupType, elementalEffect.prefix);

        setMonsterStats(prev => {
            const newHp = prev.hp - damageDealt;
            return { ...prev, hp: newHp };
        });
    };

    const handleGenericUpgrade = useCallback((costKey, levelKey, base, multiplier, statUpdateFn) => {
        const cost = upgrades[costKey];
        if(playerStats.coins < cost) return;

        setPlayerStats(prev => ({...prev, coins: prev.coins - cost}));
        setUpgrades(prev => {
            const newLevel = (prev[levelKey] || 0) + 1;
            return {
                ...prev,
                [costKey]: Math.floor(base * Math.pow(multiplier, newLevel)),
                [levelKey]: newLevel,
            };
        });
        statUpdateFn();
        updateMissionProgress('UPGRADE_TIMES', 1);
        needsSave.current = true;
    }, [upgrades, playerStats.coins, updateMissionProgress]);

    const handleUseSkill1 = useCallback(() => {
        if (!playerClass || activeSkillCooldown > 0 || monsterStats.hp <= 0) return;

        const job = JOBS[playerClass];
        const skill = job.skill;
        addLog(`<strong class="text-orange-400">ìŠ¤í‚¬ ì‚¬ìš©: ${skill.name}!</strong>`);
        setActiveSkillCooldown(finalAbilityStats.activeSkillCooldown);

        const skillPower = 1 + (finalAbilityStats.skillDamageBonus / 100);
        const skillDuration = 1 + (finalAbilityStats.skillDurationBonus / 100);

        switch (playerClass) {
            case 'WARRIOR': { // ì†Œìš©ëŒì´
                if (whirlwindIntervalRef.current) clearInterval(whirlwindIntervalRef.current);
                let ticks = 0;
                const duration = 5000 * skillDuration;
                whirlwindIntervalRef.current = setInterval(() => {
                    if (ticks >= 5) {
                        clearInterval(whirlwindIntervalRef.current);
                        whirlwindIntervalRef.current = null;
                        return;
                    }
                    const damage = Math.floor(finalStats.autoAttackDamage * 3.0 * skillPower);
                    createDamagePopup(damage, 'skill');
                    setMonsterStats(prev => {
                        if (prev.hp <= 0) {
                           clearInterval(whirlwindIntervalRef.current);
                           whirlwindIntervalRef.current = null;
                           return prev;
                        }
                        const newHp = prev.hp - damage;
                        return { ...prev, hp: newHp };
                    });
                    ticks++;
                }, duration / 5);
                break;
            }
            case 'ARCHER': { // ì§‘ì¤‘ì˜ ì‹œê°„
                const damage = Math.floor(finalStats.autoAttackDamage * 3.0 * skillPower);
                createDamagePopup(damage, 'skill');
                setMonsterStats(prev => ({ ...prev, hp: prev.hp - damage }));

                setFocusTimeActive(true);
                setTimeout(() => setFocusTimeActive(false), 10000 * skillDuration);
                break;
            }
            case 'MAGE': { // ìš´ì„ ë‚™í•˜
                const totalAtk = finalStats.clickDamage + finalStats.autoAttackDamage;
                const damage = Math.floor(totalAtk * 25 * skillPower);
                createDamagePopup(damage, 'skill');
                
                const elementalEffect = getElementalEffect();
                if (elementalEffect.type === 'elemental') {
                    addLog('ëª¬ìŠ¤í„°ê°€ ë¹™ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!');
                    setIsMonsterStunned(true);
                    setTimeout(() => setIsMonsterStunned(false), 3000 * skillDuration);
                }

                setMonsterStats(prev => {
                    const newHp = prev.hp - damage;
                    return { ...prev, hp: newHp };
                });
                break;
            }
        }
    }, [playerClass, activeSkillCooldown, finalStats, finalAbilityStats, monsterStats.hp, addLog, createDamagePopup, getElementalEffect]);

    const handleUseSkill2 = useCallback(() => {
        if (!playerClass || secondSkillCooldown > 0 || monsterStats.hp <= 0) return;

        const job = JOBS[playerClass];
        const skill = job.skill2;
        addLog(`<strong class="text-cyan-400">ìŠ¤í‚¬ ì‚¬ìš©: ${skill.name}!</strong>`);
        setSecondSkillCooldown(job.skill2.cooldown * (1 - finalAbilityStats.haste / 100));

        const skillPower = 1 + (finalAbilityStats.skillDamageBonus / 100);
        const skillDuration = 1 + (finalAbilityStats.skillDurationBonus / 100);

        switch (playerClass) {
            case 'WARRIOR': { // ì••ë„
                setOverwhelmState({ active: true, clicksLeft: 5 });
                break;
            }
            case 'ARCHER': { // ì €ê²©
                const missingHp = monsterStats.maxHp - monsterStats.hp;
                let damage = missingHp * 0.15 * skillPower;
                const maxDamage = finalStats.autoAttackDamage * 20;
                damage = Math.min(damage, maxDamage);
                damage = Math.floor(damage * (finalStats.critDamage / 100)); // Always crit
                createDamagePopup(damage, 'crit');
                setMonsterStats(prev => {
                    const newHp = prev.hp - damage;
                    return { ...prev, hp: newHp };
                });
                break;
            }
            case 'MAGE': { // ì‹œê°„ ì™œê³¡
                const totalAtk = finalStats.clickDamage + finalStats.autoAttackDamage;
                const damage = Math.floor(totalAtk * 5.0 * skillPower);
                createDamagePopup(damage, 'skill');
                setMonsterStats(prev => ({ ...prev, hp: prev.hp - damage }));

                setTimeWarpActive(true);
                setTimeout(() => setTimeWarpActive(false), 10000 * skillDuration);
                break;
            }
        }
    }, [playerClass, secondSkillCooldown, finalStats, finalAbilityStats, monsterStats, addLog, createDamagePopup]);

    const handleUseSkill3 = useCallback(() => {
        if (!playerClass || thirdSkillCooldown > 0 || monsterStats.hp <= 0) return;

        const job = JOBS[playerClass];
        const skill = job.skill3;
        addLog(`<strong class="text-purple-400">ìŠ¤í‚¬ ì‚¬ìš©: ${skill.name}!</strong>`);
        setThirdSkillCooldown(job.skill3.cooldown * (1 - finalAbilityStats.haste / 100));

        const skillPower = 1 + (finalAbilityStats.skillDamageBonus / 100);
        const skillDuration = 1 + (finalAbilityStats.skillDurationBonus / 100);

        let damage = 0;
        switch (playerClass) {
            case 'WARRIOR': { // ëŒ€ì§€ ë¶„ì‡„
                damage = Math.floor(finalStats.autoAttackDamage * 8.0 * skillPower);
                createDamagePopup(damage, 'skill');
                if(!isMonsterStunned) {
                    setIsMonsterStunned(true);
                    setTimeout(() => setIsMonsterStunned(false), 1000 * skillDuration);
                    addLog('ëŒ€ì§€ ë¶„ì‡„! ëª¬ìŠ¤í„°ë¥¼ 1ì´ˆê°„ ê¸°ì ˆì‹œí‚µë‹ˆë‹¤!');
                }
                setMonsterStats(prev => ({ ...prev, hp: prev.hp - damage }));
                break;
            }
            case 'ARCHER': { // ì•½ì  íƒìƒ‰
                damage = Math.floor(finalStats.autoAttackDamage * 5.0 * skillPower);
                createDamagePopup(damage, 'skill');
                setMonsterStats(prev => ({ ...prev, hp: prev.hp - damage }));
                setWeaknessFoundActive(true);
                setTimeout(() => setWeaknessFoundActive(false), 15000 * skillDuration);
                break;
            }
            case 'MAGE': { // ë§ˆë ¥ í­í’
                const totalAtk = finalStats.clickDamage + finalStats.autoAttackDamage;
                damage = Math.floor(totalAtk * 15.0 * skillPower);
                createDamagePopup(damage, 'skill');
                setMonsterStats(prev => ({ ...prev, hp: prev.hp - damage }));
                setMagicStormDebuff({ active: true, expires: Date.now() + (5000 * skillDuration) });
                break;
            }
        }
    }, [playerClass, thirdSkillCooldown, finalStats, finalAbilityStats, monsterStats.hp, addLog, createDamagePopup, isMonsterStunned]);

    const handleLiberate = () => {
        if (playerStats.coins < liberationCost) {
            addLog(`<strong class="text-red-400">í•´ë°©ì— í•„ìš”í•œ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.</strong>`);
            return;
        }
        if (confirm(`ì •ë§ë¡œ í•´ë°©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n${formatNumber(liberationCost)} ê³¨ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ìŠ¤íƒ¯ì„ ì˜êµ¬ì ìœ¼ë¡œ 2ë°°ë¡œ ë§Œë“­ë‹ˆë‹¤.`)) {
            setPlayerStats(prev => ({...prev, coins: prev.coins - liberationCost}));
            setLiberationCount(prev => prev + 1);
            addLog(`<strong class="text-yellow-300">í•´ë°© ì™„ë£Œ! ëª¨ë“  ìŠ¤íƒ¯ì´ 2ë°°ë¡œ ì¦ê°€í–ˆìŠµë‹ˆë‹¤!</strong>`);
            needsSave.current = true;
        }
    };

    const handlers = useMemo(() => ({
        onUpgradeClick: () => handleGenericUpgrade('clickUpgradeCost', 'clickUpgradeLevel', CLICK_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, CLICK_UPGRADE_COST_MULTIPLIER, () => {
            setPlayerStats(prev => ({ ...prev, clickDamage: prev.clickDamage + prev.level }));
        }),
        onUpgradeAutoAttack: () => handleGenericUpgrade('autoAttackUpgradeCost', 'autoAttackUpgradeLevel', AUTO_ATTACK_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, AUTO_ATTACK_UPGRADE_COST_MULTIPLIER, () => {
            setPlayerStats(prev => ({ ...prev, autoAttackDamage: prev.autoAttackDamage + Math.ceil(prev.level * 0.5) }));
        }),
        onUpgradeAttackSpeed: () => handleGenericUpgrade('attackSpeedUpgradeCost', 'attackSpeedUpgradeLevel', ATTACK_SPEED_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, ATTACK_SPEED_UPGRADE_COST_MULTIPLIER, () => {
            setPlayerStats(prev => ({ ...prev, attackSpeed: prev.attackSpeed + 0.1 }));
        }),
        onUpgradeCritChance: () => handleGenericUpgrade('critChanceUpgradeCost', null, CRIT_CHANCE_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, CRIT_CHANCE_UPGRADE_COST_MULTIPLIER, () => {
            setPlayerStats(prev => ({ ...prev, critChance: prev.critChance + CRIT_CHANCE_UPGRADE_INCREASE }));
            setUpgrades(prev => ({ ...prev, critChanceUpgradeCost: Math.floor(prev.critChanceUpgradeCost * CRIT_CHANCE_UPGRADE_COST_MULTIPLIER) }));
        }),
        onUpgradeCritDamage: () => handleGenericUpgrade('critDamageUpgradeCost', null, CRIT_DAMAGE_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, CRIT_DAMAGE_UPGRADE_COST_MULTIPLIER, () => {
            setPlayerStats(prev => ({ ...prev, critDamage: prev.critDamage + CRIT_DAMAGE_UPGRADE_INCREASE }));
            setUpgrades(prev => ({ ...prev, critDamageUpgradeCost: Math.floor(prev.critDamageUpgradeCost * CRIT_DAMAGE_UPGRADE_COST_MULTIPLIER) }));
        }),
        onUpgradeLuck: () => handleGenericUpgrade('luckUpgradeCost', null, LUCK_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, LUCK_UPGRADE_COST_MULTIPLIER, () => {
            setPlayerStats(prev => ({...prev, luck: prev.luck + 1 }));
            setUpgrades(prev => ({ ...prev, luckUpgradeCost: Math.floor(prev.luckUpgradeCost * LUCK_UPGRADE_COST_MULTIPLIER) }));
        }),
        onUpgradeGoldGain: () => handleGenericUpgrade('goldGainUpgradeCost', null, GOLD_GAIN_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, GOLD_GAIN_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({ ...prev, goldGainBonus: prev.goldGainBonus + 5 }));
            setUpgrades(prev => ({ ...prev, goldGainUpgradeCost: Math.floor(prev.goldGainUpgradeCost * GOLD_GAIN_UPGRADE_COST_MULTIPLIER) }));
        }),
        onUpgradeXpGain: () => handleGenericUpgrade('xpGainUpgradeCost', null, XP_GAIN_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, XP_GAIN_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({ ...prev, xpGainBonus: prev.xpGainBonus + 5 }));
            setUpgrades(prev => ({ ...prev, xpGainUpgradeCost: Math.floor(prev.xpGainUpgradeCost * XP_GAIN_UPGRADE_COST_MULTIPLIER) }));
        }),
        onUpgradeHaste: () => handleGenericUpgrade('hasteUpgradeCost', null, HASTE_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, HASTE_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({ ...prev, haste: prev.haste + 1 }));
            setUpgrades(prev => ({ ...prev, hasteUpgradeCost: Math.floor(prev.hasteUpgradeCost * HASTE_UPGRADE_COST_MULTIPLIER) }));
        }),
        onUpgradeSkillDamage: () => handleGenericUpgrade('skillDamageUpgradeCost', null, SKILL_DAMAGE_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, SKILL_DAMAGE_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({ ...prev, skillDamageBonus: prev.skillDamageBonus + 10 }));
            setUpgrades(prev => ({ ...prev, skillDamageUpgradeCost: Math.floor(prev.skillDamageUpgradeCost * SKILL_DAMAGE_UPGRADE_COST_MULTIPLIER) }));
        }),
        onUpgradeBossDamage: () => handleGenericUpgrade('bossDamageUpgradeCost', null, BOSS_DAMAGE_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, BOSS_DAMAGE_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({ ...prev, bossDamageBonus: prev.bossDamageBonus + 2 }));
            setUpgrades(prev => ({ ...prev, bossDamageUpgradeCost: Math.floor(prev.bossDamageUpgradeCost * BOSS_DAMAGE_UPGRADE_COST_MULTIPLIER) }));
        }),
        onUpgradeFinalDamage: () => handleGenericUpgrade('finalDamageUpgradeCost', null, FINAL_DAMAGE_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, FINAL_DAMAGE_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({...prev, finalDamageBonus: prev.finalDamageBonus + 1}));
            setUpgrades(prev => ({...prev, finalDamageUpgradeCost: Math.floor(prev.finalDamageUpgradeCost * FINAL_DAMAGE_UPGRADE_COST_MULTIPLIER)}));
        }),
        onUpgradeSkillDuration: () => handleGenericUpgrade('skillDurationUpgradeCost', null, SKILL_DURATION_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, SKILL_DURATION_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({...prev, skillDurationBonus: prev.skillDurationBonus + 2}));
            setUpgrades(prev => ({...prev, skillDurationUpgradeCost: Math.floor(prev.skillDurationUpgradeCost * SKILL_DURATION_UPGRADE_COST_MULTIPLIER)}));
        }),
        onUpgradeElementalPower: () => handleGenericUpgrade('elementalPowerUpgradeCost', null, ELEMENTAL_POWER_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, ELEMENTAL_POWER_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({...prev, elementalPowerBonus: prev.elementalPowerBonus + 2}));
            setUpgrades(prev => ({...prev, elementalPowerUpgradeCost: Math.floor(prev.elementalPowerUpgradeCost * ELEMENTAL_POWER_UPGRADE_COST_MULTIPLIER)}));
        }),
        onUpgradeOfflineRewards: () => handleGenericUpgrade('offlineRewardsUpgradeCost', null, OFFLINE_REWARDS_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, OFFLINE_REWARDS_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({...prev, offlineRewardsBonus: prev.offlineRewardsBonus + 2}));
            setUpgrades(prev => ({...prev, offlineRewardsUpgradeCost: Math.floor(prev.offlineRewardsUpgradeCost * OFFLINE_REWARDS_UPGRADE_COST_MULTIPLIER)}));
        }),
        onUpgradeTreasureGolemChance: () => handleGenericUpgrade('treasureGolemChanceUpgradeCost', null, TREASURE_GOLEM_CHANCE_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, TREASURE_GOLEM_CHANCE_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({...prev, treasureGolemChanceBonus: prev.treasureGolemChanceBonus + 0.1}));
            setUpgrades(prev => ({...prev, treasureGolemChanceUpgradeCost: Math.floor(prev.treasureGolemChanceUpgradeCost * TREASURE_GOLEM_CHANCE_UPGRADE_COST_MULTIPLIER)}));
        }),
        onUpgradeArtifactPower: () => handleGenericUpgrade('artifactPowerUpgradeCost', null, ARTIFACT_POWER_UPGRADE_COST_BASE * difficultyMultipliers.upgradeCost, ARTIFACT_POWER_UPGRADE_COST_MULTIPLIER, () => {
            setAbilityStats(prev => ({...prev, artifactPowerBonus: prev.artifactPowerBonus + 1}));
            setUpgrades(prev => ({...prev, artifactPowerUpgradeCost: Math.floor(prev.artifactPowerUpgradeCost * ARTIFACT_POWER_UPGRADE_COST_MULTIPLIER)}));
        }),
        onEquipmentGacha: () => {
            if (playerStats.coins < equipmentGachaCost) return;
            setPlayerStats(prev => ({...prev, coins: prev.coins - equipmentGachaCost }));
            const newItem = generateRandomItem(playerStats.level);
            addLog(`ì¥ë¹„ ë½‘ê¸°: <span class="${RARITIES[newItem.rarity].textClass}">[${RARITIES[newItem.rarity].name}] ${newItem.name}</span> íšë“!`);
            setNewItemDrop(newItem);
            updateMissionProgress('UPGRADE_TIMES', 1);
        },
        onSelectItem: (item) => {
            if (!item) return;
            setSelectedInventoryItem(item);
        },
        onEquipItem: (item) => {
            if (!item) return;
            const itemTypeKey = item.type.toLowerCase();
            const currentItem = equipment[itemTypeKey];
            
            setEquipment(prev => ({ ...prev, [itemTypeKey]: item }));
            setInventory(prev => {
                const newInventory = prev.filter(invItem => invItem.id !== item.id);
                if (currentItem) {
                    newInventory.push(currentItem);
                }
                return newInventory;
            });
            addLog(`<span class="${RARITIES[item.rarity].textClass}">${item.name}</span>ì„(ë¥¼) ì¥ì°©í–ˆìŠµë‹ˆë‹¤.`);
            needsSave.current = true;
        },
        onSellItem: (item) => {
            if (item.locked) {
                addLog('ì ê¸ˆ ìƒíƒœì˜ ì•„ì´í…œì€ íŒë§¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            const sellPrice = Math.ceil((item.baseLevel || 1) * RARITIES[item.rarity].statMultiplier * 2);
            setPlayerStats(prev => ({ ...prev, coins: prev.coins + sellPrice }));
            setInventory(prev => prev.filter(invItem => invItem.id !== item.id));
            addLog(`<span class="${RARITIES[item.rarity].textClass}">${item.name}</span> íŒë§¤! +${formatNumber(sellPrice)} <span class="text-yellow-400">ê³¨ë“œ</span>`);
            needsSave.current = true;
        },
        onToggleSellMode: () => setIsSellMode(prev => !prev),
        onToggleSellItem: (item) => {
            if (item.locked) {
                addLog('ì ê¸ˆ ìƒíƒœì˜ ì•„ì´í…œì€ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            setSellList(prev => {
                const newSet = new Set(prev);
                if (newSet.has(item.id)) {
                    newSet.delete(item.id);
                } else {
                    newSet.add(item.id);
                }
                return newSet;
            });
        },
        onBulkSell: () => {
            let totalSellPrice = 0;
            const itemsToSell = inventory.filter(item => sellList.has(item.id));
            itemsToSell.forEach(item => {
                totalSellPrice += Math.ceil((item.baseLevel || 1) * RARITIES[item.rarity].statMultiplier * 2);
            });
            setPlayerStats(prev => ({ ...prev, coins: prev.coins + totalSellPrice }));
            setInventory(prev => prev.filter(item => !sellList.has(item.id)));
            addLog(`${sellList.size}ê°œì˜ ì•„ì´í…œ íŒë§¤! +${formatNumber(totalSellPrice)} <span class="text-yellow-400">ê³¨ë“œ</span>`);
            setSellList(new Set());
            setIsSellMode(false);
            needsSave.current = true;
        },
        onBulkSellByRarity: (rarity) => {
            const itemsToSell = inventory.filter(item => item.rarity === rarity && !item.locked);
            if (itemsToSell.length === 0) {
                addLog(`${RARITIES[rarity].name} ë“±ê¸‰ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.`);
                return;
            }
            let totalSellPrice = 0;
            itemsToSell.forEach(item => {
                totalSellPrice += Math.ceil((item.baseLevel || 1) * RARITIES[item.rarity].statMultiplier * 2);
            });
            setPlayerStats(prev => ({ ...prev, coins: prev.coins + totalSellPrice }));
            setInventory(prev => prev.filter(item => item.rarity !== rarity || item.locked));
            addLog(`${itemsToSell.length}ê°œì˜ ${RARITIES[rarity].name} ë“±ê¸‰ ì•„ì´í…œ íŒë§¤! +${formatNumber(totalSellPrice)} <span class="text-yellow-400">ê³¨ë“œ</span>`);
            needsSave.current = true;
        },
        onForgeItem: (item) => {
            const upgradeCost = Math.ceil(RARITIES[item.rarity].statMultiplier * 30 * Math.pow(1.35, item.level || 0) * (1 + (item.level || 0) * 0.1));
            if (playerStats.coins < upgradeCost) return;

            setPlayerStats(prev => ({...prev, coins: prev.coins - upgradeCost}));
            const updateItem = (i) => ({ ...i, level: (i.level || 0) + 1 });
            
            const itemTypeKey = item.type.toLowerCase();
            if (equipment[itemTypeKey]?.id === item.id) {
                setEquipment(prev => ({...prev, [itemTypeKey]: updateItem(prev[itemTypeKey]) }));
            } else {
                 setInventory(prev => prev.map(invItem => invItem.id === item.id ? updateItem(invItem) : invItem));
            }
            setSelectedForgeItem(prev => updateItem(prev));
            addLog(`${item.name} ê°•í™” ì„±ê³µ! (+${(item.level || 0) + 1})`);
            updateMissionProgress('UPGRADE_TIMES', 1);
        },
        onReforgeItem: (item) => {
            const cost = Math.ceil(RARITIES[item.rarity].statMultiplier * 500 * (1 + (item.level || 0) * 0.5) * (item.baseLevel || 1));
            if (playerStats.coins < cost) return;

            setPlayerStats(prev => ({ ...prev, coins: prev.coins - cost }));
            const newStats = calculateItemStats(item.baseLevel, item.rarity, item.type);
            const updateItem = (i) => ({ ...i, stats: newStats });
            
            const itemTypeKey = item.type.toLowerCase();
            if (equipment[itemTypeKey]?.id === item.id) {
                setEquipment(prev => ({...prev, [itemTypeKey]: updateItem(prev[itemTypeKey]) }));
            } else {
                 setInventory(prev => prev.map(invItem => invItem.id === item.id ? updateItem(invItem) : invItem));
            }
            setSelectedForgeItem(prev => updateItem(prev));
            addLog(`${item.name} ì¬ë ¨ ì™„ë£Œ!`);
            updateMissionProgress('UPGRADE_TIMES', 1);
        },
        onUpgradeRarity: (item) => {
            const currentRarityIndex = RARITY_ORDER.indexOf(item.rarity);
            if (currentRarityIndex >= RARITY_ORDER.length - 1) return;

            const cost = Math.ceil(Math.pow(8, currentRarityIndex + 1.5) * (item.baseLevel || 1) * RARITIES[item.rarity].statMultiplier * 10);
            if (playerStats.coins < cost) return;

            setPlayerStats(prev => ({ ...prev, coins: prev.coins - cost }));
            
            const nextRarityKey = RARITY_ORDER[currentRarityIndex + 1];
            const nextRarity = RARITIES[nextRarityKey];
            const newStats = calculateItemStats(item.baseLevel, nextRarityKey, item.type);
            const updateItem = (i) => ({ ...i, rarity: nextRarityKey, name: `${nextRarity.name} ${EQUIPMENT_TYPES[i.type].name}`, stats: newStats });
            
            const itemTypeKey = item.type.toLowerCase();
            if (equipment[itemTypeKey]?.id === item.id) {
                setEquipment(prev => ({...prev, [itemTypeKey]: updateItem(prev[itemTypeKey]) }));
            } else {
                 setInventory(prev => prev.map(invItem => invItem.id === item.id ? updateItem(invItem) : invItem));
            }
            setSelectedForgeItem(prev => updateItem(prev));
            addLog(`${item.name} ë“±ê¸‰ ìŠ¹ê¸‰! -> ${nextRarity.name}`);
            updateMissionProgress('UPGRADE_TIMES', 1);
        },
        onToggleLock: (item) => {
            const updateLock = (i) => ({...i, locked: !i.locked});
            const itemTypeKey = item.type.toLowerCase();
            if (equipment[itemTypeKey]?.id === item.id) {
                 setEquipment(prev => ({...prev, [itemTypeKey]: updateLock(prev[itemTypeKey])}));
            } else {
                 setInventory(prev => prev.map(invItem => invItem.id === item.id ? updateLock(invItem) : invItem));
            }
            setSelectedInventoryItem(prev => updateLock(prev));
            addLog(`${item.name} ${!item.locked ? 'ì ê¸ˆ' : 'ì ê¸ˆ í•´ì œ'}.`);
        },
        onClaimMission: (missionId) => {
            const mission = missions.find(m => m.id === missionId);
            if (mission && mission.isCompleted) {
                setPlayerStats(prev => ({...prev, coins: prev.coins + mission.reward}));
                setMissions(prev => prev.filter(m => m.id !== missionId));
                addLog(`ì„ë¬´ ë³´ìƒ íšë“! +${formatNumber(mission.reward)} <span class="text-yellow-400">ê³¨ë“œ</span>`);
                needsSave.current = true;
            }
        },
        onEquipArtifact: (id) => {
            if (equippedArtifacts.length >= 3) {
                addLog('ìœ ë¬¼ ìŠ¬ë¡¯ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤.');
                return;
            }
            if (!equippedArtifacts.includes(id)) {
                setEquippedArtifacts(prev => [...prev, id]);
                const artifact = ARTIFACTS.find(a => a.id === id);
                addLog(`${artifact.name} ìœ ë¬¼ì„ ì¥ì°©í–ˆìŠµë‹ˆë‹¤.`);
                needsSave.current = true;
            }
        },
        onUnequipArtifact: (id) => {
            setEquippedArtifacts(prev => prev.filter(artId => artId !== id));
            const artifact = ARTIFACTS.find(a => a.id === id);
            addLog(`${artifact.name} ìœ ë¬¼ì„ í•´ì œí–ˆìŠµë‹ˆë‹¤.`);
            needsSave.current = true;
        },
        onArtifactGacha: () => {
            const cost = 1000;
            if (playerStats.coins < cost || ownedArtifacts.length >= ARTIFACTS.length) return;
            
            setPlayerStats(prev => ({...prev, coins: prev.coins - cost}));
            updateMissionProgress('UPGRADE_TIMES', 1);
            
            const available = ARTIFACTS.filter(a => !ownedArtifacts.includes(a.id));
            if (available.length > 0) {
                const newArtifact = available[Math.floor(Math.random() * available.length)];
                setOwnedArtifacts(prev => [...prev, newArtifact.id]);
                addLog(`ìƒˆë¡œìš´ ìœ ë¬¼ íšë“: <strong class="text-yellow-400">${newArtifact.name}</strong>!`);
                needsSave.current = true;
            }
        },
        onSlotSpin: (cost, callback) => {
            if (playerStats.coins < cost) return;
            setPlayerStats(prev => ({...prev, coins: prev.coins - cost}));

            const symbolKeys = ['COIN', 'SWORD', 'GEM', 'CLOVER', 'G_SLIME', 'R_SLIME', 'B_SLIME'];
            const reels = [
                symbolKeys[Math.floor(Math.random() * symbolKeys.length)],
                symbolKeys[Math.floor(Math.random() * symbolKeys.length)],
                symbolKeys[Math.floor(Math.random() * symbolKeys.length)],
            ];

            let reward = { gold: 0, message: "ê½!"};
            const [r1, r2, r3] = reels;
            if (r1 === r2 && r2 === r3) {
                if(r1 === 'COIN') { reward = { gold: cost * 10, message: 'ì­íŒŸ! ì½”ì¸ x10!'}; }
                else if(r1 === 'GEM') { reward = { gold: cost * 20, message: 'ëŒ€ì„±ê³µ! ë‹¤ì´ì•„ x20!'}; }
                else { reward = { gold: cost * 5, message: 'ì„±ê³µ! x5 ë³´ìƒ!'}; }
            } else if (r1 === r2 || r2 === r3 || r1 === r3) {
                reward = { gold: cost * 2, message: 'ì•„ì‰½ë„¤ìš”! x2 ë³´ìƒ.'};
            }
            setPlayerStats(prev => ({...prev, coins: prev.coins + reward.gold}));
            if (reward.gold > 0) addLog(`ìŠ¬ë¡¯ë¨¸ì‹ : +${formatNumber(reward.gold)} ê³¨ë“œ!`);
            callback(reels, reward);
        },
        onSlimeWhackStart: (cost) => {
            if (playerStats.coins < cost) return false;
            setPlayerStats(p => ({...p, coins: p.coins - cost}));
            return true;
        },
        onSlimeWhackEnd: (reward) => {
             setPlayerStats(p => ({...p, coins: p.coins + reward}));
             addLog(`ë‘ë”ì§€ ìŠ¬ë¼ì„: +${formatNumber(reward)} ê³¨ë“œ!`);
        },
        onLiberate: handleLiberate,
        onRebirth: onRebirth,
    }), [playerStats, equipment, upgrades, liberationCost, equipmentGachaCost, difficultyMultipliers.upgradeCost, inventory, sellList, missions, handleGenericUpgrade, generateRandomItem, addLog, isMonsterStunned, isAutoDropEnabled, finalAbilityStats, finalStats, playerClass, monsterStats, activeSkillCooldown, secondSkillCooldown, thirdSkillCooldown, handleLiberate, onRebirth, equippedArtifacts, ownedArtifacts]);
    
    // Auto attack loop
    useEffect(() => {
        const attackInterval = setInterval(() => {
            if (finalStats.autoAttackDamage > 0 && monsterStats.hp > 0 && !newItemDrop && !isJobSelectionOpen && !selectedInventoryItem) {
                const isStunned = isMonsterStunned;
                const bossMultiplier = monsterStats.isBoss ? (1 + finalAbilityStats.bossDamageBonus / 100) : 1;
                const isCrit = isStunned || focusTimeActive || (Math.random() * 100 < finalStats.critChance);
                const critMultiplier = isCrit ? finalStats.critDamage / 100 : 1;
                const elementalEffect = getElementalEffect();
                let damageDealt = Math.floor(finalStats.autoAttackDamage * critMultiplier * bossMultiplier * elementalEffect.multiplier);
                
                if (magicStormDebuff.active && magicStormDebuff.expires > Date.now()) {
                    damageDealt = Math.floor(damageDealt * 1.20);
                }

                createDamagePopup(damageDealt, isCrit ? 'crit' : 'normal');

                setMonsterStats(prev => {
                    const newHp = prev.hp - damageDealt;
                    return { ...prev, hp: newHp };
                });
            }
        }, 1000 / finalStats.attackSpeed);
        return () => clearInterval(attackInterval);
    }, [finalStats, monsterStats.hp, finalAbilityStats.bossDamageBonus, isMonsterStunned, newItemDrop, isJobSelectionOpen, selectedInventoryItem, createDamagePopup, getElementalEffect, focusTimeActive, magicStormDebuff]);
    
    // Monster defeat check
    useEffect(() => { if (monsterStats.hp <= 0 && !treasureGolem.isActive) { handleMonsterDefeat(); } }, [monsterStats.hp, treasureGolem.isActive, handleMonsterDefeat]);

    // Skill cooldown timers
    useEffect(() => {
        if (activeSkillCooldown > 0) {
            const timer = setTimeout(() => {
                const reduction = timeWarpActive ? 200 : 100;
                setActiveSkillCooldown(prev => Math.max(0, prev - reduction));
            }, 100);
            return () => clearTimeout(timer);
        }
    }, [activeSkillCooldown, timeWarpActive]);
    
    useEffect(() => {
        if (secondSkillCooldown > 0) {
            const timer = setTimeout(() => {
                const reduction = timeWarpActive ? 200 : 100;
                setSecondSkillCooldown(prev => Math.max(0, prev - reduction));
            }, 100);
            return () => clearTimeout(timer);
        }
    }, [secondSkillCooldown, timeWarpActive]);
    
    useEffect(() => {
        if (thirdSkillCooldown > 0) {
            const timer = setTimeout(() => {
                const reduction = timeWarpActive ? 200 : 100;
                setThirdSkillCooldown(prev => Math.max(0, prev - reduction));
            }, 100);
            return () => clearTimeout(timer);
        }
    }, [thirdSkillCooldown, timeWarpActive]);
    
    // Treasure Golem timer
    useEffect(() => {
        if (treasureGolem.isActive && treasureGolem.timer > 0) {
            const timer = setTimeout(() => setTreasureGolem(prev => ({ ...prev, timer: prev.timer - 1 })), 1000);
            return () => clearTimeout(timer);
        } else if (treasureGolem.isActive && treasureGolem.timer <= 0) {
            addLog("ë³´ë¬¼ ê³¨ë ˜ì´ ë„ë§ì³¤ìŠµë‹ˆë‹¤!");
            setTreasureGolem({ isActive: false, timer: 0 });
            handleMonsterDefeat(); // Spawn a new regular monster
        }
    }, [treasureGolem, handleMonsterDefeat, addLog]);

    // Elemental DoT timer
    useEffect(() => {
        if (elementalEffects.fire_dot) {
            if (Date.now() > elementalEffects.fire_dot.expires || monsterStats.hp <= 0) {
                setElementalEffects(prev => ({ ...prev, fire_dot: null }));
                return;
            }
            const timer = setInterval(() => {
                createDamagePopup(elementalEffects.fire_dot.damagePerTick, 'elemental', 'ğŸ”¥');
                setMonsterStats(prev => ({...prev, hp: prev.hp - elementalEffects.fire_dot.damagePerTick}));
            }, 1000);
            return () => clearInterval(timer);
        }
    }, [elementalEffects.fire_dot, monsterStats.hp, createDamagePopup]);

    // Initial setup
    useEffect(() => {
        if (!difficulty) { setIsDifficultyModalOpen(true); }
        else if (!playerClass) { setIsJobSelectionOpen(true); }
    }, [difficulty, playerClass]);

    if (!difficulty) return <DifficultySelectionModal onSelect={handleSelectDifficulty} />;
    
    return (
        <div className="min-h-screen flex flex-col md:flex-row p-2 gap-2">
            <NewItemDropModal
                newItem={newItemDrop}
                currentItem={newItemDrop ? equipment[newItemDrop.type.toLowerCase()] : null}
                onEquip={() => { handlers.onEquipItem(newItemDrop); setNewItemDrop(null); }}
                onStore={() => { setInventory(prev => [...prev, newItemDrop]); setNewItemDrop(null); }}
            />
             {isJobSelectionOpen && <JobSelectionModal onSelect={handleJobSelect} onClose={() => { if(playerClass) setIsJobSelectionOpen(false) }} />}
             {selectedInventoryItem && (
                 <InventoryItemDetailModal 
                    item={selectedInventoryItem}
                    currentEquipped={equipment[selectedInventoryItem.type.toLowerCase()]}
                    onEquip={handlers.onEquipItem}
                    onSell={handlers.onSellItem}
                    onToggleLock={handlers.onToggleLock}
                    onSelectForge={(item) => { setActiveTab('forge'); setSelectedForgeItem(item); }}
                    onClose={() => setSelectedInventoryItem(null)}
                />
            )}
            {isDifficultyModalOpen && <DifficultyChangeModal currentDifficulty={difficulty} onSelect={handleChangeDifficulty} onClose={() => setIsDifficultyModalOpen(false)} />}
            {isElementModalOpen && <ElementSelectionModal currentElement={playerElement} onSelect={handleSelectElement} onClose={() => setIsElementModalOpen(false)} />}
            {offlineProgress && <OfflineProgressModal progress={offlineProgress} onClaim={() => {
                setPlayerStats(prev => ({...prev, coins: prev.coins + offlineProgress.gold, xp: prev.xp + offlineProgress.xp}));
                setOfflineProgress(null);
            }}/>}
            
            <div className="w-full md:w-1/4 space-y-2 order-1">
                <PlayerStats
                    stats={finalStats}
                    playerClass={playerClass}
                    onNameChange={(name) => setPlayerStats(prev => ({ ...prev, playerName: name }))}
                    abilityStats={finalAbilityStats}
                    liberationCount={liberationCount}
                    rebirthCount={rebirthCount}
                    onJobChangeClick={() => setIsJobSelectionOpen(true)}
                    difficulty={difficulty}
                    onDifficultyChangeClick={() => setIsDifficultyModalOpen(true)}
                    isAutoDropEnabled={isAutoDropEnabled}
                    onToggleAutoDrop={() => setIsAutoDropEnabled(prev => !prev)}
                    onReset={() => {
                        if (confirm("ì •ë§ë¡œ ê²Œì„ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ëª¨ë“  ì§„í–‰ ìƒí™©ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤.")) {
                            localStorage.removeItem(SAVED_GAME_KEY);
                            window.location.reload();
                        }
                    }}
                />
                <EquipmentPanel equipment={equipment} onSelectItem={handlers.onSelectItem} />
            </div>

            <div className="w-full md:w-1/2 flex flex-col justify-between items-center order-2">
                <MonsterDisplay monster={monsterStats} onClick={handleMonsterClick} damagePopups={damagePopups} treasureGolem={treasureGolem}>
                    {playerClass && (
                        <div className="w-full max-w-lg mt-4 grid grid-cols-3 gap-2">
                            <ActiveSkillButton skill={JOBS[playerClass].skill} onClick={handleUseSkill1} cooldown={activeSkillCooldown} maxCooldown={finalAbilityStats.activeSkillCooldown} />
                            <ActiveSkillButton skill={JOBS[playerClass].skill2} onClick={handleUseSkill2} cooldown={secondSkillCooldown} maxCooldown={JOBS[playerClass].skill2.cooldown * (1 - finalAbilityStats.haste / 100)} />
                            <ActiveSkillButton skill={JOBS[playerClass].skill3} onClick={handleUseSkill3} cooldown={thirdSkillCooldown} maxCooldown={JOBS[playerClass].skill3.cooldown * (1 - finalAbilityStats.haste / 100)} />
                        </div>
                    )}
                </MonsterDisplay>
                <div className="w-full max-w-lg mt-4 grid grid-cols-2 gap-2">
                    <ElementPanel playerElement={playerElement} onOpenModal={() => setIsElementModalOpen(true)} />
                    <EquippedArtifactsPanel equipped={equippedArtifacts} onSlotClick={() => setActiveTab('artifacts')} />
                </div>
                <div className="w-full max-w-lg mt-4">
                     <GameLog log={gameLog} />
                </div>
            </div>

            <RightPanel
                activeTab={activeTab}
                setActiveTab={setActiveTab}
                upgrades={upgrades}
                playerCoins={playerStats.coins}
                handlers={handlers}
                abilityStats={finalAbilityStats}
                equipmentGachaCost={equipmentGachaCost}
                inventory={inventory}
                isSellMode={isSellMode}
                onToggleSellMode={() => setIsSellMode(prev => !prev)}
                sellList={sellList}
                selectedForgeItem={selectedForgeItem}
                missions={missions}
                ownedArtifacts={ownedArtifacts}
                equippedArtifacts={equippedArtifacts}
                playerLevel={playerStats.level}
                liberationCost={liberationCost}
                liberationCount={liberationCount}
                rebirthCount={rebirthCount}
            />
        </div>
    );
};

// Initial render
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

    </script>
  </body>
</html>
