
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>슬라임 헌터 (Slime Hunter)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/"
  }
}
</script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @keyframes damage-popup {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }
        .animate-damage-popup {
            animation: damage-popup 1s ease-out forwards;
        }
        @keyframes damage-popup-skill {
            0% { transform: translateY(0) scale(1.2); opacity: 1; }
            100% { transform: translateY(-80px) scale(2.2); opacity: 0; }
        }
        .animate-damage-popup-skill {
            animation: damage-popup-skill 1s ease-out forwards;
        }
    </style>
  </head>
  <body class="bg-gray-900 text-white antialiased">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useCallback, useRef } from 'react';
      import ReactDOM from 'react-dom/client';

      // --- TYPES (from types.ts) ---
      /*
        Interfaces are used for code clarity and will be stripped by Babel during transpilation.
      */
      interface Player {
        level: number;
        xp: number;
        xpToNextLevel: number;
        gold: number;
        baseAttack: number;
        dps: number;
      }

      interface Monster {
        id: number;
        name: string;
        hp: number;
        maxHp: number;
        goldReward: number;
        xpReward: number;
        level: number;
        color: string;
        special?: 'HEAL';
      }

      interface Upgrade {
        id: string;
        name: string;
        description: (level: number, cost: number, benefit: number) => string;
        level: number;
        cost: (level: number) => number;
        benefit: (level: number) => number;
      }

      interface DamageNumber {
        id: number;
        amount: number | string;
        x: number;
        y: number;
        type: 'click' | 'dps' | 'heal' | 'skill';
      }
      
      // --- ICONS (from components/icons/*.tsx) ---

      const LevelIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}>
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 10l7-7m0 0l7 7m-7-7v18" />
        </svg>
      );

      const XPIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}>
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 11l7-7 7 7M5 19l7-7 7 7" />
        </svg>
      );

      const CoinIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}>
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8v1m0 6v1m0-1c-1.11 0-2.08-.402-2.599-1M12 18c1.11 0 2.08-.402-2.599-1M8.999 12H8m8 0h-.001M12 21a9 9 0 110-18 9 9 0 010 18z" />
        </svg>
      );

      const SwordIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}>
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
        </svg>
      );
      
      const SlimeIcon = (props) => (
          <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" {...props}>
              <defs>
                  <radialGradient id="slimeGradient" cx="50%" cy="50%" r="50%" fx="30%" fy="30%">
                  <stop offset="0%" style={{stopColor: 'rgba(255,255,255,0.5)'}} />
                  <stop offset="100%" style={{stopColor: 'rgba(255,255,255,0)'}} />
                  </radialGradient>
              </defs>
              <path d="M 10,60 C 10,30 30,10 50,10 C 70,10 90,30 90,60 C 90,80 80,90 50,90 C 20,90 10,80 10,60 Z" fill="currentColor" />
              <circle cx="50" cy="50" r="40" fill="url(#slimeGradient)" />
              <circle cx="35" cy="45" r="5" fill="white" />
              <circle cx="65" cy="45" r="5" fill="white" />
              <circle cx="36" cy="46" r="2" fill="black" />
              <circle cx="66" cy="46" r="2" fill="black" />
          </svg>
      );

      // --- CONSTANTS (from constants.ts) ---

      const INITIAL_PLAYER = {
        level: 1,
        xp: 0,
        xpToNextLevel: 10,
        gold: 0,
        baseAttack: 1,
        dps: 0,
      };

      const MONSTER_TEMPLATES = [
        { name: '초록 슬라임', baseHp: 8, baseGold: 2, baseXp: 5, color: 'text-green-400', minLevel: 1 },
        { name: '파랑 슬라임', baseHp: 12, baseGold: 3, baseXp: 7, color: 'text-blue-400', minLevel: 2 },
        { name: '고블린', baseHp: 20, baseGold: 5, baseXp: 10, color: 'text-emerald-500', minLevel: 4 },
        { name: '버섯 엔트', baseHp: 35, baseGold: 6, baseXp: 12, color: 'text-orange-400', minLevel: 6, special: 'HEAL' },
        { name: '그림자 임프', baseHp: 15, baseGold: 15, baseXp: 8, color: 'text-purple-500', minLevel: 8 },
        { name: '스켈레톤 전사', baseHp: 50, baseGold: 10, baseXp: 20, color: 'text-gray-300', minLevel: 10 },
        { name: '돌 골렘', baseHp: 80, baseGold: 15, baseXp: 30, color: 'text-slate-500', minLevel: 12 },
      ];

      const BOSS_TEMPLATE = {
        name: '거대 슬라임 왕', baseHp: 100, baseGold: 50, baseXp: 100, color: 'text-yellow-400', minLevel: 5
      };

      const MONSTER_GENERATOR = (level) => {
        if (level >= BOSS_TEMPLATE.minLevel && Math.random() < 0.05) {
            const template = BOSS_TEMPLATE;
            const hp = Math.floor(template.baseHp * Math.pow(1.3, level - template.minLevel));
            const goldReward = Math.floor(template.baseGold * Math.pow(1.2, level - template.minLevel));
            const xpReward = Math.floor(template.baseXp * Math.pow(1.2, level - template.minLevel));
            return {
              id: Date.now() + Math.random(),
              name: `${template.name} (Lv.${level})`, hp, maxHp: hp, goldReward, xpReward, level,
              color: template.color, special: template.special,
            };
        }
        
        const availableMonsters = MONSTER_TEMPLATES.filter(m => level >= m.minLevel);
        const template = availableMonsters[Math.floor(Math.random() * availableMonsters.length)] || MONSTER_TEMPLATES[0];

        const hp = Math.floor(template.baseHp * Math.pow(1.25, level - 1));
        const goldReward = Math.floor(template.baseGold * Math.pow(1.15, level - 1));
        const xpReward = Math.floor(template.baseXp * Math.pow(1.12, level - 1));
        
        return {
          id: Date.now() + Math.random(),
          name: `${template.name} (Lv.${level})`, hp, maxHp: hp, goldReward, xpReward, level,
          color: template.color, special: template.special,
        };
      };

      const UPGRADES_CONFIG = [
        {
          id: 'CLICK_UPGRADE', name: '검 강화', level: 1,
          description: (level, cost, benefit) => `클릭 공격력을 +${benefit} 만큼 영구적으로 증가시킵니다.`,
          cost: (level) => Math.floor(10 * Math.pow(1.2, level-1)),
          benefit: (level) => Math.floor(1 * Math.pow(1.1, level-1)),
        },
        {
          id: 'DPS_UPGRADE', name: '자동 공격 용병 고용', level: 0,
          description: (level, cost, benefit) => `초당 ${benefit}의 자동 공격을 추가합니다.`,
          cost: (level) => Math.floor(25 * Math.pow(1.5, level)),
          benefit: (level) => Math.floor(1 * Math.pow(1.3, level)),
        },
        {
          id: 'POWER_SHOT_UPGRADE', name: '파워 샷 강화', level: 0,
          description: (level) => `파워 샷의 골드 소모량을 5% 감소시킵니다. (현재: -${Math.min(95, level * 5)}%)`,
          cost: (level) => Math.floor(150 * Math.pow(1.8, level)),
          benefit: () => 0.05,
        },
      ];
      
      // --- COMPONENTS (from components/*.tsx) ---

      const StatBar = ({ value, maxValue, color, icon, label }) => {
        const percentage = Math.min((value / maxValue) * 100, 100);
        return (
          <div>
            <div className="flex justify-between items-center text-sm mb-1 text-gray-300">
              <div className="flex items-center gap-2">
                {icon}
                <span>{label}</span>
              </div>
              <span>{value} / {maxValue}</span>
            </div>
            <div className="w-full bg-gray-700 rounded-full h-2.5">
              <div className={`${color} h-2.5 rounded-full`} style={{ width: `${percentage}%`, transition: 'width 0.3s ease-in-out' }}></div>
            </div>
          </div>
        );
      };

      const PlayerStats = ({ player }) => {
        return (
          <div className="flex flex-col gap-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700">
              <h2 className="text-xl font-bold text-center text-yellow-300">플레이어 정보</h2>
              <div className="flex justify-around text-center">
                  <div className="flex flex-col items-center">
                      <LevelIcon className="w-8 h-8 text-green-400 mb-1" />
                      <span className="text-sm text-gray-400">레벨</span>
                      <span className="text-lg font-bold">{player.level}</span>
                  </div>
                  <div className="flex flex-col items-center">
                      <CoinIcon className="w-8 h-8 text-yellow-400 mb-1" />
                      <span className="text-sm text-gray-400">골드</span>
                      <span className="text-lg font-bold">{player.gold}</span>
                  </div>
              </div>
              <StatBar 
                  value={player.xp}
                  maxValue={player.xpToNextLevel}
                  color="bg-blue-500"
                  icon={<XPIcon className="w-4 h-4" />}
                  label="경험치"
              />
              <div className="flex justify-around text-center mt-2 border-t border-gray-700 pt-4">
                  <div className="flex flex-col items-center">
                      <SwordIcon className="w-8 h-8 text-red-400 mb-1" />
                      <span className="text-sm text-gray-400">클릭 공격력</span>
                      <span className="text-lg font-bold">{player.baseAttack}</span>
                  </div>
                  <div className="flex flex-col items-center">
                      <SwordIcon className="w-8 h-8 text-purple-400 mb-1" />
                      <span className="text-sm text-gray-400">초당 공격력</span>
                      <span className="text-lg font-bold">{player.dps}</span>
                  </div>
              </div>
          </div>
        );
      };
      
      const MonsterDisplay = ({ monster, onAttack, damageNumbers }) => {
        const [isHit, setIsHit] = useState(false);
        const hpPercentage = (monster.hp / monster.maxHp) * 100;

        useEffect(() => {
          if (damageNumbers.length > 0) {
            setIsHit(true);
            const timer = setTimeout(() => setIsHit(false), 100);
            return () => clearTimeout(timer);
          }
        }, [damageNumbers]);
        
        return (
          <div className="relative w-64 h-64 flex flex-col items-center justify-center cursor-pointer group" onClick={onAttack}>
              <div className="absolute inset-0 flex flex-col items-center justify-center">
                  <div className="mb-2 text-center">
                      <h3 className="text-lg font-bold text-gray-200">{monster.name}</h3>
                      <p className="text-sm text-red-400 font-semibold">{monster.hp} / {monster.maxHp}</p>
                  </div>
                  <div className={`relative w-40 h-40 transition-transform duration-100 ${isHit ? 'transform scale-95' : 'group-hover:scale-110'}`}>
                      <SlimeIcon className={`w-full h-full ${monster.color} ${isHit ? 'animate-pulse' : ''}`}/>
                  </div>
                  <div className="w-48 bg-gray-700 rounded-full h-4 mt-4 border-2 border-gray-600">
                      <div className="bg-red-500 h-full rounded-full transition-all duration-200 ease-linear" style={{ width: `${hpPercentage}%` }}></div>
                  </div>
              </div>

              {damageNumbers.map(dn => {
                  let colorClass = '';
                  let animationClass = 'animate-damage-popup';
                  let style = {};

                  switch(dn.type) {
                      case 'click': colorClass = 'text-yellow-300 text-2xl'; break;
                      case 'dps': colorClass = 'text-purple-400 text-xl'; break;
                      case 'heal': colorClass = 'text-green-400 text-xl'; break;
                      case 'skill': 
                          colorClass = 'text-cyan-400 text-4xl'; 
                          animationClass = 'animate-damage-popup-skill';
                          style = { textShadow: '0 0 8px rgba(0, 255, 255, 0.9)' };
                          break;
                  }

                  return (
                    <div 
                        key={dn.id}
                        className={`absolute font-bold pointer-events-none ${animationClass} ${colorClass}`}
                        style={{ 
                            left: `${dn.x}%`, 
                            top: `${dn.y}%`,
                            textShadow: '0px 0px 5px rgba(0,0,0,0.8)',
                            ...style
                        }}
                    >
                        {dn.amount}
                    </div>
                  );
              })}
          </div>
        );
      };
      
      const UpgradePanel = ({ upgrades, onUpgrade, playerGold }) => {
        return (
          <div className="flex flex-col gap-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700">
            <h2 className="text-xl font-bold text-center text-yellow-300">업그레이드</h2>
            <div className="flex flex-col gap-3">
              {upgrades.map(upgrade => {
                const cost = upgrade.cost(upgrade.level);
                const benefit = upgrade.benefit(upgrade.level);
                const canAfford = playerGold >= cost;

                return (
                  <div key={upgrade.id} className="bg-gray-800 p-4 rounded-lg border border-gray-600">
                      <div className="flex justify-between items-center">
                          <h3 className="text-lg font-semibold text-green-400">{upgrade.name}</h3>
                          <span className="text-sm text-gray-400">레벨 {upgrade.level}</span>
                      </div>
                    <p className="text-sm text-gray-300 my-2">{upgrade.description(upgrade.level, cost, benefit)}</p>
                    <button
                      onClick={() => onUpgrade(upgrade.id)}
                      disabled={!canAfford}
                      className={`w-full font-bold py-2 px-4 rounded-lg transition-colors duration-200 flex items-center justify-center gap-2 ${
                        canAfford
                          ? 'bg-yellow-500 hover:bg-yellow-600 text-gray-900'
                          : 'bg-gray-600 text-gray-400 cursor-not-allowed'
                      }`}
                    >
                      <CoinIcon className="w-5 h-5" />
                      <span>{cost}</span>
                    </button>
                  </div>
                );
              })}
            </div>
          </div>
        );
      };
      
      const GameLog = ({ log }) => {
        return (
          <div className="flex-grow flex flex-col p-4 bg-gray-900/50 rounded-lg border border-gray-700">
            <h2 className="text-xl font-bold text-center text-yellow-300 mb-2">게임 로그</h2>
            <div className="flex-grow bg-gray-900 p-2 rounded-md overflow-y-auto h-32">
              {log.map((message, index) => (
                <p
                  key={index}
                  className={`text-sm ${index === 0 ? 'text-yellow-200' : 'text-gray-400'}`}
                >
                  {`> ${message}`}
                </p>
              ))}
            </div>
          </div>
        );
      };

      // --- MAIN APP (from App.tsx) ---
      
      const PowerShotIcon = (props) => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}>
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
          </svg>
      );

      const CoinIconForSkill = (props) => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}>
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8v1m0 6v1m0-1c-1.11 0-2.08-.402-2.599-1M12 18c1.11 0 2.08-.402-2.599-1M8.999 12H8m8 0h-.001M12 21a9 9 0 110-18 9 9 0 010 18z" />
          </svg>
      );

      const SkillsPanel = ({ player, onPowerShot, cooldown, powerShotCost }) => {
          const canAfford = player.gold >= powerShotCost;
          const isDisabled = cooldown > 0 || !canAfford;

          return (
              <div className="w-full max-w-xs mt-4">
                  <button
                      onClick={onPowerShot}
                      disabled={isDisabled}
                      className={`w-full font-bold py-3 px-4 rounded-lg transition-colors duration-200 flex items-center justify-center gap-2 relative overflow-hidden shadow-lg border border-gray-600 ${
                          isDisabled
                              ? 'bg-gray-700 text-gray-500 cursor-not-allowed'
                              : 'bg-cyan-500 hover:bg-cyan-600 text-white'
                      }`}
                  >
                      {cooldown > 0 && (
                          <div className="absolute top-0 left-0 h-full bg-black/50" style={{ width: `${(cooldown / 15) * 100}%`}}></div>
                      )}
                      <PowerShotIcon className="w-6 h-6 z-10" />
                      <div className="flex flex-col items-center z-10">
                          <span className="text-md leading-tight">
                              {cooldown > 0 ? `재사용 대기중 (${cooldown}s)` : '파워 샷'}
                          </span>
                          <div className="flex items-center gap-1 text-xs text-yellow-200">
                              <CoinIconForSkill />
                              <span>{powerShotCost}</span>
                          </div>
                      </div>
                  </button>
              </div>
          );
      };


      const App = () => {
        const [player, setPlayer] = useState(INITIAL_PLAYER);
        const [monster, setMonster] = useState(() => MONSTER_GENERATOR(1));
        const [upgrades, setUpgrades] = useState(UPGRADES_CONFIG);
        const [gameLog, setGameLog] = useState(['게임 시작! 첫 슬라임을 공격하세요.']);
        const [damageNumbers, setDamageNumbers] = useState([]);
        const [powerShotCooldown, setPowerShotCooldown] = useState(0);
        const prevMonsterRef = useRef();

        const addLog = (message) => {
          setGameLog(prev => [message, ...prev.slice(0, 4)]);
        };

        const spawnFloatingNumber = (amount, type) => {
          const newFloatingNumber = {
            id: Date.now() + Math.random(),
            amount,
            x: 50 + Math.random() * 20 - 10,
            y: 50 + Math.random() * 20 - 10,
            type
          };
          setDamageNumbers(prev => [...prev, newFloatingNumber]);
          setTimeout(() => {
            setDamageNumbers(prev => prev.filter(dn => dn.id !== newFloatingNumber.id));
          }, 1000);
        };
        
        const dealDamage = useCallback((damage, type) => {
          if (monster.hp <= 0) return;

          let newHp = Math.max(0, monster.hp - damage);

          if (newHp > 0 && monster.special === 'HEAL' && Math.random() < 0.15) { 
              const healAmount = Math.max(1, Math.floor(monster.maxHp * 0.05));
              newHp = Math.min(monster.maxHp, newHp + healAmount);
              addLog(`${monster.name}이(가) 스스로를 치유했습니다! (+${healAmount} HP)`);
              spawnFloatingNumber(`+${healAmount}`, 'heal');
          }
          
          setMonster(prevMonster => ({ ...prevMonster, hp: newHp }));
          spawnFloatingNumber(damage, type);
        }, [monster.hp, monster.maxHp, monster.name, monster.special]);

        useEffect(() => {
          if (prevMonsterRef.current && prevMonsterRef.current.hp > 0 && monster.hp === 0) {
            addLog(`${monster.name}을(를) 물리쳤습니다!`);
            addLog(`+${monster.goldReward} 골드, +${monster.xpReward} 경험치`);

            let newXp = player.xp + monster.xpReward;
            let newLevel = player.level;
            let newXpToNextLevel = player.xpToNextLevel;
            let newBaseAttack = player.baseAttack;

            while (newXp >= newXpToNextLevel) {
              newXp -= newXpToNextLevel;
              newLevel++;
              newXpToNextLevel = Math.floor(newXpToNextLevel * 1.5);
              newBaseAttack = Math.floor(newBaseAttack * 1.2);
              addLog(`레벨 업! ${newLevel}레벨이 되었습니다!`);
            }

            const nextPlayerState = {
              ...player,
              level: newLevel,
              xp: newXp,
              xpToNextLevel: newXpToNextLevel,
              gold: player.gold + monster.goldReward,
              baseAttack: newBaseAttack,
            };

            setPlayer(nextPlayerState);
            setMonster(MONSTER_GENERATOR(nextPlayerState.level));
          }
          prevMonsterRef.current = monster;
        }, [monster, player]);

        const handleAttack = () => {
          dealDamage(player.baseAttack, 'click');
        };

        const powerShotUpgrade = upgrades.find(u => u.id === 'POWER_SHOT_UPGRADE') || { level: 0 };
        const powerShotCostReduction = Math.min(0.95, powerShotUpgrade.level * 0.05);
        const basePowerShotCost = 50 + player.level * 10;
        const powerShotCost = Math.floor(basePowerShotCost * (1 - powerShotCostReduction));
        const powerShotDamage = Math.floor(player.baseAttack * 5 + player.dps * 2 + player.level * 3);
        
        const handlePowerShot = () => {
          if (powerShotCooldown > 0 || player.gold < powerShotCost) return;

          setPlayer(prev => ({...prev, gold: prev.gold - powerShotCost}));
          dealDamage(powerShotDamage, 'skill');
          setPowerShotCooldown(15);
          addLog(`파워 샷! ${powerShotDamage}의 피해를 입혔습니다! (-${powerShotCost} 골드)`);
        };

        const handleUpgrade = (upgradeId) => {
          const upgradeIndex = upgrades.findIndex(u => u.id === upgradeId);
          if (upgradeIndex === -1) return;

          const upgradeToBuy = upgrades[upgradeIndex];
          const cost = upgradeToBuy.cost(upgradeToBuy.level);

          if (player.gold >= cost) {
            setPlayer(prevPlayer => ({
              ...prevPlayer,
              gold: prevPlayer.gold - cost,
              baseAttack: upgradeId === 'CLICK_UPGRADE' ? prevPlayer.baseAttack + upgradeToBuy.benefit(upgradeToBuy.level) : prevPlayer.baseAttack,
              dps: upgradeId === 'DPS_UPGRADE' ? prevPlayer.dps + upgradeToBuy.benefit(upgradeToBuy.level) : prevPlayer.dps,
            }));

            setUpgrades(prevUpgrades => {
              const newUpgrades = [...prevUpgrades];
              const targetUpgrade = newUpgrades[upgradeIndex];
              targetUpgrade.level = (targetUpgrade.level || 0) + 1; // Ensure level is a number and increment
              return newUpgrades;
            });
            
            addLog(`${upgradeToBuy.name} 강화! (레벨 ${upgrades[upgradeIndex].level + 1})`);
          }
        };
        
        useEffect(() => {
          if (player.dps > 0) {
            const interval = setInterval(() => {
              dealDamage(player.dps, 'dps');
            }, 1000);
            return () => clearInterval(interval);
          }
        }, [player.dps, dealDamage]);

        useEffect(() => {
          if (powerShotCooldown > 0) {
            const timer = setInterval(() => {
              setPowerShotCooldown(prev => Math.max(0, prev - 1));
            }, 1000);
            return () => clearInterval(timer);
          }
        }, [powerShotCooldown]);

        return (
          <div className="min-h-screen bg-gradient-to-b from-gray-800 to-gray-900 flex flex-col items-center justify-center p-4 font-sans select-none">
            <div className="w-full max-w-4xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-8">
              <div className="lg:col-span-1 bg-gray-800/50 p-6 rounded-2xl shadow-lg border border-gray-700 flex flex-col gap-6 order-2 lg:order-1">
                <PlayerStats player={player} />
                <GameLog log={gameLog} />
              </div>
              <div className="lg:col-span-1 flex flex-col items-center justify-center order-1 lg:order-2">
                 <h1 className="text-4xl font-bold text-yellow-400 mb-4 tracking-wider" style={{textShadow: '0 0 10px rgba(250, 204, 21, 0.7)'}}>슬라임 헌터</h1>
                <MonsterDisplay 
                  monster={monster} 
                  onAttack={handleAttack} 
                  damageNumbers={damageNumbers}
                />
                <SkillsPanel 
                  player={player}
                  onPowerShot={handlePowerShot}
                  cooldown={powerShotCooldown}
                  powerShotCost={powerShotCost}
                />
              </div>
              <div className="lg:col-span-1 bg-gray-800/50 p-6 rounded-2xl shadow-lg border border-gray-700 order-3 lg:order-3">
                <UpgradePanel 
                  upgrades={upgrades} 
                  onUpgrade={handleUpgrade} 
                  playerGold={player.gold}
                />
              </div>
            </div>
             <footer className="text-center text-gray-500 mt-8">
                <p>&copy; 2024 Slime Hunter. A simple RPG.</p>
            </footer>
          </div>
        );
      };

      // --- RENDER APP (from index.tsx) ---

      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>