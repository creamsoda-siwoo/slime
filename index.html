<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>슬라임 헌터 (Slime Hunter)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes damage-popup {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }
        .animate-damage-popup {
            animation: damage-popup 1s ease-out forwards;
        }
        @keyframes damage-popup-skill {
            0% { transform: translateY(0) scale(1.2); opacity: 1; }
            100% { transform: translateY(-80px) scale(2.2); opacity: 0; }
        }
        .animate-damage-popup-skill {
            animation: damage-popup-skill 1s ease-out forwards;
        }
        @keyframes damage-popup-crit {
            0% { transform: translateY(0) scale(1.5) rotate(-5deg); opacity: 1; text-shadow: 0 0 10px #fff, 0 0 20px #fff; }
            100% { transform: translateY(-100px) scale(2.8) rotate(10deg); opacity: 0; }
        }
        .animate-damage-popup-crit {
            animation: damage-popup-crit 1s ease-out forwards;
        }


        @keyframes screen-shake {
            0% { transform: translate(0, 0) rotate(0); }
            25% { transform: translate(0.5px, -0.5px) rotate(-0.1deg); }
            50% { transform: translate(-0.5px, 0.5px) rotate(0.1deg); }
            75% { transform: translate(0.5px, 0.5px) rotate(-0.1deg); }
            100% { transform: translate(0, 0) rotate(0); }
        }
        .animate-screen-shake {
            animation: screen-shake 0.1s linear;
        }

        /* Rarity Colors */
        .text-rarity-COMMON { color: #ffffff; }
        .text-rarity-UNCOMMON { color: #1eff00; }
        .text-rarity-RARE { color: #0070dd; }
        .text-rarity-EPIC { color: #a335ee; }
        .text-rarity-LEGENDARY { color: #ff8000; }
        .text-rarity-MYTHIC { color: #2dd4bf; text-shadow: 0 0 8px #2dd4bf; }


        .border-rarity-COMMON { border-color: #6b7280; }
        .border-rarity-UNCOMMON { border-color: #16a34a; }
        .border-rarity-RARE { border-color: #2563eb; }
        .border-rarity-EPIC { border-color: #9333ea; }
        .border-rarity-LEGENDARY { border-color: #d97706; }
        .border-rarity-MYTHIC { border-color: #14b8a6; box-shadow: 0 0 10px #2dd4bf; }

        .crit-icon { color: #facc15; }

        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 240px;
            background-color: #1f2937;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 50;
            bottom: 125%;
            left: 50%;
            margin-left: -120px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #4b5563;
            pointer-events: none;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        @keyframes slime-pop {
            0% { transform: translateY(80%) scale(0.8); }
            70% { transform: translateY(-10%) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }
        .animate-slime-pop {
            animation: slime-pop 0.3s ease-out;
        }
    </style>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel for JSX and TypeScript transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
  <body class="bg-gray-900 text-white antialiased">
    <div id="root"></div>
    <script type="text/babel" data-presets="react,typescript">
// Use global React and ReactDOM loaded from CDN, and destructure hooks for convenience.
const { useState, useEffect, useCallback, useRef, useMemo } = React;

// --- CONFIG ---
const LEVEL_EXPERIENCE_BASE = 20;
const LEVEL_EXPERIENCE_MULTIPLIER = 1.15;
const MONSTER_HP_BASE = 20;
const MONSTER_HP_MULTIPLIER = 1.16;
const MONSTER_REWARD_BASE = 5;
const MONSTER_REWARD_MULTIPLIER = 1.1;
const BOSS_LEVEL_INTERVAL = 10;
const BOSS_HP_MULTIPLIER = 4.0;
const BOSS_REWARD_MULTIPLIER = 3;
const BOSS_DROP_CHANCE_BOOST = 0.2;
const UPGRADE_COST_LEVEL_FACTOR = 0.02;

const CLICK_UPGRADE_COST_BASE = 4;
const CLICK_UPGRADE_COST_MULTIPLIER = 1.12;
const AUTO_ATTACK_UPGRADE_COST_BASE = 10;
const AUTO_ATTACK_UPGRADE_COST_MULTIPLIER = 1.18;
const CRIT_CHANCE_UPGRADE_COST_BASE = 30;
const CRIT_CHANCE_UPGRADE_COST_MULTIPLIER = 1.32;
const CRIT_CHANCE_UPGRADE_INCREASE = 1;
const CRIT_DAMAGE_UPGRADE_COST_BASE = 50;
const CRIT_DAMAGE_UPGRADE_COST_MULTIPLIER = 1.30;
const CRIT_DAMAGE_UPGRADE_INCREASE = 5;

const GOLD_GAIN_UPGRADE_COST_BASE = 50;
const GOLD_GAIN_UPGRADE_COST_MULTIPLIER = 1.33;
const XP_GAIN_UPGRADE_COST_BASE = 75;
const XP_GAIN_UPGRADE_COST_MULTIPLIER = 1.42;

const ATTACK_SPEED_UPGRADE_COST_BASE = 100;
const ATTACK_SPEED_UPGRADE_COST_MULTIPLIER = 1.28;
const HASTE_UPGRADE_COST_BASE = 250;
const HASTE_UPGRADE_COST_MULTIPLIER = 1.48;
const LUCK_UPGRADE_COST_BASE = 200;
const LUCK_UPGRADE_COST_MULTIPLIER = 1.36;

const SKILL_DAMAGE_UPGRADE_COST_BASE = 150;
const SKILL_DAMAGE_UPGRADE_COST_MULTIPLIER = 1.45;

const BOSS_DAMAGE_UPGRADE_COST_BASE = 200;
const BOSS_DAMAGE_UPGRADE_COST_MULTIPLIER = 1.41;

const ARTIFACT_POWER_UPGRADE_COST_BASE = 5000;
const ARTIFACT_POWER_UPGRADE_COST_MULTIPLIER = 1.5;

const LIBERATION_COST_BASE = 10000;
const LIBERATION_COST_MULTIPLIER = 100;

const BASE_SKILL_COOLDOWN = 30000; // 30 seconds
const BASE_SKILL_DAMAGE_MULTIPLIER = 5;

const EQUIPMENT_DROP_CHANCE_BASE = 0.15;
const EQUIPMENT_GACHA_COST_BASE = 100;
const EQUIPMENT_GACHA_COST_LEVEL_MULTIPLIER = 20;

const REBIRTH_LEVEL_REQUIREMENT = 30;
const REBIRTH_ALL_STAT_BONUS = 10; // All stats +10%

const TREASURE_GOLEM_SPAWN_CHANCE = 0.02; // 2% chance
const TREASURE_GOLEM_TIMER = 30; // 30 seconds

const SAVED_GAME_KEY = 'slimeHunterSaveData';

// --- DIFFICULTY DATA ---
const DIFFICULTIES = {
    EASY: {
        name: '쉬움',
        description: '느긋하게 즐기는 모험. 몬스터가 약하고 성장이 빠릅니다.',
        multipliers: { monsterHp: 0.75, monsterReward: 1.25, upgradeCost: 0.8 }
    },
    NORMAL: {
        name: '보통',
        description: '균형 잡힌 도전. 표준적인 게임 플레이를 경험하세요.',
        multipliers: { monsterHp: 1.0, monsterReward: 1.0, upgradeCost: 1.0 }
    },
    HARD: {
        name: '어려움',
        description: '진정한 헌터를 위한 시련. 몬스터가 강력하지만, 보상이 더 큽니다.',
        multipliers: { monsterHp: 1.5, monsterReward: 1.2, upgradeCost: 1.2 }
    }
};

// --- JOB DATA ---
const JOBS = {
    WARRIOR: {
        name: '전사',
        description: '강력한 클릭 공격과 지속적인 전투에 특화되었습니다.',
        passive: '클릭 데미지 +25%, 자동 공격 데미지 +10%',
        skill: { name: '광란', description: '8초간 클릭 데미지 +100%, 자동 공격 데미지 +50% 증가' },
        bonuses: { clickDamage: 0.25, autoAttackDamage: 0.10, critChance: 0, critDamage: 0, skillEffect: 0 },
        icon: (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" /></svg>
    },
    ARCHER: {
        name: '궁수',
        description: '치명타를 활용하여 폭발적인 데미지를 입힙니다.',
        passive: '크리티컬 확률 +10%p, 크리티컬 데미지 +50%p',
        skill: { name: '화살비', description: '즉시 클릭 데미지의 3배 피해를 주고, 5초간 크리티컬 확률이 25%p 증가합니다.' },
        bonuses: { clickDamage: 0, autoAttackDamage: 0, critChance: 10, critDamage: 50, skillEffect: 0 },
        icon: (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z" /></svg>
    },
    MAGE: {
        name: '마법사',
        description: '강력한 스킬로 전장을 지배합니다.',
        passive: '스킬 데미지 +50%, 스킬 쿨타임 감소 효과 +25%',
        skill: { name: '신비한 폭발', description: '총 공격력의 15배 피해를 주고, 10초간 몬스터가 받는 모든 피해가 20% 증가합니다.' },
        bonuses: { clickDamage: 0, autoAttackDamage: 0, critChance: 0, critDamage: 0, skillEffect: 0.5 },
        icon: (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M15.362 5.214A8.252 8.252 0 0112 21 8.25 8.25 0 016.038 7.048 8.287 8.287 0 009 9.6a8.983 8.983 0 013.362-3.797z" /></svg>
    }
};

const MISSION_TYPES = {
    DEFEAT_MONSTERS: '몬스터 처치',
    DEFEAT_BOSSES: '보스 처치',
    UPGRADE_TIMES: '강화 시도',
    EARN_GOLD: '골드 획득',
};

// --- EQUIPMENT DATA ---
const EQUIPMENT_TYPES = {
    WEAPON: { name: '무기', icon: (props) => <SwordIcon {...props}/> },
    ARMOR: { name: '방어구', icon: (props) => <ArmorIcon {...props}/> },
    AMULET: { name: '장신구', icon: (props) => <AmuletIcon {...props}/> },
    HELMET: { name: '투구', icon: (props) => <HelmetIcon {...props}/> },
    GLOVES: { name: '장갑', icon: (props) => <GlovesIcon {...props}/> },
    BOOTS: { name: '신발', icon: (props) => <BootsIcon {...props}/> }
};

const RARITY_ORDER = ['COMMON', 'UNCOMMON', 'RARE', 'EPIC', 'LEGENDARY', 'MYTHIC'];
const RARITIES = {
    COMMON: { name: '일반', textClass: 'text-rarity-COMMON', borderClass: 'border-rarity-COMMON', statMultiplier: 1 },
    UNCOMMON: { name: '고급', textClass: 'text-rarity-UNCOMMON', borderClass: 'border-rarity-UNCOMMON', statMultiplier: 1.6 },
    RARE: { name: '희귀', textClass: 'text-rarity-RARE', borderClass: 'border-rarity-RARE', statMultiplier: 2.8 },
    EPIC: { name: '영웅', textClass: 'text-rarity-EPIC', borderClass: 'border-rarity-EPIC', statMultiplier: 5 },
    LEGENDARY: { name: '전설', textClass: 'text-rarity-LEGENDARY', borderClass: 'border-rarity-LEGENDARY', statMultiplier: 8 },
    MYTHIC: { name: '신화', textClass: 'text-rarity-MYTHIC', borderClass: 'border-rarity-MYTHIC', statMultiplier: 15 }
};

// --- ICONS ---
const LevelIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 10l7-7m0 0l7 7m-7-7v18" /> </svg> );
const XPIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 11l7-7 7 7M5 19l7-7 7 7" /> </svg> );
const CoinIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8v1m0 6v1m0-1c-1.11 0-2.08-.402-2.599-1M12 18c1.11 0 2.08-.402-2.599-1M8.999 12H8m8 0h-.001M12 21a9 9 0 110-18 9 9 0 010 18z" /> </svg> );
const SwordIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" /> </svg> );
const DpsIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /> </svg> );
const CritIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block crit-icon" fill="currentColor" viewBox="0 0 24 24" {...props}> <path d="M12 .587l3.668 7.568 8.332 1.151-6.064 5.828 1.48 8.279-7.416-3.967-7.417 3.967 1.481-8.279-6.064-5.828 8.332-1.151z" /> </svg> );
const ArmorIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" /> </svg> );
const AmuletIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v1m6 11h2m-6.5-1.5l3.5 3.5M4 12H2m13.5 1.5L12 17l-3.5-3.5M12 8a4 4 0 100 8 4 4 0 000-8z" /> </svg> );
const GachaIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" /> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2z" /> </svg> );
const AttackSpeedIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> );
const LuckIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> );
const BossIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 1.052A10.952 10.952 0 003.848 5.766L2 12l1.848 6.234A10.952 10.952 0 0012 22.948a10.952 10.952 0 008.152-4.714L22 12l-1.848-6.234A10.952 10.952 0 0012 1.052z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 14s1.5-2 4-2 4 2 4 2" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 9h.01M15 9h.01" /></svg> );
const HelmetIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg> );
const GlovesIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.618 5.984A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.31-.264-2.55-.724-3.682z" /><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z" /></svg> );
const BootsIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" /></svg> );
const ArtifactIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16.5 6v.75m0 3v.75m0 3v.75m0 3V18m-9-1.5h10.5a2.25 2.25 0 002.25-2.25V6.75a2.25 2.25 0 00-2.25-2.25H7.5A2.25 2.25 0 005.25 6.75v9.75a2.25 2.25 0 002.25 2.25z" /> </svg> );

// Monster Icons
const GreenSlimeIcon = ({className, ...props}) => ( <svg viewBox="0 0 100 80" className={`drop-shadow-lg ${className}`} {...props}> <path d="M 35 25 C 40 20, 50 20, 55 25" fill="rgba(255,255,255,0.5)" stroke="none"></path> <path d="M 50 80 C 10 80, 10 40, 10 40 C 10 10, 40 10, 50 10 C 60 10, 90 10, 90 40 C 90 40, 90 80, 50 80 Z" fill="#22c55e" stroke="#166534" strokeWidth="3"></path> <circle cx="28" cy="50" r="5" fill="#fecaca"></circle> <circle cx="72" cy="50" r="5" fill="#fecaca"></circle> <circle cx="38" cy="45" r="8" fill="white"></circle> <circle cx="62" cy="45" r="8" fill="white"></circle> <circle cx="40" cy="46" r="4" fill="black"></circle> <circle cx="64" cy="46" r="4" fill="black"></circle> <circle cx="37" cy="42" r="2" fill="white"></circle> <circle cx="61" cy="42" r="2" fill="white"></circle> <path d="M 45 60 Q 50 68, 55 60" stroke="black" fill="transparent" strokeWidth="2.5" strokeLinecap="round"></path> </svg> );
const RedSlimeIcon = ({className, ...props}) => ( <svg viewBox="0 0 100 80" className={`drop-shadow-lg ${className}`} {...props}> <path d="M 35 25 C 40 20, 50 20, 55 25" fill="rgba(255,255,255,0.5)" stroke="none"></path> <path d="M 50 80 C 10 80, 10 40, 10 40 C 10 10, 40 10, 50 10 C 60 10, 90 10, 90 40 C 90 40, 90 80, 50 80 Z" fill="#ef4444" stroke="#991b1b" strokeWidth="3"></path> <circle cx="38" cy="45" r="7" fill="white"></circle> <circle cx="62" cy="45" r="7" fill="white"></circle> <circle cx="40" cy="47" r="3" fill="black"></circle> <circle cx="64" cy="47" r="3" fill="black"></circle> <path d="M 45 62 Q 50 55, 55 62" stroke="black" fill="transparent" strokeWidth="2.5" strokeLinecap="round"></path> </svg> );
const BlueSlimeIcon = ({className, ...props}) => ( <svg viewBox="0 0 100 80" className={`drop-shadow-lg ${className}`} {...props}> <path d="M 35 25 C 40 20, 50 20, 55 25" fill="rgba(255,255,255,0.5)" stroke="none"></path> <path d="M 50 80 C 10 80, 10 40, 10 40 C 10 10, 40 10, 50 10 C 60 10, 90 10, 90 40 C 90 40, 90 80, 50 80 Z" fill="#3b82f6" stroke="#1e3a8a" strokeWidth="3"></path> <path d="M 32 40 C 35 45, 41 45, 44 40" stroke="white" fill="transparent" strokeWidth="3" strokeLinecap="round"></path> <path d="M 56 40 C 59 45, 65 45, 68 40" stroke="white" fill="transparent" strokeWidth="3" strokeLinecap="round"></path> <path d="M 45 60 Q 50 65, 55 60" stroke="black" fill="transparent" strokeWidth="2.5" strokeLinecap="round"></path> </svg> );
const GolemIcon = () => ( <svg viewBox="0 0 100 100" className="w-96 h-96 drop-shadow-lg"> <rect x="20" y="40" width="60" height="50" fill="#6b7280" stroke="#4b5563" strokeWidth="3" rx="5"></rect> <rect x="30" y="20" width="40" height="30" fill="#7f8c9b" stroke="#4b5563" strokeWidth="3" rx="5"></rect> <circle cx="45" cy="35" r="4" fill="#dc2626"></circle> <circle cx="55" cy="35" r="4" fill="#dc2626"></circle> <rect x="10" y="50" width="20" height="30" fill="#6b7280" stroke="#4b5563" strokeWidth="3" rx="5"></rect> <rect x="70" y="50" width="20" height="30" fill="#6b7280" stroke="#4b5563" strokeWidth="3" rx="5"></rect> </svg> );
const KingSlimeIcon = () => ( <svg viewBox="0 0 100 80" className="w-96 h-96 drop-shadow-lg"> <path d="M 25 20 L 30 5 L 50 15 L 70 5 L 75 20 Z" fill="#facc15" stroke="#ca8a04" strokeWidth="2" strokeLinejoin="round"></path> <circle cx="30" cy="7" r="3" fill="#ef4444"></circle> <circle cx="50" cy="17" r="3" fill="#3b82f6"></circle> <circle cx="70" cy="7" r="3" fill="#22c55e"></circle> <path d="M 35 35 C 40 30, 50 30, 55 35" fill="rgba(255,255,255,0.5)" stroke="none"></path> <path d="M 50 80 C 10 80, 10 40, 10 40 C 10 20, 40 20, 50 20 C 60 20, 90 20, 90 40 C 90 40, 90 80, 50 80 Z" fill="#22c55e" stroke="#166534" strokeWidth="3"></path> <circle cx="28" cy="55" r="5" fill="#fecaca"></circle> <circle cx="72" cy="55" r="5" fill="#fecaca"></circle> <circle cx="38" cy="50" r="8" fill="white"></circle> <circle cx="62" cy="50" r="8" fill="white"></circle> <circle cx="40" cy="51" r="4" fill="black"></circle> <circle cx="64" cy="51" r="4" fill="black"></circle> <circle cx="37" cy="47" r="2" fill="white"></circle> <circle cx="61" cy="47" r="2" fill="white"></circle> <path d="M 45 65 Q 50 73, 55 65" stroke="black" fill="transparent" strokeWidth="2.5" strokeLinecap="round"></path> </svg> );
const DragonIcon = () => ( <svg viewBox="0 0 100 100" className="w-96 h-96 drop-shadow-lg"> <path d="M 50 10 C 20 40, 20 80, 50 90 C 80 80, 80 40, 50 10" fill="#b91c1c" stroke="#4a0404" strokeWidth="3"></path> <path d="M 40 20 C 30 30, 30 40, 40 50" fill="none" stroke="#fef2f2" strokeWidth="2"></path> <path d="M 60 20 C 70 30, 70 40, 60 50" fill="none" stroke="#fef2f2" strokeWidth="2"></path> <circle cx="45" cy="35" r="5" fill="#fef08a"></circle> <circle cx="55" cy="35" r="5" fill="#fef08a"></circle> <path d="M 45 70 Q 50 80, 55 70" stroke="white" strokeWidth="2" fill="none"></path> <path d="M 20 50 C 10 60, 10 70, 20 80" fill="#991b1b" stroke="#4a0404" strokeWidth="2"></path> <path d="M 80 50 C 90 60, 90 70, 80 80" fill="#991b1b" stroke="#4a0404" strokeWidth="2"></path> </svg> );
const TreasureGolemIcon = () => ( <svg viewBox="0 0 100 100" className="w-96 h-96 drop-shadow-lg"> <rect x="20" y="40" width="60" height="50" fill="#facc15" stroke="#ca8a04" strokeWidth="3" rx="5"></rect> <rect x="30" y="20" width="40" height="30" fill="#fde047" stroke="#ca8a04" strokeWidth="3" rx="5"></rect> <circle cx="45" cy="35" r="4" fill="#3b82f6"></circle> <circle cx="55" cy="35" r="4" fill="#3b82f6"></circle> <rect x="10" y="50" width="20" height="30" fill="#facc15" stroke="#ca8a04" strokeWidth="3" rx="5"></rect> <rect x="70" y="50" width="20" height="30" fill="#facc15" stroke="#ca8a04" strokeWidth="3" rx="5"></rect> <circle cx="50" cy="65" r="8" fill="#22c55e" stroke="#166534" strokeWidth="2"></circle> </svg> );

// --- MONSTER DATA ---
const MONSTER_TYPES = [
    { name: '초록 슬라임', Icon: GreenSlimeIcon, minLevel: 1 },
    { name: '빨간 슬라임', Icon: RedSlimeIcon, minLevel: 1 },
    { name: '파란 슬라임', Icon: BlueSlimeIcon, minLevel: 1 },
];
const BOSS_TYPES = [
    { name: '골렘', Icon: GolemIcon },
    { name: '킹 슬라임', Icon: KingSlimeIcon },
    { name: '드래곤', Icon: DragonIcon },
];
const SPECIAL_MONSTERS = {
    TREASURE_GOLEM: { name: '보물 골렘', Icon: TreasureGolemIcon, isSpecial: true }
};

// --- ARTIFACT DATA ---
const ARTIFACTS = [
    { id: 'berserkers_blood', name: '광전사의 피', description: '보스에게 주는 모든 피해 +25%', icon: BossIcon, effect: { type: 'BOSS_DAMAGE', value: 25 } },
    { id: 'swift_quiver', name: '신속의 화살통', description: '공격 속도 +10%', icon: AttackSpeedIcon, effect: { type: 'ATTACK_SPEED_MULT', value: 0.1 } },
    { id: 'mana_crystal', name: '마나 수정', description: '스킬 쿨타임 -15%', icon: DpsIcon, effect: { type: 'HASTE', value: 15 } },
    { id: 'lucky_clover', name: '행운의 클로버', description: '크리티컬 확률 +5%p', icon: LuckIcon, effect: { type: 'CRIT_CHANCE', value: 5 } },
    { id: 'executioners_edge', name: '처형인의 칼날', description: '크리티컬 데미지 +50%p', icon: CritIcon, effect: { type: 'CRIT_DAMAGE', value: 50 } },
    { id: 'golden_goblet', name: '황금 술잔', description: '골드 획득량 +20%', icon: CoinIcon, effect: { type: 'GOLD_GAIN', value: 20 } },
    { id: 'sages_stone', name: '현자의 돌', description: '경험치 획득량 +20%', icon: XPIcon, effect: { type: 'XP_GAIN', value: 20 } },
    { id: 'ancient_scope', name: '고대의 조준경', description: '클릭 데미지 +25%', icon: SwordIcon, effect: { type: 'CLICK_DAMAGE_MULT', value: 0.25 } },
];

// --- UTILS ---
const formatNumber = (num) => {
    const n = Math.floor(num);
    if (n < 1000) return n.toString();
    if (n < 1000000) return (n / 1000).toFixed(0) + 'K';
    if (n < 1000000000) return (n / 1000000).toFixed(0) + 'M';
    if (n < 1000000000000) return (n / 1000000000).toFixed(0) + 'B';
    return (n / 1000000000000).toFixed(0) + 'T';
};

const formatTime = (seconds) => {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    return [
        h > 0 ? `${h}시간` : '',
        m > 0 ? `${m}분` : '',
        s > 0 ? `${s}초` : ''
    ].filter(Boolean).join(' ');
};

const getEnhancedItemStats = (item) => {
    if (!item || !item.stats) return { clickDamage: 0, autoAttackDamage: 0, critChance: 0, critDamage: 0, attackSpeedBonus: 0, hasteBonus: 0, goldGainBonus: 0, xpGainBonus: 0 };
    const itemLevel = item.level || 0;
    const multiplier = Math.pow(1.1, itemLevel);
    const bonusStatMultiplier = 1 + (itemLevel * 0.1);
    
    return {
        clickDamage: (item.stats.clickDamage || 0) * multiplier,
        autoAttackDamage: (item.stats.autoAttackDamage || 0) * multiplier,
        critChance: (item.stats.critChance || 0) + (itemLevel * 0.2),
        critDamage: (item.stats.critDamage || 0) + (itemLevel * 2),
        attackSpeedBonus: (item.stats.attackSpeedBonus || 0) * bonusStatMultiplier,
        hasteBonus: (item.stats.hasteBonus || 0) * bonusStatMultiplier,
        goldGainBonus: (item.stats.goldGainBonus || 0) * bonusStatMultiplier,
        xpGainBonus: (item.stats.xpGainBonus || 0) * bonusStatMultiplier,
    };
};

const calculateItemStats = (baseLevel, rarityKey, typeKey) => {
    const rarity = RARITIES[rarityKey];
    const stats = { clickDamage: 0, autoAttackDamage: 0, critChance: 0, critDamage: 0, attackSpeedBonus: 0, hasteBonus: 0, goldGainBonus: 0, xpGainBonus: 0 };
    const statBudget = baseLevel * rarity.statMultiplier;
    switch (typeKey) {
        case 'WEAPON': stats.clickDamage = Math.ceil(statBudget * (1 + Math.random() * 0.2)); break;
        case 'ARMOR': stats.autoAttackDamage = Math.ceil(statBudget * 0.6 * (1 + Math.random() * 0.2)); break;
        case 'AMULET':
            stats.critChance = parseFloat((statBudget * 0.1 * (1 + Math.random() * 0.1)).toFixed(1));
            stats.critDamage = Math.ceil(statBudget * 2 * (1 + Math.random() * 0.1));
            break;
        case 'HELMET': stats.xpGainBonus = Math.ceil(statBudget * 0.5); break;
        case 'GLOVES': stats.attackSpeedBonus = Math.ceil(statBudget * 0.15); break;
        case 'BOOTS': stats.hasteBonus = Math.ceil(statBudget * 0.15); break;
    }
    return stats;
}


// --- COMPONENTS ---
const PlayerStats = ({ stats, playerClass, onNameChange, abilityStats, liberationCount, rebirthCount, onJobChangeClick, difficulty, onDifficultyChangeClick, isAutoDropEnabled, onToggleAutoDrop }) => (
    <div className="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h2 className="text-2xl font-bold mb-4 text-green-400">플레이어 정보</h2>
        <div className="flex justify-around mb-3 text-center">
             {liberationCount > 0 && ( <div className="font-bold text-yellow-300 text-lg border-2 border-yellow-400 bg-gray-700 p-2 rounded w-1/2 mr-1">해방 {liberationCount}</div> )}
             {rebirthCount > 0 && ( <div className="font-bold text-purple-400 text-lg border-2 border-purple-500 bg-gray-700 p-2 rounded w-1/2 ml-1">환생 {rebirthCount}</div> )}
        </div>
        <div className="space-y-2">
             <div className="flex justify-between items-center bg-gray-700 p-2 rounded">
                <span className="font-semibold">이름:</span>
                <input type="text" value={stats.playerName} onChange={(e) => onNameChange(e.target.value)} className="bg-gray-600 text-right font-bold text-lg rounded px-2 w-32" />
            </div>
            {playerClass && (
                <div className="flex justify-between items-center bg-gray-700 p-2 rounded">
                    <span className="font-semibold">직업:</span>
                    <button onClick={onJobChangeClick} className="font-bold text-lg text-amber-400 hover:text-amber-300 transition-colors" title="직업 변경">
                        {JOBS[playerClass].name} <span className="text-sm">🔄</span>
                    </button>
                </div>
            )}
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded">
                <span className="font-semibold">난이도:</span>
                <button onClick={onDifficultyChangeClick} className="font-bold text-lg text-cyan-400 hover:text-cyan-300 transition-colors" title="난이도 변경">
                    {DIFFICULTIES[difficulty].name} <span className="text-sm">⚙️</span>
                </button>
            </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded">
                <span className="font-semibold">장비 자동 판매:</span>
                <button onClick={onToggleAutoDrop} className={`font-bold text-sm px-3 py-1 rounded-md transition-colors ${isAutoDropEnabled ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-red-600 hover:bg-red-700 text-white'}`}>
                    {isAutoDropEnabled ? 'ON' : 'OFF'}
                </button>
            </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><LevelIcon />레벨:</span> <span className="font-bold text-lg">{stats.level}</span> </div>
            <div className="bg-gray-700 p-2 rounded text-sm">
                <div className="flex justify-between items-center mb-1"> <span className="font-semibold"><XPIcon />경험치:</span> <span>{formatNumber(stats.xp)} / {formatNumber(stats.maxXp)}</span> </div>
                <div className="w-full bg-gray-600 rounded-full h-3"> <div className="bg-purple-500 h-3 rounded-full" style={{ width: `${(stats.xp / stats.maxXp) * 100}%` }}></div> </div>
            </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><CoinIcon />골드:</span> <span className="font-bold text-lg text-yellow-400">{formatNumber(stats.coins)}</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><SwordIcon />클릭 데미지:</span> <span>{formatNumber(stats.clickDamage)}</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><DpsIcon />자동 공격 데미지:</span> <span>{formatNumber(stats.autoAttackDamage)}</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><AttackSpeedIcon />공격 속도:</span> <span>{stats.attackSpeed.toFixed(1)} / s</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><CritIcon />크리 확률:</span> <span>{Math.round(stats.critChance)}%</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><CritIcon />크리 데미지:</span> <span>{Math.round(stats.critDamage)}%</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm"> <span className="font-semibold"><LuckIcon />행운:</span> <span>{stats.luck}</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-xs"> <span className="font-semibold text-cyan-400"><CoinIcon />골드 보너스:</span> <span className="text-cyan-400">+{Math.round(abilityStats.goldGainBonus)}%</span> </div>
            <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-xs"> <span className="font-semibold text-purple-400"><XPIcon />경험치 보너스:</span> <span className="text-purple-400">+{Math.round(abilityStats.xpGainBonus)}%</span> </div>
             <div className="flex justify-between items-center bg-gray-700 p-2 rounded text-xs"> <span className="font-semibold text-red-400"><BossIcon />보스 데미지:</span> <span className="text-red-400">+{Math.round(abilityStats.bossDamageBonus)}%</span> </div>
        </div>
    </div>
);


const EquipmentTooltip = ({ item }) => {
    if (!item) return null;
    const rarityInfo = RARITIES[item.rarity];
    const typeInfo = EQUIPMENT_TYPES[item.type];
    const enhancedStats = getEnhancedItemStats(item);

    return (
        <div className="tooltiptext">
            <p className={`font-bold text-lg ${rarityInfo.textClass}`}>{item.name} {item.level > 0 ? `+${item.level}`: ''}</p>
            <p className="text-sm text-gray-400 mb-2"> <span className={rarityInfo.textClass}>[{rarityInfo.name}]</span> <span> {typeInfo.name}</span> </p>
            <hr className="border-gray-600 my-2" />
            <div className="space-y-1 text-sm">
                {enhancedStats.clickDamage > 0 && <p className="flex items-center"><SwordIcon className="h-4 w-4 mr-1.5" /> <span>클릭 데미지 +{formatNumber(enhancedStats.clickDamage)}</span></p>}
                {enhancedStats.autoAttackDamage > 0 && <p className="flex items-center"><DpsIcon className="h-4 w-4 mr-1.5" /> <span>자동 공격 +{formatNumber(enhancedStats.autoAttackDamage)}</span></p>}
                {enhancedStats.critChance > 0 && <p className="flex items-center"><CritIcon className="h-4 w-4 mr-1.5" /> <span>크리 확률 +{Math.round(enhancedStats.critChance)}%</span></p>}
                {enhancedStats.critDamage > 0 && <p className="flex items-center"><CritIcon className="h-4 w-4 mr-1.5" /> <span>크리 데미지 +{formatNumber(enhancedStats.critDamage)}%</span></p>}
                {enhancedStats.attackSpeedBonus > 0 && <p className="flex items-center"><AttackSpeedIcon className="h-4 w-4 mr-1.5" /> <span>공격 속도 +{Math.round(enhancedStats.attackSpeedBonus)}%</span></p>}
                {enhancedStats.hasteBonus > 0 && <p className="flex items-center"><DpsIcon className="h-4 w-4 mr-1.5" /> <span>가속 +{Math.round(enhancedStats.hasteBonus)}%</span></p>}
                {enhancedStats.goldGainBonus > 0 && <p className="flex items-center"><CoinIcon className="h-4 w-4 mr-1.5" /> <span>골드 획득 +{Math.round(enhancedStats.goldGainBonus)}%</span></p>}
                {enhancedStats.xpGainBonus > 0 && <p className="flex items-center"><XPIcon className="h-4 w-4 mr-1.5" /> <span>경험치 획득 +{Math.round(enhancedStats.xpGainBonus)}%</span></p>}
            </div>
        </div>
    );
};

const EquipmentSlot = ({ item, type, onClick }) => {
    const IconComponent = EQUIPMENT_TYPES[type].icon;
    const rarityInfo = item ? RARITIES[item.rarity] : null;

    return (
        <div className="tooltip" onClick={onClick}>
             <div className={`bg-gray-700 p-2 rounded h-16 flex items-center border-2 ${item ? `${rarityInfo.borderClass} cursor-pointer hover:bg-gray-600` : 'border-gray-600'}`}>
                <IconComponent className="h-8 w-8 text-gray-400 mr-2" />
                {item ? ( <div> <p className={`font-semibold text-sm ${rarityInfo.textClass}`}>{item.name} {item.level > 0 ? `+${item.level}` : ''}</p> <p className="text-xs text-gray-400">{rarityInfo.name}</p> </div> ) : ( <p className="text-gray-500">비어있음</p> )}
            </div>
            <EquipmentTooltip item={item} />
        </div>
    );
};


const EquipmentPanel = ({ equipment, onSelectItem }) => (
    <div className="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h2 className="text-2xl font-bold mb-4 text-green-400">장비</h2>
        <div className="grid grid-cols-2 gap-2">
            <EquipmentSlot item={equipment.weapon} type="WEAPON" onClick={() => onSelectItem(equipment.weapon)} />
            <EquipmentSlot item={equipment.helmet} type="HELMET" onClick={() => onSelectItem(equipment.helmet)} />
            <EquipmentSlot item={equipment.armor} type="ARMOR" onClick={() => onSelectItem(equipment.armor)} />
            <EquipmentSlot item={equipment.gloves} type="GLOVES" onClick={() => onSelectItem(equipment.gloves)} />
            <EquipmentSlot item={equipment.amulet} type="AMULET" onClick={() => onSelectItem(equipment.amulet)} />
            <EquipmentSlot item={equipment.boots} type="BOOTS" onClick={() => onSelectItem(equipment.boots)} />
        </div>
    </div>
);


const MonsterDisplay = ({ monster, onClick, damagePopups, treasureGolem }) => {
    const MonsterIcon = monster.Icon;
    const isTreasureGolem = treasureGolem.isActive;

    return (
        <div className="transition-transform duration-100">
            <h2 className={`text-3xl font-bold text-center mb-2 ${monster.isBoss ? 'text-red-400' : ''} ${isTreasureGolem ? 'text-yellow-400' : ''}`}>
                {monster.isBoss ? `[BOSS] ${monster.name}` : monster.name} (Lv.{monster.level})
            </h2>
            {isTreasureGolem && <p className="text-center text-2xl font-bold text-yellow-300 mb-2">남은 시간: {treasureGolem.timer}초</p>}
            <div className={`w-full bg-gray-700 rounded-full h-6 mb-2 border-2 ${monster.isBoss ? 'border-red-400' : 'border-gray-600'}`}>
                <div className="bg-red-500 h-full rounded-full transition-width duration-300" style={{ width: `${(monster.hp / monster.maxHp) * 100}%` }}> </div>
            </div>
            <p className="text-center font-bold text-lg mb-4"> {formatNumber(monster.hp)} / {formatNumber(monster.maxHp)} </p>
            <div className="relative cursor-pointer" onClick={onClick} style={{ userSelect: 'none' }}>
                <MonsterIcon className="w-96 h-96" />
                {damagePopups.map(popup => (
                    <div key={popup.id}
                         className={`absolute font-bold text-2xl pointer-events-none 
                            ${popup.type === 'skill' ? 'text-orange-400 animate-damage-popup-skill' : ''}
                            ${popup.type === 'normal' ? 'text-yellow-300 animate-damage-popup' : ''}
                            ${popup.type === 'crit' ? 'text-yellow-200 animate-damage-popup-crit' : ''}
                         `}
                         style={{ left: `${popup.x}%`, top: `${popup.y}%` }}>
                        {formatNumber(popup.damage)}
                    </div>
                ))}
            </div>
        </div>
    );
};

const UpgradePanel = ({ upgrades, playerCoins, handlers, abilityStats, equipmentGachaCost }) => (
    <div>
        <h3 className="text-lg font-semibold mb-2 text-green-300">전투 능력</h3>
        <div className="space-y-2">
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeClick} disabled={playerCoins < upgrades.clickUpgradeCost} className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    검 강화 (+{upgrades.clickUpgradeLevel}) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.clickUpgradeCost)}
                </button>
                 <span className="tooltiptext"> <p className="font-bold">클릭 데미지 증가</p> <p className="text-sm text-gray-300">클릭당 공격력을 높여 몬스터를 더 빠르게 처치합니다.</p> </span>
            </div>
             <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeAutoAttack} disabled={playerCoins < upgrades.autoAttackUpgradeCost} className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    자동 공격 강화 (+{upgrades.autoAttackUpgradeLevel}) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.autoAttackUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">자동 공격 데미지 증가</p> <p className="text-sm text-gray-300">자동 공격의 기본 데미지를 증가시킵니다.</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeAttackSpeed} disabled={playerCoins < upgrades.attackSpeedUpgradeCost} className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    공격 속도 증가 (+0.1) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.attackSpeedUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">공격 속도 증가</p> <p className="text-sm text-gray-300">초당 자동 공격 횟수를 늘려 DPS를 극대화합니다.</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeCritChance} disabled={playerCoins < upgrades.critChanceUpgradeCost} className="w-full bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    크리 확률 (+{CRIT_CHANCE_UPGRADE_INCREASE}%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.critChanceUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">크리티컬 확률 증가</p> <p className="text-sm text-gray-300">모든 공격에 적용되는 강력한 능력치입니다.</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeCritDamage} disabled={playerCoins < upgrades.critDamageUpgradeCost} className="w-full bg-yellow-800 hover:bg-yellow-900 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    크리 데미지 (+{CRIT_DAMAGE_UPGRADE_INCREASE}%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.critDamageUpgradeCost)}
                </button>
                 <span className="tooltiptext"> <p className="font-bold">크리티컬 데미지 증가</p> <p className="text-sm text-gray-300">크리티컬 데미지 배율을 증가시킵니다.</p> </span>
            </div>
             <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeBossDamage} disabled={playerCoins < upgrades.bossDamageUpgradeCost} className="w-full bg-red-800 hover:bg-red-900 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    보스 데미지 (+2%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.bossDamageUpgradeCost)}
                </button>
                 <span className="tooltiptext"> <p className="font-bold">보스 데미지 증가</p> <p className="text-sm text-gray-300">보스 몬스터에게 주는 모든 피해량이 증가합니다.</p> <p className="text-sm text-red-300 mt-2">현재: +{Math.round(abilityStats.bossDamageBonus)}%</p> </span>
            </div>
        </div>

        <h3 className="text-lg font-semibold mt-4 mb-2 text-green-300">보조 능력</h3>
        <div className="space-y-2">
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeGoldGain} disabled={playerCoins < upgrades.goldGainUpgradeCost} className="w-full bg-cyan-600 hover:bg-cyan-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    골드 획득 (+5%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.goldGainUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">골드 획득량 증가</p> <p className="text-sm text-gray-300">더 빠른 성장을 위한 필수 투자입니다.</p> <p className="text-sm text-cyan-300 mt-2">현재: +{Math.round(abilityStats.goldGainBonus)}%</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeXpGain} disabled={playerCoins < upgrades.xpGainUpgradeCost} className="w-full bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    경험치 획득 (+5%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.xpGainUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">경험치 획득량 증가</p> <p className="text-sm text-gray-300">빠른 레벨업을 돕습니다.</p> <p className="text-sm text-purple-300 mt-2">현재: +{Math.round(abilityStats.xpGainBonus)}%</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeLuck} disabled={playerCoins < upgrades.luckUpgradeCost} className="w-full bg-pink-500 hover:bg-pink-600 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    행운 증가 (+1) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.luckUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">행운 증가</p> <p className="text-sm text-gray-300">장비 획득 확률과 등급을 높여줍니다.</p> <p className="text-sm text-pink-300 mt-2">현재: {abilityStats.luck} 행운</p> </span>
            </div>
        </div>

        <h3 className="text-lg font-semibold mt-4 mb-2 text-green-300">스킬 강화</h3>
        <div className="space-y-2">
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeSkillDamage} disabled={playerCoins < upgrades.skillDamageUpgradeCost} className="w-full bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    스킬 공격력 (+10%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.skillDamageUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">스킬 데미지 강화</p> <p className="text-sm text-gray-300">액티브 스킬의 효과를 강화합니다.</p> <p className="text-sm text-orange-300 mt-2">현재: +{Math.round(abilityStats.skillDamageBonus)}%</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeHaste} disabled={playerCoins < upgrades.hasteUpgradeCost} className="w-full bg-teal-600 hover:bg-teal-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    가속 (+1%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.hasteUpgradeCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">가속 (쿨타임 감소)</p> <p className="text-sm text-gray-300">스킬 재사용 대기시간을 줄입니다.</p> <p className="text-sm text-teal-300 mt-2">현재: 쿨타임 -{Math.round(abilityStats.haste)}%</p> </span>
            </div>
        </div>

        <h3 className="text-lg font-semibold mt-4 mb-2 text-green-300">특별</h3>
         <div className="space-y-2">
            <div className="tooltip w-full">
                <button onClick={handlers.onEquipmentGacha} disabled={playerCoins < equipmentGachaCost} className="w-full bg-pink-600 hover:bg-pink-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    <GachaIcon className="inline-block h-4 w-4 -mt-1" /> 장비 뽑기 | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(equipmentGachaCost)}
                </button>
                <span className="tooltiptext"> <p className="font-bold">장비 뽑기</p> <p className="text-sm text-gray-300">골드를 사용하여 무작위 장비를 획득합니다.</p> </span>
            </div>
            <div className="tooltip w-full">
                <button onClick={handlers.onUpgradeArtifactPower} disabled={playerCoins < upgrades.artifactPowerUpgradeCost} className="w-full bg-yellow-500 hover:bg-yellow-600 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm transition-all duration-200">
                    <ArtifactIcon className="inline-block h-4 w-4 -mt-1" /> 유물력 강화 (+1%) | <CoinIcon className="inline-block h-4 w-4 -mt-1" /> {formatNumber(upgrades.artifactPowerUpgradeCost)}
                </button>
                <span className="tooltiptext">
                    <p className="font-bold">유물력 강화</p>
                    <p className="text-sm text-gray-300">장착한 모든 유물의 효과를 증폭시킵니다.</p>
                    <p className="text-sm text-yellow-300 mt-2">현재: +{Math.round(abilityStats.artifactPowerBonus)}%</p>
                </span>
            </div>
        </div>
    </div>
);

const InventoryPanel = ({ inventory, onSelectItem, isSellMode, onToggleSellMode, sellList, onToggleSellItem, onBulkSell }) => {
    const [filter, setFilter] = useState('ALL');

    const filteredInventory = useMemo(() => {
        if (filter === 'ALL') return inventory;
        return inventory.filter(item => item.type === filter);
    }, [inventory, filter]);

    const FilterButton = ({ type, children }) => {
        const isActive = filter === type;
        return (
            <button
                onClick={() => setFilter(type)}
                className={`flex-1 p-2 rounded-md text-sm transition-colors ${isActive ? 'bg-green-600 text-white font-bold' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
            >
                {children}
            </button>
        );
    };

    return (
        <div>
            <div className="flex justify-between items-center mb-2">
                 <h3 className="text-lg font-semibold text-green-300">인벤토리</h3>
                 <div className="flex items-center gap-2">
                    <span className="text-sm text-gray-400">{inventory.length}개</span>
                    <button onClick={onToggleSellMode} className={`text-sm py-1 px-2 rounded ${isSellMode ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-600 hover:bg-gray-500 text-gray-200'}`}>판매 모드</button>
                 </div>
            </div>
            <div className="grid grid-cols-4 gap-1 mb-2">
                <FilterButton type="ALL">전체</FilterButton>
                <FilterButton type="WEAPON"><SwordIcon className="w-5 h-5 mx-auto"/></FilterButton>
                <FilterButton type="ARMOR"><ArmorIcon className="w-5 h-5 mx-auto"/></FilterButton>
                <FilterButton type="AMULET"><AmuletIcon className="w-5 h-5 mx-auto"/></FilterButton>
                <FilterButton type="HELMET"><HelmetIcon className="w-5 h-5 mx-auto"/></FilterButton>
                <FilterButton type="GLOVES"><GlovesIcon className="w-5 h-5 mx-auto"/></FilterButton>
                <FilterButton type="BOOTS"><BootsIcon className="w-5 h-5 mx-auto"/></FilterButton>
            </div>
            <div className="grid grid-cols-4 gap-2 h-[380px] overflow-y-auto bg-gray-900/50 p-2 rounded">
                {filteredInventory.map(item => {
                    const rarityInfo = RARITIES[item.rarity];
                    const IconComponent = EQUIPMENT_TYPES[item.type].icon;
                    const isSelected = sellList.has(item.id);
                    return (
                        <div key={item.id} className="tooltip" onClick={() => isSellMode ? onToggleSellItem(item) : onSelectItem(item)}>
                            <div className={`relative aspect-square flex items-center justify-center p-1 border-2 ${rarityInfo.borderClass} bg-gray-800 rounded-md cursor-pointer hover:bg-gray-700 transition-colors ${isSelected ? 'ring-2 ring-red-500 ring-offset-2 ring-offset-gray-800' : ''}`}>
                                 <IconComponent className={`h-8 w-8 ${rarityInfo.textClass}`} />
                                 {item.level > 0 && <span className="absolute bottom-0 right-0 text-xs bg-gray-900 px-1 rounded-sm">+{item.level}</span>}
                                 {isSelected && <div className="absolute inset-0 bg-red-500/50 flex items-center justify-center"><CoinIcon className="w-6 h-6 text-white"/></div>}
                            </div>
                            <EquipmentTooltip item={item} />
                        </div>
                    );
                })}
            </div>
            {isSellMode && (
                <div className="mt-2 p-2 bg-gray-900/50 rounded">
                    <p className="text-center mb-2 text-sm text-gray-300">{sellList.size}개 아이템 선택됨</p>
                    <button
                        onClick={onBulkSell}
                        disabled={sellList.size === 0}
                        className="w-full bg-red-600 hover:bg-red-700 disabled:bg-gray-500 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors"
                    >
                        선택 아이템 판매
                    </button>
                </div>
            )}
        </div>
    );
};


const ForgePanel = ({ selectedItem, handlers, playerCoins }) => {
    const [forgeTab, setForgeTab] = useState('enhance');

    if (!selectedItem) {
        return (
            <div>
                 <h3 className="text-lg font-semibold mb-2 text-green-300">대장간</h3>
                 <div className="h-[450px] flex items-center justify-center text-gray-500">
                     <p>아이템을 선택하세요.</p>
                 </div>
            </div>
        );
    }
    
    const { onForge, onUpgradeRarity, onReforge } = handlers;
    const rarityInfo = RARITIES[selectedItem.rarity];
    const itemLevel = selectedItem.level || 0;

    const renderStats = (item) => {
        const stats = getEnhancedItemStats(item);
        
        return (
             <div className="space-y-1 text-sm p-2 bg-gray-900/50 rounded">
                {stats.clickDamage > 0 && <p>클릭 데미지 +{formatNumber(stats.clickDamage)}</p>}
                {stats.autoAttackDamage > 0 && <p>자동 공격 +{formatNumber(stats.autoAttackDamage)}</p>}
                {stats.critChance > 0 && <p>크리 확률 +{Math.round(stats.critChance)}%</p>}
                {stats.critDamage > 0 && <p>크리 데미지 +{formatNumber(stats.critDamage)}%</p>}
                {stats.attackSpeedBonus > 0 && <p>공격 속도 +{Math.round(stats.attackSpeedBonus)}%</p>}
                {stats.hasteBonus > 0 && <p>가속 +{Math.round(stats.hasteBonus)}%</p>}
                {stats.goldGainBonus > 0 && <p>골드 획득 +{Math.round(stats.goldGainBonus)}%</p>}
                {stats.xpGainBonus > 0 && <p>경험치 획득 +{Math.round(stats.xpGainBonus)}%</p>}
            </div>
        );
    };
    
    const renderEnhanceTab = () => {
        const upgradeCost = Math.ceil(rarityInfo.statMultiplier * 30 * Math.pow(1.35, itemLevel) * (1 + itemLevel * 0.1));
        return (
            <div className="space-y-3">
                 <div> <p className="font-semibold mb-1">현재 (+{itemLevel})</p> {renderStats(selectedItem)} </div>
                 <div> <p className="font-semibold mb-1">다음 (+{itemLevel + 1})</p> {renderStats({ ...selectedItem, level: itemLevel + 1 })} </div>
                <div className="text-center">
                    <p className="mb-2 flex items-center justify-center">비용: <CoinIcon/> {formatNumber(upgradeCost)}</p>
                    <button onClick={() => onForge(selectedItem)} disabled={playerCoins < upgradeCost} className="w-full bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded">
                        강화하기
                    </button>
                </div>
            </div>
        );
    };

    const renderUpgradeRarityTab = () => {
        const currentRarityIndex = RARITY_ORDER.indexOf(selectedItem.rarity);
        if (currentRarityIndex === -1 || currentRarityIndex >= RARITY_ORDER.length - 1) {
            return <div className="text-center text-gray-400 py-8">최고 등급 아이템입니다.</div>;
        }
        const nextRarityKey = RARITY_ORDER[currentRarityIndex + 1];
        
        const upgradeCost = Math.ceil(Math.pow(10, currentRarityIndex + 2) * (selectedItem.baseLevel || 1) * rarityInfo.statMultiplier);
        const canUpgrade = playerCoins >= upgradeCost;

        return (
             <div className="space-y-3 text-center">
                 <p>현재 등급: <span className={rarityInfo.textClass}>{rarityInfo.name}</span></p>
                 <p className="text-2xl font-bold my-4">▼</p>
                 <p>다음 등급: <span className={RARITIES[nextRarityKey].textClass}>{RARITIES[nextRarityKey].name}</span></p>
                 <div className="mt-6">
                    <p className="mb-2 flex items-center justify-center">비용: <CoinIcon/> {formatNumber(upgradeCost)}</p>
                     <button onClick={() => onUpgradeRarity(selectedItem)} disabled={!canUpgrade} className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded">
                        등급 승급
                    </button>
                 </div>
            </div>
        );
    };

    const renderReforgeTab = () => {
        const cost = Math.ceil(rarityInfo.statMultiplier * 500 * (1 + itemLevel * 0.5) * (selectedItem.baseLevel || 1));
        const canReforge = playerCoins >= cost;
         return (
             <div className="space-y-3">
                 <div> <p className="font-semibold mb-1">현재 능력치</p> {renderStats(selectedItem)} </div>
                 <p className="text-sm text-gray-400 text-center">아이템의 기본 능력치를 무작위로 재설정합니다.</p>
                 <div className="text-center mt-4">
                    <p className="mb-2 flex items-center justify-center">비용: <CoinIcon/> {formatNumber(cost)}</p>
                     <button onClick={() => onReforge(selectedItem)} disabled={!canReforge} className="w-full bg-pink-600 hover:bg-pink-700 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded">
                        능력치 재련
                    </button>
                 </div>
            </div>
        );
    }

    return (
        <div>
            <h3 className="text-lg font-semibold mb-2 text-green-300">대장간</h3>
             <div className={`p-2 rounded border-2 ${rarityInfo.borderClass} bg-gray-800 mb-4`}>
                <p className={`font-bold text-lg ${rarityInfo.textClass}`}>{selectedItem.name} {itemLevel > 0 ? `+${itemLevel}` : ''}</p>
            </div>
            <div className="flex border-b border-gray-700 mb-4 text-sm">
                <button onClick={() => setForgeTab('enhance')} className={`flex-1 py-2 text-center font-semibold ${forgeTab === 'enhance' ? 'text-yellow-400 border-b-2 border-yellow-400' : 'text-gray-400'}`}>강화</button>
                <button onClick={() => setForgeTab('upgrade')} className={`flex-1 py-2 text-center font-semibold ${forgeTab === 'upgrade' ? 'text-purple-400 border-b-2 border-purple-400' : 'text-gray-400'}`}>승급</button>
                <button onClick={() => setForgeTab('reforge')} className={`flex-1 py-2 text-center font-semibold ${forgeTab === 'reforge' ? 'text-pink-400 border-b-2 border-pink-400' : 'text-gray-400'}`}>재련</button>
            </div>

            {forgeTab === 'enhance' && renderEnhanceTab()}
            {forgeTab === 'upgrade' && renderUpgradeRarityTab()}
            {forgeTab === 'reforge' && renderReforgeTab()}
        </div>
    );
};

const MissionsPanel = ({ missions, onClaim }) => (
    <div>
        <h3 className="text-lg font-semibold mb-2 text-green-300">임무</h3>
        <div className="space-y-3 h-[450px] overflow-y-auto pr-2">
            {missions.length > 0 ? missions.map(mission => (
                <div key={mission.id} className="bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                    <p className="font-semibold text-gray-200">{MISSION_TYPES[mission.type]}</p>
                    <div className="w-full bg-gray-600 rounded-full h-2.5 my-1">
                        <div className="bg-teal-500 h-2.5 rounded-full" style={{ width: `${(mission.progress / mission.target) * 100}%` }}></div>
                    </div>
                    <p className="text-sm text-gray-400 mb-2">{formatNumber(mission.progress)} / {formatNumber(mission.target)}</p>
                    {mission.isCompleted ? (
                        <button onClick={() => onClaim(mission.id)} className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded text-sm transition-colors">
                            보상 받기 (+{formatNumber(mission.reward)} <CoinIcon className="h-4 w-4 inline-block -mt-1"/>)
                        </button>
                    ) : (
                        <p className="text-sm text-yellow-400 text-center">보상: {formatNumber(mission.reward)} <CoinIcon className="h-4 w-4 inline-block -mt-1"/></p>
                    )}
                </div>
            )) : (
                <div className="h-full flex items-center justify-center text-gray-500">
                     <p>모든 임무 완료!</p>
                </div>
            )}
        </div>
    </div>
);

const ArtifactPanel = ({ owned, equipped, onEquip, onUnequip, onGacha, playerCoins }) => {
    const gachaCost = 1000;
    const allArtifactsOwned = owned.length >= ARTIFACTS.length;

    return (
        <div>
            <h3 className="text-lg font-semibold mb-2 text-green-300">유물</h3>
            <div className="bg-gray-900/50 p-2 rounded mb-3">
                <h4 className="text-md font-semibold mb-2 text-center text-yellow-300">장착된 유물</h4>
                <div className="grid grid-cols-3 gap-2">
                    {[0, 1, 2].map(index => {
                        const artifactId = equipped[index];
                        const artifact = artifactId ? ARTIFACTS.find(a => a.id === artifactId) : null;
                        return (
                            <div key={index} onClick={() => artifact && onUnequip(artifact.id)} className={`tooltip aspect-square flex items-center justify-center p-1 border-2 ${artifact ? 'border-yellow-400 bg-gray-800 cursor-pointer' : 'border-gray-600 bg-gray-700'}`}>
                                {artifact ? <artifact.icon className="h-8 w-8 text-yellow-400" /> : <span className="text-gray-500 text-xs">비어있음</span>}
                                {artifact && <span className="tooltiptext">{artifact.name}: {artifact.description}</span>}
                            </div>
                        );
                    })}
                </div>
            </div>
            <div className="space-y-2 h-[260px] overflow-y-auto pr-2">
                <h4 className="text-md font-semibold text-center text-gray-300">보유한 유물</h4>
                {owned.length > 0 ? owned.map(id => {
                    const artifact = ARTIFACTS.find(a => a.id === id);
                    if (!artifact) return null;
                    const isEquipped = equipped.includes(id);
                    return (
                        <div key={id} onClick={() => !isEquipped && onEquip(id)} className={`bg-gray-800 p-3 rounded-lg border border-gray-600 flex items-center gap-3 ${isEquipped ? 'opacity-50' : 'cursor-pointer hover:bg-gray-700'}`}>
                            <artifact.icon className="w-8 h-8 text-yellow-400 flex-shrink-0" />
                            <div>
                                <p className="font-semibold text-yellow-400">{artifact.name}</p>
                                <p className="text-xs text-gray-300">{artifact.description}</p>
                            </div>
                        </div>
                    );
                }) : <p className="text-center text-gray-500 mt-8">보유한 유물이 없습니다.</p>}
            </div>
            <div className="mt-2 pt-2 border-t border-gray-700">
                <h4 className="text-md font-semibold text-center text-green-300 mb-2">유물 뽑기</h4>
                <button 
                    onClick={onGacha}
                    disabled={allArtifactsOwned || playerCoins < gachaCost}
                    className="w-full bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 text-white font-bold py-2 px-4 rounded"
                >
                    {allArtifactsOwned ? '모든 유물 획득' : (
                        `뽑기 | ${formatNumber(gachaCost)}`
                    )}
                </button>
            </div>
        </div>
    );
};

const SlotMachineGame = ({ playerCoins, playerLevel, onSpin }) => {
    const [reels, setReels] = useState(['🍀', '🍀', '🍀']);
    const [spinning, setSpinning] = useState(false);
    const [result, setResult] = useState(null);
    const spinIntervalRef = useRef(null);
    const symbols = useMemo(() => ['💰', '⚔️', '💧', '💎', '🍀'], []);
    const cost = 100 + playerLevel * 50;
    
    const handleSpin = () => {
        if (playerCoins < cost || spinning) return;
        setSpinning(true);
        setResult(null);

        spinIntervalRef.current = setInterval(() => {
            setReels(reels => reels.map(() => symbols[Math.floor(Math.random() * symbols.length)]));
        }, 80);

        onSpin(cost, (newReels, reward) => {
            setTimeout(() => {
                clearInterval(spinIntervalRef.current);
                
                let reelIndex = 0;
                const revealInterval = setInterval(() => {
                    setReels(prev => {
                        const next = [...prev];
                        next[reelIndex] = newReels[reelIndex];
                        return next;
                    });
                    reelIndex++;
                    if (reelIndex >= newReels.length) {
                        clearInterval(revealInterval);
                        setSpinning(false);
                        setResult(reward);
                    }
                }, 400);
            }, 1200);
        });
    };

    return (
        <div className="bg-gray-900/50 p-4 rounded-lg">
            <div className="flex justify-center gap-4 mb-4 bg-gray-700 p-4 rounded">
                {reels.map((symbol, i) => (
                    <div key={i} className="w-16 h-16 bg-gray-900 rounded-md flex items-center justify-center text-4xl">
                        {symbol}
                    </div>
                ))}
            </div>
            <div className="text-center mb-4 h-12">
                {result && (
                    <p className="text-lg font-bold text-yellow-300">{result.message}</p>
                )}
            </div>
            <button onClick={handleSpin} disabled={playerCoins < cost || spinning} className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded">
                {spinning ? '돌아가는 중...' : `돌리기 (${formatNumber(cost)} 골드)`}
            </button>
        </div>
    );
};

const WhackASlimeGame = ({ playerCoins, playerLevel, onStart, onEnd }) => {
    const [gameState, setGameState] = useState({ status: 'idle', score: 0, timeLeft: 15, holes: Array(9).fill(false) });
    const cost = 200 + playerLevel * 100;

    const handleStart = () => {
        if (playerCoins >= cost && onStart(cost)) {
            setGameState({
                status: 'playing',
                score: 0,
                timeLeft: 15,
                holes: Array(9).fill(false)
            });
        }
    };

    useEffect(() => {
        if (gameState.status !== 'playing') return;

        const timerId = setInterval(() => {
            setGameState(prev => {
                if (prev.status !== 'playing') return prev;
                const newTime = prev.timeLeft - 1;
                if (newTime <= 0) {
                    onEnd(prev.score * playerLevel * 5); // Reward calculation
                    return { ...prev, status: 'ended', timeLeft: 0 };
                }
                return { ...prev, timeLeft: newTime };
            });
        }, 1000);

        const slimeId = setInterval(() => {
            setGameState(prev => {
                if (prev.status !== 'playing') return prev;
                const newHoles = [...prev.holes];
                const availableHoles = newHoles.map((h, i) => !h ? i : -1).filter(i => i !== -1);
                if (availableHoles.length > 0) {
                    const randomIndex = availableHoles[Math.floor(Math.random() * availableHoles.length)];
                    newHoles[randomIndex] = true;
                    setTimeout(() => {
                        setGameState(p => {
                            if (p.status !== 'playing') return p;
                            const latestHoles = [...p.holes];
                            latestHoles[randomIndex] = false;
                            return {...p, holes: latestHoles};
                        });
                    }, 700 + Math.random() * 400);
                }
                return { ...prev, holes: newHoles };
            });
        }, 450);

        return () => {
            clearInterval(timerId);
            clearInterval(slimeId);
        };
    }, [gameState.status, playerLevel, onEnd]);

    const handleWhack = (index) => {
        if (gameState.holes[index]) {
            setGameState(prev => {
                const newHoles = [...prev.holes];
                newHoles[index] = false;
                return { ...prev, score: prev.score + 1, holes: newHoles };
            });
        }
    };

    if (gameState.status === 'idle' || gameState.status === 'ended') {
        return (
            <div className="bg-gray-900/50 p-4 rounded-lg text-center">
                {gameState.status === 'ended' && <p className="text-xl mb-4">게임 종료! 최종 점수: <span className="font-bold text-green-400">{gameState.score}</span></p>}
                <p className="mb-4">15초 안에 최대한 많은 슬라임을 잡으세요!</p>
                <button onClick={handleStart} disabled={playerCoins < cost} className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded">
                    시작하기 ({formatNumber(cost)} 골드)
                </button>
            </div>
        );
    }

    return (
        <div className="bg-gray-900/50 p-4 rounded-lg">
            <div className="flex justify-between text-xl font-bold mb-4">
                <span>점수: {gameState.score}</span>
                <span>시간: {gameState.timeLeft}</span>
            </div>
            <div className="grid grid-cols-3 gap-2">
                {gameState.holes.map((isActive, i) => (
                    <div key={i} className="aspect-square bg-yellow-900/70 rounded-full border-4 border-yellow-800 relative overflow-hidden flex items-center justify-center">
                        {isActive && (
                             <div onClick={() => handleWhack(i)} className="w-full h-full cursor-pointer animate-slime-pop">
                                 <GreenSlimeIcon className="w-full h-full" />
                             </div>
                        )}
                    </div>
                ))}
            </div>
        </div>
    );
};


const MinigamePanel = ({ playerCoins, playerLevel, onSlotSpin, onSlimeWhackStart, onSlimeWhackEnd }) => {
    const [activeGame, setActiveGame] = useState('slots');
    return (
        <div>
            <h3 className="text-lg font-semibold mb-2 text-green-300">미니게임</h3>
             <div className="flex border-b border-gray-700 mb-4 text-sm">
                <button onClick={() => setActiveGame('slots')} className={`flex-1 py-2 text-center font-semibold ${activeGame === 'slots' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>행운의 슬롯</button>
                <button onClick={() => setActiveGame('whack')} className={`flex-1 py-2 text-center font-semibold ${activeGame === 'whack' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>두더지 슬라임</button>
            </div>
            {activeGame === 'slots' && <SlotMachineGame playerCoins={playerCoins} playerLevel={playerLevel} onSpin={onSlotSpin} />}
            {activeGame === 'whack' && <WhackASlimeGame playerCoins={playerCoins} playerLevel={playerLevel} onStart={onSlimeWhackStart} onEnd={onSlimeWhackEnd} />}
        </div>
    );
};

const RightPanel = ({ activeTab, setActiveTab, selectedForgeItem, ...props }) => {
    const forgeHandlers = {
        onForge: props.handlers.onForgeItem,
        onUpgradeRarity: props.handlers.onUpgradeRarity,
        onReforge: props.handlers.onReforgeItem,
    };

    return (
        <div className="w-full md:w-1/4 bg-gray-800 p-2 rounded-lg shadow-lg order-3 md:order-3">
            <div className="grid grid-cols-3 text-sm">
                 <button onClick={() => setActiveTab('upgrade')} className={`py-2 text-center font-semibold ${activeTab === 'upgrade' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>강화</button>
                 <button onClick={() => setActiveTab('inventory')} className={`py-2 text-center font-semibold ${activeTab === 'inventory' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>인벤토리</button>
                 <button onClick={() => setActiveTab('forge')} className={`py-2 text-center font-semibold ${activeTab === 'forge' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>대장간</button>
                 <button onClick={() => setActiveTab('missions')} className={`py-2 text-center font-semibold ${activeTab === 'missions' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>임무</button>
                 <button onClick={() => setActiveTab('artifacts')} className={`py-2 text-center font-semibold ${activeTab === 'artifacts' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>유물</button>
                 <button onClick={() => setActiveTab('minigame')} className={`py-2 text-center font-semibold ${activeTab === 'minigame' ? 'text-green-400 border-b-2 border-green-400' : 'text-gray-400'}`}>미니게임</button>
            </div>
            <div className="p-2">
            {activeTab === 'upgrade' && <UpgradePanel {...props}/>}
            {activeTab === 'inventory' && <InventoryPanel 
                inventory={props.inventory} 
                onSelectItem={props.handlers.onSelectItem}
                isSellMode={props.isSellMode}
                onToggleSellMode={props.handlers.onToggleSellMode}
                sellList={props.sellList}
                onToggleSellItem={props.handlers.onToggleSellItem}
                onBulkSell={props.handlers.onBulkSell}
                 />}
            {activeTab === 'forge' && <ForgePanel selectedItem={selectedForgeItem} handlers={forgeHandlers} playerCoins={props.playerCoins} />}
            {activeTab === 'missions' && <MissionsPanel missions={props.missions} onClaim={props.handlers.onClaimMission} />}
            {activeTab === 'artifacts' && <ArtifactPanel owned={props.ownedArtifacts} equipped={props.equippedArtifacts} onEquip={props.handlers.onEquipArtifact} onUnequip={props.handlers.onUnequipArtifact} onGacha={props.handlers.onArtifactGacha} playerCoins={props.playerCoins} />}
            {activeTab === 'minigame' && <MinigamePanel playerCoins={props.playerCoins} onSlotSpin={props.handlers.onSlotSpin} onSlimeWhackStart={props.handlers.onSlimeWhackStart} onSlimeWhackEnd={props.handlers.onSlimeWhackEnd} playerLevel={props.playerStats.level} />}
            </div>
        </div>
    );
};


const LiberationButton = ({ onLiberate, cost, playerCoins, count }) => (
    <div className="w-full">
        <button
            onClick={onLiberate}
            disabled={playerCoins < cost}
            className="w-full bg-gradient-to-r from-yellow-400 via-red-500 to-pink-500 hover:from-yellow-500 hover:to-pink-600 disabled:from-gray-600 disabled:to-gray-700 disabled:cursor-not-allowed text-white font-bold py-4 px-4 rounded-lg transition-all shadow-lg transform hover:scale-105">
            <span className="text-lg drop-shadow-md">해방 ({count}) - 모든 스탯 x2 | <CoinIcon className="inline-block h-5 w-5 -mt-1"/> {formatNumber(cost)}</span>
        </button>
    </div>
);

const RebirthButton = ({ onRebirth, level, count }) => {
    const canRebirth = level >= REBIRTH_LEVEL_REQUIREMENT;
    return (
        <div className="w-full">
            <button
                onClick={onRebirth}
                disabled={!canRebirth}
                className="w-full bg-gradient-to-r from-purple-500 via-indigo-500 to-blue-500 hover:from-purple-600 hover:to-blue-600 disabled:from-gray-600 disabled:to-gray-700 disabled:cursor-not-allowed text-white font-bold py-4 px-4 rounded-lg transition-all shadow-lg transform hover:scale-105"
            >
                {canRebirth ? (
                    <span className="text-lg drop-shadow-md">환생 | 영구 스탯 +{REBIRTH_ALL_STAT_BONUS}% (현재 {count}회)</span>
                ) : (
                    <span className="text-lg drop-shadow-md">환생 필요: Lv.{REBIRTH_LEVEL_REQUIREMENT} (현재 {level})</span>
                )}
            </button>
        </div>
    );
};


const ActiveSkillButton = ({ skill, onClick, cooldown, maxCooldown }) => {
    const isDisabled = cooldown > 0;
    const cooldownPercentage = (cooldown / maxCooldown) * 100;

    return (
        <button
            onClick={onClick}
            disabled={isDisabled}
            className="relative w-full bg-red-700 hover:bg-red-800 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-4 px-4 rounded-lg transition-colors shadow-lg overflow-hidden">
            {cooldown > 0 && (
                 <div className="absolute top-0 left-0 h-full bg-black opacity-50" style={{ width: `${100 - cooldownPercentage}%` }}></div>
            )}
            <div className="relative z-10">
                {cooldown > 0 ? (
                    <span className="text-xl">{skill.name} ({Math.ceil(cooldown / 1000)}초)</span>
                ) : (
                    <span className="text-xl">{skill.name} (사용 가능)</span>
                )}
            </div>
        </button>
    );
};

const GameLog = ({ log }) => (
     <div className="w-full bg-gray-800 p-4 rounded-lg shadow-lg order-4 h-40 overflow-y-auto">
        <h3 className="text-lg font-bold mb-2 text-green-400">게임 로그</h3>
        <div className="text-sm space-y-1"> {log.map((entry, index) => ( <p key={index} className="text-gray-300" dangerouslySetInnerHTML={{ __html: entry }}></p> ))} </div>
    </div>
);

const NewItemDropModal = ({ newItem, currentItem, onEquip, onStore }) => {
    if (!newItem) return null;

    const renderItemStats = (item) => {
        if (!item) return <p className="text-gray-400">없음</p>;
        const rarityInfo = RARITIES[item.rarity];
        const enhancedStats = getEnhancedItemStats(item);
        return (
            <div className={`p-4 rounded-lg border-2 ${rarityInfo.borderClass} bg-gray-800`}>
                <p className={`font-bold text-xl ${rarityInfo.textClass}`}>{item.name} {item.level > 0 ? `+${item.level}` : ''}</p>
                <p className={`text-sm mb-2 ${rarityInfo.textClass}`}>[{rarityInfo.name}]</p>
                <div className="space-y-1">
                    {enhancedStats.clickDamage > 0 && <p><SwordIcon /> 클릭 데미지 +{formatNumber(enhancedStats.clickDamage)}</p>}
                    {enhancedStats.autoAttackDamage > 0 && <p><DpsIcon /> 자동 공격 +{formatNumber(enhancedStats.autoAttackDamage)}</p>}
                    {enhancedStats.critChance > 0 && <p><CritIcon /> 크리 확률 +{Math.round(enhancedStats.critChance)}%</p>}
                    {enhancedStats.critDamage > 0 && <p><CritIcon /> 크리 데미지 +{formatNumber(enhancedStats.critDamage)}%</p>}
                    {enhancedStats.attackSpeedBonus > 0 && <p><AttackSpeedIcon /> 공격 속도 +{Math.round(enhancedStats.attackSpeedBonus)}%</p>}
                    {enhancedStats.hasteBonus > 0 && <p><DpsIcon /> 가속 +{Math.round(enhancedStats.hasteBonus)}%</p>}
                    {enhancedStats.goldGainBonus > 0 && <p><CoinIcon /> 골드 획득 +{Math.round(enhancedStats.goldGainBonus)}%</p>}
                    {enhancedStats.xpGainBonus > 0 && <p><XPIcon /> 경험치 획득 +{Math.round(enhancedStats.xpGainBonus)}%</p>}
                </div>
            </div>
        );
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div className="bg-gray-900 p-6 rounded-lg shadow-2xl w-full max-w-2xl border border-gray-700">
                <h2 className="text-3xl font-bold text-center mb-4 text-green-400">새로운 아이템 획득!</h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div> <h3 className="text-lg font-semibold mb-2 text-center text-yellow-400">새 아이템</h3> {renderItemStats(newItem)} </div>
                    <div> <h3 className="text-lg font-semibold mb-2 text-center text-gray-400">현재 장착</h3> {renderItemStats(currentItem)} </div>
                </div>
                <div className="flex justify-center gap-4">
                     <button onClick={onEquip} className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-lg"> 장착 </button>
                     <button onClick={onStore} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-lg"> 보관 </button>
                </div>
            </div>
        </div>
    );
};

const JobSelectionModal = ({ onSelect, onClose }) => {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
            <div className="bg-gray-900 p-8 rounded-lg shadow-2xl w-full max-w-4xl border border-gray-700 text-center relative">
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-white text-3xl font-bold">&times;</button>
                <h2 className="text-4xl font-bold mb-4 text-green-400">직업을 선택하세요</h2>
                <p className="text-gray-400 mb-8">선택한 직업은 게임 플레이에 큰 영향을 미칩니다.</p>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                    {Object.keys(JOBS).map(jobKey => {
                        const job = JOBS[jobKey];
                        const Icon = job.icon;
                        return (
                            <div key={jobKey} className="bg-gray-800 p-6 rounded-lg border-2 border-gray-700 hover:border-green-500 transition-all flex flex-col">
                                <Icon className="w-12 h-12 mx-auto mb-4 text-green-400"/>
                                <h3 className="text-2xl font-bold mb-3 text-white">{job.name}</h3>
                                <p className="text-gray-300 mb-4 flex-grow">{job.description}</p>
                                <p className="text-sm text-yellow-400 mb-1"><strong>지속 효과:</strong> {job.passive}</p>
                                <p className="text-sm text-orange-400 mb-6"><strong>액티브 스킬:</strong> {job.skill.name}</p>
                                <button onClick={() => onSelect(jobKey)} className="mt-auto w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                                    {job.name}(으)로 선택
                                </button>
                            </div>
                        );
                    })}
                </div>
            </div>
        </div>
    );
};

const InventoryItemDetailModal = ({ item, currentEquipped, onEquip, onSell, onSelectForge, onClose }) => {
    if (!item) return null;

    const renderItemStats = (itemToRender, title) => {
        if (!itemToRender) return <div><h3 className="text-lg font-semibold mb-2 text-center text-gray-400">{title}</h3><div className="p-4 rounded-lg border-2 border-gray-600 bg-gray-800 flex items-center justify-center min-h-[160px]"><p className="text-gray-500">없음</p></div></div>;
        const rarityInfo = RARITIES[itemToRender.rarity];
        const enhancedStats = getEnhancedItemStats(itemToRender);
        return (
            <div>
                 <h3 className="text-lg font-semibold mb-2 text-center text-gray-400">{title}</h3>
                <div className={`p-4 rounded-lg border-2 ${rarityInfo.borderClass} bg-gray-800 min-h-[160px]`}>
                    <p className={`font-bold text-xl ${rarityInfo.textClass}`}>{itemToRender.name} {itemToRender.level > 0 ? `+${itemToRender.level}` : ''}</p>
                    <p className={`text-sm mb-2 ${rarityInfo.textClass}`}>[{rarityInfo.name}]</p>
                    <hr className="border-gray-600 my-1"/>
                    <div className="space-y-1 mt-2">
                        {enhancedStats.clickDamage > 0 && <p><SwordIcon /> 클릭 데미지 +{formatNumber(enhancedStats.clickDamage)}</p>}
                        {enhancedStats.autoAttackDamage > 0 && <p><DpsIcon /> 자동 공격 +{formatNumber(enhancedStats.autoAttackDamage)}</p>}
                        {enhancedStats.critChance > 0 && <p><CritIcon /> 크리 확률 +{Math.round(enhancedStats.critChance)}%</p>}
                        {enhancedStats.critDamage > 0 && <p><CritIcon /> 크리 데미지 +{formatNumber(enhancedStats.critDamage)}%</p>}
                        {enhancedStats.attackSpeedBonus > 0 && <p><AttackSpeedIcon /> 공격 속도 +{Math.round(enhancedStats.attackSpeedBonus)}%</p>}
                        {enhancedStats.hasteBonus > 0 && <p><DpsIcon /> 가속 +{Math.round(enhancedStats.hasteBonus)}%</p>}
                        {enhancedStats.goldGainBonus > 0 && <p><CoinIcon /> 골드 획득 +{Math.round(enhancedStats.goldGainBonus)}%</p>}
                        {enhancedStats.xpGainBonus > 0 && <p><XPIcon /> 경험치 획득 +{Math.round(enhancedStats.xpGainBonus)}%</p>}
                    </div>
                </div>
            </div>
        );
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50" onClick={onClose}>
            <div className="bg-gray-900 p-6 rounded-lg shadow-2xl w-full max-w-2xl border border-gray-700 relative" onClick={e => e.stopPropagation()}>
                <button onClick={onClose} className="absolute top-2 right-3 text-gray-500 hover:text-white text-3xl font-bold">&times;</button>
                <h2 className="text-3xl font-bold text-center mb-4 text-green-400">아이템 정보</h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    {renderItemStats(item, "선택한 아이템")}
                    {renderItemStats(currentEquipped, "현재 장착")}
                </div>
                <div className="flex justify-center gap-4">
                    <button onClick={() => { onEquip(item); onClose(); }} className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg">장착</button>
                    <button onClick={() => { onSell(item); onClose(); }} className="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg text-lg">판매</button>
                    <button onClick={() => { onSelectForge(item); onClose(); }} className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-6 rounded-lg text-lg">대장간</button>
                </div>
            </div>
        </div>
    );
};

const DifficultySelectionModal = ({ onSelect }) => (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-50">
        <div className="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-4xl border border-gray-700 text-center">
            <h2 className="text-4xl font-bold mb-4 text-green-400">난이도 선택</h2>
            <p className="text-gray-400 mb-8">게임을 시작하기 전에 난이도를 선택해주세요. 난이도는 나중에 변경할 수 있습니다.</p>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {Object.keys(DIFFICULTIES).map(key => {
                    const diff = DIFFICULTIES[key];
                    return (
                        <div key={key} className="bg-gray-700 p-6 rounded-lg border-2 border-gray-600 hover:border-green-500 transition-all flex flex-col">
                            <h3 className="text-2xl font-bold mb-3 text-white">{diff.name}</h3>
                            <p className="text-gray-300 mb-4 flex-grow">{diff.description}</p>
                            <button onClick={() => onSelect(key)} className="mt-auto w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                                {diff.name}으로 시작
                            </button>
                        </div>
                    );
                })}
            </div>
        </div>
    </div>
);

const DifficultyChangeModal = ({ currentDifficulty, onSelect, onClose }) => (
    <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
        <div className="bg-gray-900 p-8 rounded-lg shadow-2xl w-full max-w-4xl border border-gray-700 text-center relative">
            <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-white text-3xl font-bold">&times;</button>
            <h2 className="text-4xl font-bold mb-4 text-green-400">난이도 변경</h2>
            <p className="text-gray-400 mb-8">몬스터 체력과 보상에 즉시 영향을 줍니다.</p>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {Object.keys(DIFFICULTIES).map(key => {
                    const diff = DIFFICULTIES[key];
                    const isCurrent = currentDifficulty === key;
                    return (
                        <div key={key} className={`bg-gray-700 p-6 rounded-lg border-2 ${isCurrent ? 'border-green-500' : 'border-gray-600 hover:border-green-400'} transition-all flex flex-col`}>
                            <h3 className="text-2xl font-bold mb-3 text-white">{diff.name}</h3>
                            <p className="text-gray-300 mb-4 flex-grow">{diff.description}</p>
                            <button
                                onClick={() => onSelect(key)}
                                disabled={isCurrent}
                                className={`mt-auto w-full text-white font-bold py-3 px-6 rounded-lg text-lg ${isCurrent ? 'bg-gray-500 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'}`}
                            >
                                {isCurrent ? '현재 난이도' : '선택'}
                            </button>
                        </div>
                    );
                })}
            </div>
        </div>
    </div>
);

const OfflineProgressModal = ({ progress, onClaim }) => {
    if (!progress) return null;
    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
            <div className="bg-gray-900 p-6 rounded-lg shadow-2xl w-full max-w-md border border-gray-700 text-center">
                <h2 className="text-3xl font-bold mb-4 text-green-400">자리 비움 보상</h2>
                <p className="text-lg text-gray-300 mb-4">{formatTime(progress.time)} 동안 자리를 비웠습니다.</p>
                <div className="bg-gray-800 p-4 rounded-lg space-y-2">
                    <p className="text-xl flex justify-center items-center"><CoinIcon /> 획득한 골드: <span className="font-bold text-yellow-400 ml-2">{formatNumber(progress.gold)}</span></p>
                    <p className="text-xl flex justify-center items-center"><XPIcon /> 획득한 경험치: <span className="font-bold text-purple-400 ml-2">{formatNumber(progress.xp)}</span></p>
                </div>
                <button onClick={onClaim} className="mt-6 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-lg w-full">
                    보상 받기
                </button>
            </div>
        </div>
    );
};

// --- DEFAULT STATE ---
const getDefaultState = () => ({
    difficulty: null,
    playerClass: null,
    playerStats: {
        playerName: '용사',
        level: 1,
        xp: 0,
        maxXp: LEVEL_EXPERIENCE_BASE,
        coins: 0,
        clickDamage: 1,
        autoAttackDamage: 0,
        attackSpeed: 1.0,
        critChance: 0,
        critDamage: 150,
        luck: 0,
    },
    monsterStats: {
        name: MONSTER_TYPES[0].name,
        Icon: MONSTER_TYPES[0].Icon,
        level: 1,
        hp: MONSTER_HP_BASE,
        maxHp: MONSTER_HP_BASE,
        isBoss: false,
    },
    upgrades: {
        clickUpgradeCost: CLICK_UPGRADE_COST_BASE,
        clickUpgradeLevel: 1,
        autoAttackUpgradeCost: AUTO_ATTACK_UPGRADE_COST_BASE,
        autoAttackUpgradeLevel: 1,
        critChanceUpgradeCost: CRIT_CHANCE_UPGRADE_COST_BASE,
        critDamageUpgradeCost: CRIT_DAMAGE_UPGRADE_COST_BASE,
        goldGainUpgradeCost: GOLD_GAIN_UPGRADE_COST_BASE,
        xpGainUpgradeCost: XP_GAIN_UPGRADE_COST_BASE,
        skillDamageUpgradeCost: SKILL_DAMAGE_UPGRADE_COST_BASE,
        attackSpeedUpgradeCost: ATTACK_SPEED_UPGRADE_COST_BASE,
        hasteUpgradeCost: HASTE_UPGRADE_COST_BASE,
        luckUpgradeCost: LUCK_UPGRADE_COST_BASE,
        bossDamageUpgradeCost: BOSS_DAMAGE_UPGRADE_COST_BASE,
        artifactPowerUpgradeCost: ARTIFACT_POWER_UPGRADE_COST_BASE,
    },
    equipment: {
        weapon: null, armor: null, amulet: null, helmet: null, gloves: null, boots: null
    },
    gameLog: ["게임 시작! 슬라임을 처치하세요."],
    abilityStats: {
        goldGainBonus: 0,
        xpGainBonus: 0,
        haste: 0, // Skill Cooldown Reduction %
        skillDamageBonus: 0,
        bossDamageBonus: 0,
        artifactPowerBonus: 0,
    },
    liberationCount: 0,
    rebirthCount: 0,
    inventory: [],
    isAutoDropEnabled: true,
    missions: [],
    ownedArtifacts: [],
    equippedArtifacts: [],
    lastSaveTimestamp: Date.now(),
});


// --- MAIN APP ---
const App = () => {
    // State initialization with robust saved data handling
    const [difficulty, setDifficulty] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return null;
        try { return JSON.parse(saved).difficulty || 'NORMAL'; }
        catch (e) { return null; }
    });
    
    const [playerClass, setPlayerClass] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().playerClass;
        try { return JSON.parse(saved).playerClass || getDefaultState().playerClass; }
        catch (e) { return getDefaultState().playerClass; }
    });

    const [playerStats, setPlayerStats] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().playerStats;
        try { const savedGame = JSON.parse(saved); return { ...getDefaultState().playerStats, ...savedGame.playerStats }; }
        catch (e) { return getDefaultState().playerStats; }
    });

    const [monsterStats, setMonsterStats] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().monsterStats;
        try {
            const savedGame = JSON.parse(saved); const savedMonster = savedGame.monsterStats;
            if (savedMonster) {
                const monsterData = (savedMonster.isBoss ? BOSS_TYPES.find(b => b.name === savedMonster.name) : MONSTER_TYPES.find(m => m.name === savedMonster.name)) || MONSTER_TYPES[0];
                return { ...getDefaultState().monsterStats, ...savedMonster, Icon: monsterData.Icon };
            }
            return getDefaultState().monsterStats;
        } catch (e) { return getDefaultState().monsterStats; }
    });

    const [upgrades, setUpgrades] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().upgrades;
        try { const savedGame = JSON.parse(saved); return { ...getDefaultState().upgrades, ...savedGame.upgrades }; }
        catch (e) { return getDefaultState().upgrades; }
    });
    
    const [abilityStats, setAbilityStats] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().abilityStats;
        try { const savedGame = JSON.parse(saved); return { ...getDefaultState().abilityStats, ...savedGame.abilityStats }; }
        catch (e) { return getDefaultState().abilityStats; }
    });
    
    const [liberationCount, setLiberationCount] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().liberationCount;
        try { const savedGame = JSON.parse(saved); return savedGame.liberationCount || getDefaultState().liberationCount; }
        catch (e) { return getDefaultState().liberationCount; }
    });
    
    const [rebirthCount, setRebirthCount] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().rebirthCount;
        try { const savedGame = JSON.parse(saved); return savedGame.rebirthCount || getDefaultState().rebirthCount; }
        catch (e) { return getDefaultState().rebirthCount; }
    });

    const [equipment, setEquipment] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().equipment;
        try { const savedGame = JSON.parse(saved); return savedGame.equipment || getDefaultState().equipment; }
        catch (e) { return getDefaultState().equipment; }
    });
    
    const [inventory, setInventory] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().inventory;
        try { const savedGame = JSON.parse(saved); return savedGame.inventory || getDefaultState().inventory; }
        catch (e) { return getDefaultState().inventory; }
    });

    const [gameLog, setGameLog] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().gameLog;
        try { const savedGame = JSON.parse(saved); return savedGame.gameLog || getDefaultState().gameLog; }
        catch (e) { return getDefaultState().gameLog; }
    });
    
    const [isAutoDropEnabled, setIsAutoDropEnabled] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return getDefaultState().isAutoDropEnabled;
        try {
            const savedGame = JSON.parse(saved);
            return savedGame.isAutoDropEnabled !== undefined ? savedGame.isAutoDropEnabled : getDefaultState().isAutoDropEnabled;
        } catch (e) { return getDefaultState().isAutoDropEnabled; }
    });

    const [missions, setMissions] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return [];
        try { const savedGame = JSON.parse(saved); return savedGame.missions || []; }
        catch(e) { return []; }
    });

    const [ownedArtifacts, setOwnedArtifacts] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return [];
        try { return JSON.parse(saved).ownedArtifacts || []; }
        catch(e) { return []; }
    });

    const [equippedArtifacts, setEquippedArtifacts] = useState(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (!saved) return [];
        try { return JSON.parse(saved).equippedArtifacts || []; }
        catch(e) { return []; }
    });


    // UI State
    const [activeTab, setActiveTab] = useState('upgrade');
    const [selectedForgeItem, setSelectedForgeItem] = useState(null);
    const [isJobSelectionOpen, setIsJobSelectionOpen] = useState(false);
    const [selectedInventoryItem, setSelectedInventoryItem] = useState(null);
    const [isDifficultyModalOpen, setIsDifficultyModalOpen] = useState(false);
    const [isSellMode, setIsSellMode] = useState(false);
    const [sellList, setSellList] = useState(new Set());
    const [offlineProgress, setOfflineProgress] = useState(null);

    const [activeSkillCooldown, setActiveSkillCooldown] = useState(0);
    const [damagePopups, setDamagePopups] = useState([]);
    const [newItemDrop, setNewItemDrop] = useState(null);
    const [frenzyActive, setFrenzyActive] = useState(false);
    const [arrowRainActive, setArrowRainActive] = useState(false);
    const [arcaneBlastDebuff, setArcaneBlastDebuff] = useState(false);
    const [treasureGolem, setTreasureGolem] = useState({ isActive: false, timer: 0 });
    const needsSave = useRef(false);

    const difficultyMultipliers = useMemo(() => {
        return difficulty ? DIFFICULTIES[difficulty].multipliers : DIFFICULTIES.NORMAL.multipliers;
    }, [difficulty]);
    
    const addLog = useCallback((message) => { setGameLog(prevLog => [message, ...prevLog.slice(0, 19)]); }, []);

    const updateMissionProgress = useCallback((type, amount) => {
        setMissions(prevMissions => {
            let changed = false;
            const newMissions = prevMissions.map(mission => {
                if (mission.type === type && !mission.isCompleted) {
                    const newProgress = Math.min(mission.target, mission.progress + amount);
                    if (newProgress !== mission.progress) {
                        changed = true;
                        const isCompleted = newProgress >= mission.target;
                        if (isCompleted && !mission.isCompleted) {
                            addLog(`<strong class="text-teal-400">임무 완료:</strong> ${MISSION_TYPES[mission.type]}!`);
                        }
                        return { ...mission, progress: newProgress, isCompleted };
                    }
                }
                return mission;
            });
            if (changed) {
                needsSave.current = true;
                return newMissions;
            }
            return prevMissions;
        });
    }, [addLog]);

    const artifactBonuses = useMemo(() => {
        const bonuses = { goldGain: 0, xpGain: 0, bossDamage: 0, haste: 0, critChance: 0, critDamage: 0, clickDamageMult: 0, attackSpeedMult: 0 };
        const powerMultiplier = 1 + (abilityStats.artifactPowerBonus / 100);

        equippedArtifacts.forEach(id => {
            const artifact = ARTIFACTS.find(a => a.id === id);
            if (!artifact) return;
            switch(artifact.effect.type) {
                case 'GOLD_GAIN': bonuses.goldGain += artifact.effect.value * powerMultiplier; break;
                case 'XP_GAIN': bonuses.xpGain += artifact.effect.value * powerMultiplier; break;
                case 'BOSS_DAMAGE': bonuses.bossDamage += artifact.effect.value * powerMultiplier; break;
                case 'HASTE': bonuses.haste += artifact.effect.value * powerMultiplier; break;
                case 'CRIT_CHANCE': bonuses.critChance += artifact.effect.value * powerMultiplier; break;
                case 'CRIT_DAMAGE': bonuses.critDamage += artifact.effect.value * powerMultiplier; break;
                case 'CLICK_DAMAGE_MULT': bonuses.clickDamageMult += artifact.effect.value * powerMultiplier; break;
                case 'ATTACK_SPEED_MULT': bonuses.attackSpeedMult += artifact.effect.value * powerMultiplier; break;
            }
        });
        return bonuses;
    }, [equippedArtifacts, abilityStats.artifactPowerBonus]);

    const finalAbilityStats = useMemo(() => {
        let haste = abilityStats.haste;
        let skillDamage = abilityStats.skillDamageBonus;
        if (playerClass === 'MAGE') {
            haste *= 1.25;
            skillDamage *= (1 + JOBS.MAGE.bonuses.skillEffect);
        }
        
        const rebirthBonus = rebirthCount * REBIRTH_ALL_STAT_BONUS;
        
        let hasteFromItems = 0;
        let goldBonusFromItems = 0;
        let xpBonusFromItems = 0;

        Object.values(equipment).forEach(item => {
            if (!item) return;
            const enhancedStats = getEnhancedItemStats(item);
            hasteFromItems += enhancedStats.hasteBonus || 0;
            goldBonusFromItems += enhancedStats.goldGainBonus || 0;
            xpBonusFromItems += enhancedStats.xpGainBonus || 0;
        });

        return {
            ...abilityStats,
            luck: playerStats.luck,
            goldGainBonus: abilityStats.goldGainBonus + rebirthBonus + artifactBonuses.goldGain + goldBonusFromItems,
            xpGainBonus: abilityStats.xpGainBonus + rebirthBonus + artifactBonuses.xpGain + xpBonusFromItems,
            bossDamageBonus: abilityStats.bossDamageBonus + rebirthBonus + artifactBonuses.bossDamage,
            haste: haste + artifactBonuses.haste + hasteFromItems,
            skillDamageBonus: skillDamage,
            activeSkillCooldown: BASE_SKILL_COOLDOWN * (1 - (haste + artifactBonuses.haste + hasteFromItems) / 100),
        }
    }, [abilityStats, playerClass, rebirthCount, artifactBonuses, equipment, playerStats.luck]);

    const finalStats = useMemo(() => {
        let combined = { ...playerStats };
        let attackSpeedBonusFromItems = 0;

        Object.values(equipment).forEach(item => {
            if (!item) return;
            const enhancedStats = getEnhancedItemStats(item);
            
            combined.clickDamage += enhancedStats.clickDamage || 0;
            combined.autoAttackDamage += enhancedStats.autoAttackDamage || 0;
            combined.critChance += enhancedStats.critChance || 0;
            combined.critDamage += enhancedStats.critDamage || 0;
            attackSpeedBonusFromItems += enhancedStats.attackSpeedBonus || 0;
        });

        if (playerClass && JOBS[playerClass]) {
            const bonuses = JOBS[playerClass].bonuses;
            combined.clickDamage *= (1 + bonuses.clickDamage);
            combined.autoAttackDamage *= (1 + bonuses.autoAttackDamage);
            combined.critChance += bonuses.critChance;
            combined.critDamage += bonuses.critDamage;
        }

        const rebirthMultiplier = 1 + (rebirthCount * REBIRTH_ALL_STAT_BONUS / 100);
        combined.clickDamage *= rebirthMultiplier;
        combined.autoAttackDamage *= rebirthMultiplier;

        combined.critChance += artifactBonuses.critChance;
        combined.critDamage += artifactBonuses.critDamage;
        combined.clickDamage *= (1 + artifactBonuses.clickDamageMult);
        combined.attackSpeed = playerStats.attackSpeed * (1 + artifactBonuses.attackSpeedMult + attackSpeedBonusFromItems / 100);

        if (frenzyActive) {
            combined.clickDamage *= 2;
            combined.autoAttackDamage *= 1.5;
        }
        if (arrowRainActive) {
            combined.critChance = Math.min(100, combined.critChance + 25);
        }

        return combined;
    }, [playerStats, equipment, playerClass, frenzyActive, arrowRainActive, rebirthCount, artifactBonuses]);
    
    const saveGame = useCallback(() => {
        try {
            const serializableMonsterStats = { ...monsterStats, Icon: undefined };
            const gameStateToSave = {
                difficulty, playerClass, playerStats, monsterStats: serializableMonsterStats,
                upgrades, equipment, gameLog, abilityStats, liberationCount, rebirthCount,
                inventory, isAutoDropEnabled, missions, ownedArtifacts, equippedArtifacts,
                lastSaveTimestamp: Date.now()
            };
            localStorage.setItem(SAVED_GAME_KEY, JSON.stringify(gameStateToSave));
            needsSave.current = false;
        } catch (error) { console.error("Could not save game state", error); }
    }, [difficulty, playerClass, playerStats, monsterStats, upgrades, equipment, gameLog, abilityStats, liberationCount, rebirthCount, inventory, isAutoDropEnabled, missions, ownedArtifacts, equippedArtifacts]);

    useEffect(() => { if (needsSave.current) { saveGame(); } });

    const generateMission = useCallback((playerLevel) => {
        const missionKeys = Object.keys(MISSION_TYPES);
        const type = missionKeys[Math.floor(Math.random() * missionKeys.length)];
        let target = 0;
        let reward = 0;
        const baseReward = 50 + playerLevel * 20;

        switch (type) {
            case 'DEFEAT_MONSTERS':
                target = 20 + Math.floor(playerLevel * 5 * (1 + Math.random() * 0.2));
                reward = Math.floor(baseReward * target * 0.8);
                break;
            case 'DEFEAT_BOSSES':
                target = 1 + Math.floor(playerLevel / 20);
                reward = Math.floor(baseReward * target * 50);
                break;
            case 'UPGRADE_TIMES':
                target = 15 + Math.floor(playerLevel * 2 * (1 + Math.random() * 0.2));
                reward = Math.floor(baseReward * target * 0.6);
                break;
            case 'EARN_GOLD':
                target = 1000 + Math.floor(Math.pow(playerLevel, 2) * 100 * (1 + Math.random()));
                reward = Math.floor(target * 0.1);
                break;
        }

        return {
            id: Date.now() + Math.random(),
            type,
            target: Math.ceil(target),
            progress: 0,
            reward: Math.ceil(reward),
            isCompleted: false,
        };
    }, []);

    useEffect(() => {
        if (difficulty && missions.length < 3) {
            setMissions(prev => {
                const newMissions = [...prev];
                while (newMissions.length < 3) {
                    newMissions.push(generateMission(playerStats.level));
                }
                return newMissions;
            });
        }
    }, [difficulty, playerStats.level, missions.length, generateMission]);

    useEffect(() => {
        const saved = localStorage.getItem(SAVED_GAME_KEY);
        if (saved) {
            try {
                const savedGame = JSON.parse(saved);
                const lastSave = savedGame.lastSaveTimestamp || Date.now();
                const offlineTimeSeconds = Math.min(8 * 3600, (Date.now() - lastSave) / 1000); // Max 8 hours

                if (offlineTimeSeconds > 60) {
                    const pLevel = savedGame.playerStats.level || 1;
                    const goldBonus = (savedGame.abilityStats.goldGainBonus || 0) + ((savedGame.rebirthCount || 0) * REBIRTH_ALL_STAT_BONUS);
                    const xpBonus = (savedGame.abilityStats.xpGainBonus || 0) + ((savedGame.rebirthCount || 0) * REBIRTH_ALL_STAT_BONUS);
                    
                    const autoDps = (savedGame.playerStats.autoAttackDamage || 0) * (savedGame.playerStats.attackSpeed || 1);
                    let goldEarned = 0;
                    let xpEarned = 0;

                    if (autoDps > 0) {
                         const monsterHp = MONSTER_HP_BASE * Math.pow(MONSTER_HP_MULTIPLIER, pLevel - 1);
                         const timeToKill = monsterHp > 0 ? monsterHp / autoDps : Infinity;
                         const monstersPerSec = timeToKill > 0 ? 1 / timeToKill : 0;

                         const baseMonsterGold = MONSTER_REWARD_BASE * Math.pow(MONSTER_REWARD_MULTIPLIER, pLevel - 1);
                         const baseMonsterXp = pLevel * 2.5;

                         const goldPerSec = monstersPerSec * baseMonsterGold * 0.25; // 25% efficiency
                         const xpPerSec = monstersPerSec * baseMonsterXp * 0.25;
                         
                         goldEarned = Math.floor(goldPerSec * offlineTimeSeconds * (1 + goldBonus / 100));
                         xpEarned = Math.floor(xpPerSec * offlineTimeSeconds * (1 + xpBonus / 100));
                    }
                    
                    if (goldEarned > 0 || xpEarned > 0) {
                        setOfflineProgress({ time: offlineTimeSeconds, gold: goldEarned, xp: xpEarned });
                    }
                }
            } catch (e) { console.error("Error calculating offline progress:", e); }
        }
        const saveInterval = setInterval(() => { needsSave.current = true; }, 5000);
        return () => clearInterval(saveInterval);
    }, []);

    const handleSelectDifficulty = (selectedDiff) => {
        const multipliers = DIFFICULTIES[selectedDiff].multipliers;
        const initialUpgrades = { ...getDefaultState().upgrades };
        for (const key in initialUpgrades) {
            if (key.endsWith('Cost')) {
                initialUpgrades[key] = Math.floor(initialUpgrades[key] * multipliers.upgradeCost);
            }
        }
        setUpgrades(initialUpgrades);
        setDifficulty(selectedDiff);
        needsSave.current = true;
    };

    const handleChangeDifficulty = (newDifficulty) => {
        if (difficulty === newDifficulty) {
            setIsDifficultyModalOpen(false);
            return;
        }

        const oldMultipliers = DIFFICULTIES[difficulty].multipliers;
        const newMultipliers = DIFFICULTIES[newDifficulty].multipliers;

        setMonsterStats(prev => {
            const hpRatio = prev.hp / prev.maxHp;
            const newMaxHp = prev.maxHp / oldMultipliers.monsterHp * newMultipliers.monsterHp;
            const newHp = newMaxHp * hpRatio;
            return { ...prev, hp: Math.floor(newHp), maxHp: Math.floor(newMaxHp) };
        });

        setDifficulty(newDifficulty);
        addLog(`<strong class="text-cyan-400">난이도를 '${DIFFICULTIES[newDifficulty].name}'(으)로 변경했습니다.</strong>`);
        setIsDifficultyModalOpen(false);
        needsSave.current = true;
    };
    
    const handleJobSelect = (jobKey) => {
        if (playerClass) {
            addLog(`<strong class="text-amber-400">직업을 ${JOBS[jobKey].name}(으)로 변경했습니다!</strong>`);
        } else {
            addLog(`<strong class="text-amber-400">당신은 이제 ${JOBS[jobKey].name}입니다!</strong>`);
        }
        setPlayerClass(jobKey);
        setIsJobSelectionOpen(false);
        needsSave.current = true;
    };

    const generateRandomItem = useCallback((monsterLevel) => {
        const luckFactor = 1 + (finalStats.luck / 200);
        const rarityRoll = Math.random() / luckFactor;
        let rarityKey = 'COMMON';
        if (rarityRoll < 0.005) rarityKey = 'MYTHIC';
        else if (rarityRoll < 0.02) rarityKey = 'LEGENDARY';
        else if (rarityRoll < 0.10) rarityKey = 'EPIC';
        else if (rarityRoll < 0.30) rarityKey = 'RARE';
        else if (rarityRoll < 0.60) rarityKey = 'UNCOMMON';
    
        const typeKeys = Object.keys(EQUIPMENT_TYPES);
        const typeKey = typeKeys[Math.floor(Math.random() * typeKeys.length)];
    
        const rarity = RARITIES[rarityKey];
        const item = {
            id: Date.now() + Math.random(), type: typeKey, rarity: rarityKey, name: `${rarity.name} ${EQUIPMENT_TYPES[typeKey].name}`,
            level: 0,
            baseLevel: monsterLevel,
            stats: {}
        };
        item.stats = calculateItemStats(item.baseLevel, item.rarity, item.type);
        return item;
    }, [finalStats.luck]);

    const handleMonsterDefeat = useCallback(() => {
        if (treasureGolem.isActive) {
            const goldReward = Math.floor(monsterStats.maxHp * 5 * (1 + finalAbilityStats.goldGainBonus / 100));
            addLog(`<strong class="text-yellow-400">보물 골렘 처치! +${formatNumber(goldReward)} 골드!</strong>`);
            setPlayerStats(prev => ({ ...prev, coins: prev.coins + goldReward }));
            setTreasureGolem({ isActive: false, timer: 0 });
        } else {
            const isBossDefeated = monsterStats.isBoss;
            const currentMonsterLevel = monsterStats.level;
            const rewardMultiplier = (isBossDefeated ? BOSS_REWARD_MULTIPLIER : 1) * difficultyMultipliers.monsterReward;
            const xpGained = Math.ceil(currentMonsterLevel * 2.5 * rewardMultiplier * (1 + finalAbilityStats.xpGainBonus / 100));
            const coinsGained = Math.ceil(MONSTER_REWARD_BASE * Math.pow(MONSTER_REWARD_MULTIPLIER, currentMonsterLevel - 1) * rewardMultiplier * (1 + finalAbilityStats.goldGainBonus / 100));
            
            addLog(`${isBossDefeated ? `<strong>[BOSS]</strong> ` : ''}${monsterStats.name}(Lv.${currentMonsterLevel}) 처치! +${formatNumber(coinsGained)} 골드, +${formatNumber(xpGained)} 경험치.`);
            updateMissionProgress('EARN_GOLD', coinsGained);
            updateMissionProgress(isBossDefeated ? 'DEFEAT_BOSSES' : 'DEFEAT_MONSTERS', 1);

            const dropChance = EQUIPMENT_DROP_CHANCE_BASE + (currentMonsterLevel * 0.005) + (isBossDefeated ? BOSS_DROP_CHANCE_BOOST : 0) + (finalStats.luck / 100);
            if (Math.random() < dropChance && !newItemDrop) {
                const droppedItem = generateRandomItem(currentMonsterLevel);
                if (isAutoDropEnabled) {
                    const rarityInfo = RARITIES[droppedItem.rarity];
                    const itemLevel = droppedItem.level || 0;
                    const goldGained = Math.ceil(rarityInfo.statMultiplier * 25 * Math.pow(1.3, itemLevel) * (droppedItem.baseLevel || 1));
                    setPlayerStats(prev => ({...prev, coins: prev.coins + goldGained}));
                    addLog(`<span class="${rarityInfo.textClass}">[${rarityInfo.name}] ${droppedItem.name}</span> 획득 후 자동 판매! +<strong class="text-yellow-400">${formatNumber(goldGained)}</strong> 골드`);
                } else {
                    const rarityInfo = RARITIES[droppedItem.rarity];
                    addLog(`<span class="${rarityInfo.textClass}">[${rarityInfo.name}] ${droppedItem.name}</span> 획득!`);
                    setNewItemDrop(droppedItem);
                }
            }

            setPlayerStats(prev => {
                let newXp = prev.xp + xpGained; let newLevel = prev.level; let newMaxXp = prev.maxXp;
                let newClickDamage = prev.clickDamage; let newAutoAttackDamage = prev.autoAttackDamage;

                while (newXp >= newMaxXp) {
                    newXp -= newMaxXp; newLevel += 1;
                    newMaxXp = Math.floor(LEVEL_EXPERIENCE_BASE * Math.pow(LEVEL_EXPERIENCE_MULTIPLIER, newLevel - 1));
                    addLog(`레벨업! ${newLevel}레벨 달성!`);
                    newClickDamage *= 1.01; newAutoAttackDamage *= 1.01;
                    addLog(`<span class="text-yellow-300">레벨업 보너스! 기본 공격력이 1% 증가했습니다!</span>`);
                }
                return { ...prev, level: newLevel, xp: newXp, maxXp: newMaxXp, coins: prev.coins + coinsGained, clickDamage: newClickDamage, autoAttackDamage: newAutoAttackDamage };
            });
        }
        
        const newMonsterLevel = monsterStats.level + (treasureGolem.isActive ? 0 : 1);
        if (Math.random() < TREASURE_GOLEM_SPAWN_CHANCE) {
            const hp = Math.floor(MONSTER_HP_BASE * Math.pow(MONSTER_HP_MULTIPLIER, newMonsterLevel - 1) * 10 * difficultyMultipliers.monsterHp);
            setMonsterStats({ ...SPECIAL_MONSTERS.TREASURE_GOLEM, level: newMonsterLevel, hp, maxHp: hp, isBoss: false });
            setTreasureGolem({ isActive: true, timer: TREASURE_GOLEM_TIMER });
        } else {
            let nextMonster;
            if (newMonsterLevel > 0 && newMonsterLevel % BOSS_LEVEL_INTERVAL === 0) {
                const bossIndex = Math.floor((newMonsterLevel / BOSS_LEVEL_INTERVAL - 1)) % BOSS_TYPES.length;
                const bossData = BOSS_TYPES[bossIndex];
                const newMonsterHp = Math.floor(MONSTER_HP_BASE * Math.pow(MONSTER_HP_MULTIPLIER, newMonsterLevel - 1) * BOSS_HP_MULTIPLIER * difficultyMultipliers.monsterHp);
                nextMonster = { name: bossData.name, Icon: bossData.Icon, level: newMonsterLevel, hp: newMonsterHp, maxHp: newMonsterHp, isBoss: true };
            } else {
                const availableMonsters = MONSTER_TYPES.filter(m => newMonsterLevel >= m.minLevel);
                const monsterData = availableMonsters.length > 0 ? availableMonsters[Math.floor(Math.random() * availableMonsters.length)] : MONSTER_TYPES[0];
                const newMonsterHp = Math.floor(MONSTER_HP_BASE * Math.pow(MONSTER_HP_MULTIPLIER, newMonsterLevel - 1) * difficultyMultipliers.monsterHp);
                nextMonster = { name: monsterData.name, Icon: monsterData.Icon, level: newMonsterLevel, hp: newMonsterHp, maxHp: newMonsterHp, isBoss: false };
            }
            setMonsterStats(nextMonster);
        }
        needsSave.current = true;
    }, [monsterStats, addLog, generateRandomItem, newItemDrop, finalAbilityStats, finalStats.luck, difficultyMultipliers, isAutoDropEnabled, updateMissionProgress, ownedArtifacts, treasureGolem.isActive]);
    
    useEffect(() => {
        if (finalStats.autoAttackDamage <= 0) return;
        const interval = setInterval(() => {
            if (newItemDrop || isJobSelectionOpen || selectedInventoryItem || !difficulty || offlineProgress || treasureGolem.isActive) return;
            const debuffMultiplier = arcaneBlastDebuff ? 1.2 : 1;
            const isCrit = Math.random() * 100 < finalStats.critChance;
            const critMultiplier = isCrit ? finalStats.critDamage / 100 : 1;
            const bossMultiplier = monsterStats.isBoss ? (1 + finalAbilityStats.bossDamageBonus / 100) : 1;
            const damageDealt = Math.floor(finalStats.autoAttackDamage * critMultiplier * bossMultiplier * debuffMultiplier);

            setMonsterStats(prev => {
                const newHp = prev.hp - damageDealt;
                if (newHp <= 0) { handleMonsterDefeat(); return { ...prev, hp: 0 }; }
                return { ...prev, hp: newHp };
            });
        }, 1000 / finalStats.attackSpeed);
        return () => clearInterval(interval);
    }, [finalStats, handleMonsterDefeat, newItemDrop, isJobSelectionOpen, selectedInventoryItem, monsterStats.isBoss, finalAbilityStats, difficulty, arcaneBlastDebuff, offlineProgress, treasureGolem.isActive]);
    
    useEffect(() => {
        if (activeSkillCooldown > 0) {
            const timer = setTimeout(() => { setActiveSkillCooldown(prev => Math.max(0, prev - 100)); }, 100);
            return () => clearTimeout(timer);
        }
    }, [activeSkillCooldown]);

    useEffect(() => {
        if (treasureGolem.isActive && treasureGolem.timer > 0) {
            const timer = setTimeout(() => setTreasureGolem(prev => ({ ...prev, timer: prev.timer - 1 })), 1000);
            return () => clearTimeout(timer);
        } else if (treasureGolem.isActive && treasureGolem.timer <= 0) {
            addLog(`<strong class="text-yellow-600">보물 골렘이 도망쳤습니다!</strong>`);
            setTreasureGolem({ isActive: false, timer: 0 });
            // Spawn a normal monster
            const newMonsterLevel = monsterStats.level;
            const monsterData = MONSTER_TYPES[Math.floor(Math.random() * MONSTER_TYPES.length)];
            const newMonsterHp = Math.floor(MONSTER_HP_BASE * Math.pow(MONSTER_HP_MULTIPLIER, newMonsterLevel - 1) * difficultyMultipliers.monsterHp);
            setMonsterStats({ name: monsterData.name, Icon: monsterData.Icon, level: newMonsterLevel, hp: newMonsterHp, maxHp: newMonsterHp, isBoss: false });
        }
    }, [treasureGolem, addLog, monsterStats.level, difficultyMultipliers]);
    
    const createDamagePopup = (damage, type = 'normal') => {
        const newPopup = { id: Date.now() + Math.random(), damage, x: 40 + Math.random() * 20, y: 40 + Math.random() * 20, type };
        setDamagePopups(prev => [...prev, newPopup]);
        setTimeout(() => { setDamagePopups(prev => prev.filter(p => p.id !== newPopup.id)); }, 1000);
    };

    const handleMonsterClick = () => {
        if (monsterStats.hp <= 0 || newItemDrop || isJobSelectionOpen || selectedInventoryItem) return;
        
        const bossMultiplier = monsterStats.isBoss ? (1 + finalAbilityStats.bossDamageBonus / 100) : 1;
        const debuffMultiplier = arcaneBlastDebuff ? 1.2 : 1;
        
        const isCrit = Math.random() * 100 < finalStats.critChance;
        const critMultiplier = isCrit ? finalStats.critDamage / 100 : 1;
        const damageDealt = Math.floor(finalStats.clickDamage * critMultiplier * bossMultiplier * debuffMultiplier);
        createDamagePopup(damageDealt, isCrit ? 'crit' : 'normal');
        setMonsterStats(prev => {
            const newHp = prev.hp - damageDealt;
            if (newHp <= 0) { handleMonsterDefeat(); return { ...prev, hp: 0 }; }
            return { ...prev, hp: newHp };
        });
    };
    
    const handleUpgrade = (cost, onUpgrade) => {
        if (playerStats.coins >= cost) {
            setPlayerStats(prev => ({ ...prev, coins: prev.coins - cost }));
            updateMissionProgress('UPGRADE_TIMES', 1);
            onUpgrade();
            needsSave.current = true;
        }
    }
    const handleUpgradeClick = () => handleUpgrade(upgrades.clickUpgradeCost, () => {
        setPlayerStats(prev => ({ ...prev, clickDamage: prev.clickDamage + upgrades.clickUpgradeLevel }));
        setUpgrades(prev => ({ ...prev, clickUpgradeCost: Math.floor(prev.clickUpgradeCost * CLICK_UPGRADE_COST_MULTIPLIER), clickUpgradeLevel: prev.clickUpgradeLevel + 1 }));
    });
    const handleUpgradeAutoAttack = () => handleUpgrade(upgrades.autoAttackUpgradeCost, () => {
        setPlayerStats(prev => ({ ...prev, autoAttackDamage: prev.autoAttackDamage + upgrades.autoAttackUpgradeLevel }));
        setUpgrades(prev => ({ ...prev, autoAttackUpgradeCost: Math.floor(prev.autoAttackUpgradeCost * AUTO_ATTACK_UPGRADE_COST_MULTIPLIER), autoAttackUpgradeLevel: prev.autoAttackUpgradeLevel + 1 }));
    });
    const handleUpgradeAttackSpeed = () => handleUpgrade(upgrades.attackSpeedUpgradeCost, () => {
        setPlayerStats(prev => ({ ...prev, attackSpeed: prev.attackSpeed + 0.1 }));
        setUpgrades(prev => ({ ...prev, attackSpeedUpgradeCost: Math.floor(prev.attackSpeedUpgradeCost * ATTACK_SPEED_UPGRADE_COST_MULTIPLIER)}));
    });
    const handleUpgradeCritChance = () => handleUpgrade(upgrades.critChanceUpgradeCost, () => {
        setPlayerStats(prev => ({ ...prev, critChance: prev.critChance + CRIT_CHANCE_UPGRADE_INCREASE }));
        setUpgrades(prev => ({ ...prev, critChanceUpgradeCost: Math.floor(prev.critChanceUpgradeCost * CRIT_CHANCE_UPGRADE_COST_MULTIPLIER) }));
    });
    const handleUpgradeCritDamage = () => handleUpgrade(upgrades.critDamageUpgradeCost, () => {
        setPlayerStats(prev => ({ ...prev, critDamage: prev.critDamage + CRIT_DAMAGE_UPGRADE_INCREASE }));
        setUpgrades(prev => ({ ...prev, critDamageUpgradeCost: Math.floor(prev.critDamageUpgradeCost * CRIT_DAMAGE_UPGRADE_COST_MULTIPLIER) }));
    });
    const handleUpgradeGoldGain = () => handleUpgrade(upgrades.goldGainUpgradeCost, () => {
        setAbilityStats(prev => ({ ...prev, goldGainBonus: prev.goldGainBonus + 5 }));
        setUpgrades(prev => ({ ...prev, goldGainUpgradeCost: Math.floor(prev.goldGainUpgradeCost * GOLD_GAIN_UPGRADE_COST_MULTIPLIER) }));
    });
    const handleUpgradeXpGain = () => handleUpgrade(upgrades.xpGainUpgradeCost, () => {
        setAbilityStats(prev => ({ ...prev, xpGainBonus: prev.xpGainBonus + 5 }));
        setUpgrades(prev => ({ ...prev, xpGainUpgradeCost: Math.floor(prev.xpGainUpgradeCost * XP_GAIN_UPGRADE_COST_MULTIPLIER) }));
    });
    const handleUpgradeSkillDamage = () => handleUpgrade(upgrades.skillDamageUpgradeCost, () => {
        setAbilityStats(prev => ({ ...prev, skillDamageBonus: prev.skillDamageBonus + 10 }));
        setUpgrades(prev => ({ ...prev, skillDamageUpgradeCost: Math.floor(prev.skillDamageUpgradeCost * SKILL_DAMAGE_UPGRADE_COST_MULTIPLIER) }));
    });
    const handleUpgradeHaste = () => handleUpgrade(upgrades.hasteUpgradeCost, () => {
        setAbilityStats(prev => ({ ...prev, haste: prev.haste + 1 }));
        setUpgrades(prev => ({ ...prev, hasteUpgradeCost: Math.floor(prev.hasteUpgradeCost * HASTE_UPGRADE_COST_MULTIPLIER) }));
    });
    const handleUpgradeLuck = () => handleUpgrade(upgrades.luckUpgradeCost, () => {
        setPlayerStats(prev => ({ ...prev, luck: prev.luck + 1 }));
        setUpgrades(prev => ({ ...prev, luckUpgradeCost: Math.floor(prev.luckUpgradeCost * LUCK_UPGRADE_COST_MULTIPLIER) }));
    });
    const handleUpgradeBossDamage = () => handleUpgrade(upgrades.bossDamageUpgradeCost, () => {
        setAbilityStats(prev => ({ ...prev, bossDamageBonus: prev.bossDamageBonus + 2 }));
        setUpgrades(prev => ({ ...prev, bossDamageUpgradeCost: Math.floor(prev.bossDamageUpgradeCost * BOSS_DAMAGE_UPGRADE_COST_MULTIPLIER) }));
    });
     const handleUpgradeArtifactPower = () => handleUpgrade(upgrades.artifactPowerUpgradeCost, () => {
        setAbilityStats(prev => ({ ...prev, artifactPowerBonus: prev.artifactPowerBonus + 1 }));
        setUpgrades(prev => ({ ...prev, artifactPowerUpgradeCost: Math.floor(prev.artifactPowerUpgradeCost * ARTIFACT_POWER_UPGRADE_COST_MULTIPLIER) }));
    });

    const handleActiveSkill = () => {
        if (activeSkillCooldown > 0 || newItemDrop || !playerClass) return;
        
        let damageDealt = 0;
        let logMessage = '';
        const skillMultiplier = 1 + (finalAbilityStats.skillDamageBonus / 100);
        const bossMultiplier = monsterStats.isBoss ? (1 + finalAbilityStats.bossDamageBonus / 100) : 1;
        const debuffMultiplier = arcaneBlastDebuff ? 1.2 : 1;

        switch(playerClass) {
            case 'WARRIOR':
                setFrenzyActive(true);
                setTimeout(() => setFrenzyActive(false), 8000);
                logMessage = `광란 발동! 8초간 공격이 강화됩니다!`;
                break;
            case 'ARCHER':
                damageDealt = Math.floor(finalStats.clickDamage * 3 * skillMultiplier * bossMultiplier * debuffMultiplier);
                createDamagePopup(damageDealt, 'skill');
                setArrowRainActive(true);
                setTimeout(() => setArrowRainActive(false), 5000);
                logMessage = `화살비! 즉시 ${formatNumber(damageDealt)}의 피해를 주고 5초간 크리티컬 확률이 증가합니다!`;
                break;
            case 'MAGE':
                damageDealt = Math.floor((finalStats.autoAttackDamage + finalStats.clickDamage) * 15 * skillMultiplier * bossMultiplier * debuffMultiplier);
                createDamagePopup(damageDealt, 'skill');
                setArcaneBlastDebuff(true);
                setTimeout(() => setArcaneBlastDebuff(false), 10000);
                logMessage = `신비한 폭발! ${formatNumber(damageDealt)}의 피해를 주고 10초간 적을 약화시킵니다!`;
                break;
        }

        addLog(logMessage);
        setActiveSkillCooldown(finalAbilityStats.activeSkillCooldown);

        if(damageDealt > 0) {
            setMonsterStats(prev => {
                const newHp = prev.hp - damageDealt;
                if (newHp <= 0) { handleMonsterDefeat(); return { ...prev, hp: 0 }; }
                return { ...prev, hp: newHp };
            });
        }
        needsSave.current = true;
    };
    
    const handleLiberation = () => {
        const cost = liberationCost;
        if (playerStats.coins >= cost) {
            setPlayerStats(prev => ({
                ...prev, coins: prev.coins - cost, clickDamage: prev.clickDamage * 2,
                autoAttackDamage: prev.autoAttackDamage * 2, critChance: prev.critChance * 2, critDamage: prev.critDamage * 2,
            }));
            const newLiberationCount = liberationCount + 1;
            setLiberationCount(newLiberationCount);
            addLog(`<strong class="text-yellow-300">해방! 모든 기본 능력치가 2배가 되었습니다! (단계: ${newLiberationCount})</strong>`);
            needsSave.current = true;
        }
    }
    
    const handleRebirth = useCallback(() => {
        if (playerStats.level < REBIRTH_LEVEL_REQUIREMENT) return;
        if (window.confirm(`환생하시겠습니까?\n\n- 레벨, 골드, 업그레이드가 초기화됩니다.\n- 장비, 인벤토리, 유물, 해방 단계는 유지됩니다.\n- 영구적으로 모든 능력치가 ${REBIRTH_ALL_STAT_BONUS}% 증가합니다.\n\n이 작업은 되돌릴 수 없습니다!`)) {
            const newRebirthCount = rebirthCount + 1;
            setRebirthCount(newRebirthCount);
            
            const defaultPlayerState = getDefaultState().playerStats;
            setPlayerStats(prev => ({
                ...defaultPlayerState,
                playerName: prev.playerName,
            }));
            
            const multipliers = difficulty ? DIFFICULTIES[difficulty].multipliers : DIFFICULTIES.NORMAL.multipliers;
            const initialUpgrades = { ...getDefaultState().upgrades };
            for (const key in initialUpgrades) {
                if (key.endsWith('Cost')) {
                    initialUpgrades[key] = Math.floor(initialUpgrades[key] * multipliers.upgradeCost);
                }
            }
            setUpgrades(initialUpgrades);

            setAbilityStats(getDefaultState().abilityStats);
            setMonsterStats(getDefaultState().monsterStats);
            
            addLog(`<strong class="text-purple-400">환생 ${newRebirthCount}회차! 새로운 여정이 시작됩니다. (영구 보너스: +${newRebirthCount * REBIRTH_ALL_STAT_BONUS}%)</strong>`);
            needsSave.current = true;
        }
    }, [playerStats.level, rebirthCount, addLog, difficulty]);

    const handlePlayerNameChange = (newName) => { setPlayerStats(prev => ({...prev, playerName: newName})); needsSave.current = true; };

    const handleEquipmentGacha = () => {
        if (playerStats.coins >= equipmentGachaCost && !newItemDrop) {
            setPlayerStats(prev => ({ ...prev, coins: prev.coins - equipmentGachaCost }));
            const droppedItem = generateRandomItem(playerStats.level);
            const rarityInfo = RARITIES[droppedItem.rarity];
            addLog(`장비 뽑기! <span class="${rarityInfo.textClass}">[${rarityInfo.name}] ${droppedItem.name}</span> 획득!`);
            setNewItemDrop(droppedItem);
            needsSave.current = true;
        }
    };
    
    const handleEquipItem = useCallback((itemToEquip) => {
        if (!itemToEquip) return;
        const itemTypeKey = itemToEquip.type.toLowerCase();
        const currentEquippedItem = equipment[itemTypeKey];
        
        let newInventory = inventory.filter(i => i.id !== itemToEquip.id);
        if (currentEquippedItem) {
            newInventory.push(currentEquippedItem);
        }
        
        setInventory(newInventory);
        setEquipment(prev => ({ ...prev, [itemTypeKey]: itemToEquip }));
        
        if (newItemDrop && newItemDrop.id === itemToEquip.id) {
            setNewItemDrop(null);
        }
        needsSave.current = true;
    }, [equipment, inventory, newItemDrop]);
    
    const handleStoreNewItem = () => {
        if (!newItemDrop) return;
        setInventory(prev => [...prev, newItemDrop]);
        addLog(`[${newItemDrop.name}] 아이템을 인벤토리에 보관했습니다.`);
        setNewItemDrop(null);
        needsSave.current = true;
    };
    
    const handleSellItem = useCallback((itemToSell) => {
        if (!itemToSell || !window.confirm(`[${itemToSell.name}] 아이템을 정말로 판매하시겠습니까?`)) return;

        const rarityKey = itemToSell.rarity;
        const rarityInfo = RARITIES[rarityKey];
        const itemLevel = itemToSell.level || 0;
        
        const goldGained = Math.ceil(rarityInfo.statMultiplier * 25 * Math.pow(1.3, itemLevel) * (itemToSell.baseLevel || 1));
        
        setPlayerStats(prev => ({ ...prev, coins: prev.coins + goldGained }));
        updateMissionProgress('EARN_GOLD', goldGained);
        
        setInventory(prev => prev.filter(i => i.id !== itemToSell.id));
        if (selectedForgeItem && selectedForgeItem.id === itemToSell.id) {
            setSelectedForgeItem(null);
        }
        
        addLog(`[${itemToSell.name}] 판매 완료! <strong class="text-yellow-400">${formatNumber(goldGained)} 골드</strong>를 획득했습니다.`);
        
        needsSave.current = true;
    }, [selectedForgeItem, addLog, updateMissionProgress]);

    const updateItemInState = (updatedItem) => {
        const itemTypeKey = updatedItem.type.toLowerCase();
        if (equipment[itemTypeKey] && equipment[itemTypeKey].id === updatedItem.id) {
             setEquipment(prev => ({...prev, [itemTypeKey]: updatedItem}));
        } else {
            setInventory(prev => prev.map(i => i.id === updatedItem.id ? updatedItem : i));
        }
    };

    const handleForgeItem = useCallback((itemToForge) => {
        if (!itemToForge) return;
        const rarityInfo = RARITIES[itemToForge.rarity];
        const itemLevel = itemToForge.level || 0;
        const cost = Math.ceil(rarityInfo.statMultiplier * 30 * Math.pow(1.35, itemLevel) * (1 + itemLevel * 0.1));

        if (playerStats.coins < cost) {
            addLog(`<strong class="text-red-400">골드가 부족합니다!</strong>`);
            return;
        }
        handleUpgrade(cost, () => {
            const updatedItem = { ...itemToForge, level: itemLevel + 1 };
            updateItemInState(updatedItem);
            setSelectedForgeItem(updatedItem);
            addLog(`[${itemToForge.name}] 강화 성공! <strong class="${rarityInfo.textClass}">(+${updatedItem.level})</strong>`);
        });
    }, [playerStats.coins, addLog, handleUpgrade]);
    
    const handleUpgradeRarity = useCallback((item) => {
        const currentRarityIndex = RARITY_ORDER.indexOf(item.rarity);
        if(currentRarityIndex >= RARITY_ORDER.length - 1) return;

        const rarityInfo = RARITIES[item.rarity];
        const cost = Math.ceil(Math.pow(10, currentRarityIndex + 2) * (item.baseLevel || 1) * rarityInfo.statMultiplier);

        if(playerStats.coins < cost) {
            addLog(`<strong class="text-red-400">골드가 부족합니다!</strong>`);
            return;
        }
        setPlayerStats(prev => ({...prev, coins: prev.coins - cost}));

        const nextRarityKey = RARITY_ORDER[currentRarityIndex + 1];
        const updatedItem = {
            ...item,
            rarity: nextRarityKey,
            name: `${RARITIES[nextRarityKey].name} ${EQUIPMENT_TYPES[item.type].name}`,
            stats: calculateItemStats(item.baseLevel, nextRarityKey, item.type),
        };

        updateItemInState(updatedItem);
        setSelectedForgeItem(updatedItem);
        addLog(`[${item.name}] 등급 승급! <strong class="${RARITIES[nextRarityKey].textClass}">[${RARITIES[nextRarityKey].name}]</strong> 달성!`);
        needsSave.current = true;
    }, [playerStats.coins, addLog]);

    const handleReforgeItem = useCallback((item) => {
        const rarityInfo = RARITIES[item.rarity];
        const itemLevel = item.level || 0;
        const cost = Math.ceil(rarityInfo.statMultiplier * 500 * (1 + itemLevel * 0.5) * (item.baseLevel || 1));
        
        if(playerStats.coins < cost) {
            addLog(`<strong class="text-red-400">골드가 부족합니다!</strong>`);
            return;
        }
        setPlayerStats(prev => ({...prev, coins: prev.coins - cost}));

        const updatedItem = {
            ...item,
            stats: calculateItemStats(item.baseLevel, item.rarity, item.type),
        };
        updateItemInState(updatedItem);
        setSelectedForgeItem(updatedItem);
        addLog(`[${item.name}] 능력치 재련 완료!`);
        needsSave.current = true;
    }, [playerStats.coins, addLog]);

    const handleSelectForgeItem = (item) => {
        if (item) {
            setSelectedForgeItem(item);
            setActiveTab('forge');
        }
    };

    const handleResetGame = useCallback(() => {
        if (window.confirm('정말로 게임을 초기화하시겠습니까? 모든 진행 상황이 사라집니다.')) {
            localStorage.removeItem(SAVED_GAME_KEY);
            window.location.reload();
        }
    }, []);

    const handleToggleSellMode = () => {
        setIsSellMode(prev => {
            if (prev) {
                setSellList(new Set());
            }
            return !prev;
        });
    };

    const handleToggleSellItem = (item) => {
        setSellList(prev => {
            const newSet = new Set(prev);
            if (newSet.has(item.id)) {
                newSet.delete(item.id);
            } else {
                newSet.add(item.id);
            }
            return newSet;
        });
    };

    const handleBulkSell = () => {
        if (sellList.size === 0) return;

        let totalGoldGained = 0;
        const itemsToSell = inventory.filter(item => sellList.has(item.id));

        itemsToSell.forEach(itemToSell => {
            const rarityInfo = RARITIES[itemToSell.rarity];
            const itemLevel = itemToSell.level || 0;
            const goldGained = Math.ceil(rarityInfo.statMultiplier * 25 * Math.pow(1.3, itemLevel) * (itemToSell.baseLevel || 1));
            totalGoldGained += goldGained;
        });

        if (window.confirm(`${sellList.size}개의 아이템을 판매하여 ${formatNumber(totalGoldGained)} 골드를 얻습니다. 계속하시겠습니까?`)) {
            setPlayerStats(prev => ({ ...prev, coins: prev.coins + totalGoldGained }));
            updateMissionProgress('EARN_GOLD', totalGoldGained);
            setInventory(prev => prev.filter(item => !sellList.has(item.id)));
            addLog(`아이템 ${sellList.size}개를 판매하여 <strong class="text-yellow-400">${formatNumber(totalGoldGained)} 골드</strong>를 획득했습니다.`);
            setSellList(new Set());
            setIsSellMode(false);
            needsSave.current = true;
        }
    };

    const handleClaimMission = (missionId) => {
        const missionToClaim = missions.find(m => m.id === missionId);
        if (missionToClaim && missionToClaim.isCompleted) {
            setPlayerStats(prev => ({ ...prev, coins: prev.coins + missionToClaim.reward }));
            addLog(`임무 보상 획득! +<strong class="text-yellow-400">${formatNumber(missionToClaim.reward)} 골드</strong>`);
            updateMissionProgress('EARN_GOLD', missionToClaim.reward);
            setMissions(prev => prev.map(m => m.id === missionId ? generateMission(playerStats.level) : m));
            needsSave.current = true;
        }
    };

    const handleClaimOfflineProgress = () => {
        if (!offlineProgress) return;
        const { gold, xp } = offlineProgress;

        addLog(`자리 비움 보상: +<strong class="text-yellow-400">${formatNumber(gold)} 골드</strong>, +<strong class="text-purple-400">${formatNumber(xp)} 경험치</strong>`);
        updateMissionProgress('EARN_GOLD', gold);

        setPlayerStats(prev => {
            let newXp = prev.xp + xp;
            let newLevel = prev.level;
            let newMaxXp = prev.maxXp;
            let newClickDamage = prev.clickDamage;
            let newAutoAttackDamage = prev.autoAttackDamage;
            let levelUps = 0;

            while (newXp >= newMaxXp) {
                newXp -= newMaxXp;
                newLevel += 1;
                levelUps++;
                newMaxXp = Math.floor(LEVEL_EXPERIENCE_BASE * Math.pow(LEVEL_EXPERIENCE_MULTIPLIER, newLevel - 1));
                newClickDamage *= 1.01;
                newAutoAttackDamage *= 1.01;
            }

            if (levelUps > 0) {
                addLog(`오프라인 보상으로 ${levelUps}번 레벨업! ${newLevel}레벨 달성!`);
            }
            
            return { ...prev, level: newLevel, xp: newXp, maxXp: newMaxXp, coins: prev.coins + gold, clickDamage: newClickDamage, autoAttackDamage: newAutoAttackDamage };
        });

        setOfflineProgress(null);
        needsSave.current = true;
    };
    
    const handleEquipArtifact = (id) => {
        if (equippedArtifacts.length < 3) {
            setEquippedArtifacts(prev => [...prev, id]);
            needsSave.current = true;
        } else {
            addLog(`<strong class="text-red-400">유물은 3개까지만 장착할 수 있습니다.</strong>`);
        }
    };

    const handleUnequipArtifact = (id) => {
        setEquippedArtifacts(prev => prev.filter(artId => artId !== id));
        needsSave.current = true;
    };

    const handleArtifactGacha = () => {
        const unownedArtifacts = ARTIFACTS.filter(a => !ownedArtifacts.includes(a.id));
        if (unownedArtifacts.length === 0) {
            addLog('모든 유물을 획득했습니다!');
            return;
        }

        const cost = 1000;
        if (playerStats.coins < cost) {
            addLog(`<strong class="text-red-400">골드가 부족합니다!</strong> (필요: ${formatNumber(cost)})`);
            return;
        }

        setPlayerStats(prev => ({...prev, coins: prev.coins - cost}));
        
        const droppedArtifact = unownedArtifacts[Math.floor(Math.random() * unownedArtifacts.length)];
        setOwnedArtifacts(prev => [...prev, droppedArtifact.id]);
        addLog(`유물 뽑기 성공! <strong class="text-yellow-200">[${droppedArtifact.name}]</strong> 획득!`);
        needsSave.current = true;
    };

    const handleSlotSpin = (cost, callback) => {
        setPlayerStats(prev => ({...prev, coins: prev.coins - cost}));
        const symbols = ['💰', '⚔️', '💧', '💎', '🍀'];
        const reels = [symbols[Math.floor(Math.random()*symbols.length)], symbols[Math.floor(Math.random()*symbols.length)], symbols[Math.floor(Math.random()*symbols.length)]];
        let reward = { message: "꽝!", gold: 0 };

        if (reels[0] === reels[1] && reels[1] === reels[2]) {
            switch(reels[0]) {
                case '💰': reward = { message: `골드 잭팟!`, gold: cost * 10 }; break;
                case '⚔️': reward = { message: `전투력 잭팟!`, gold: cost * 5 }; break;
                case '💧': reward = { message: `슬라임 잭팟!`, gold: cost * 3 }; break;
                case '💎': reward = { message: `보석 잭팟!`, gold: cost * 20 }; break;
                case '🍀': reward = { message: `행운 잭팟!`, gold: cost * 50 }; break;
            }
        } else if (reels[0] === reels[1] || reels[1] === reels[2] || reels[0] === reels[2]) {
             reward = { message: `2개 일치!`, gold: cost * 2 };
        }
        
        if (reward.gold > 0) {
            setPlayerStats(prev => ({...prev, coins: prev.coins + reward.gold}));
            addLog(`슬롯머신: ${reward.message} (+${formatNumber(reward.gold)} 골드)`);
        } else {
            addLog(`슬롯머신: 꽝!`);
        }

        callback(reels, reward);
        needsSave.current = true;
    };
    
    const handleSlimeWhackStart = (cost) => {
        if (playerStats.coins < cost) {
            addLog(`<strong class="text-red-400">골드가 부족합니다!</strong>`);
            return false;
        }
        setPlayerStats(prev => ({ ...prev, coins: prev.coins - cost }));
        addLog(`두더지 슬라임 게임 시작! (-${formatNumber(cost)} 골드)`);
        needsSave.current = true;
        return true;
    };

    const handleSlimeWhackEnd = (reward) => {
        if (reward > 0) {
            setPlayerStats(prev => ({ ...prev, coins: prev.coins + reward }));
            addLog(`두더지 슬라임 게임 종료! 보상 <strong class="text-yellow-400">${formatNumber(reward)}</strong> 골드 획득!`);
            needsSave.current = true;
        } else {
            addLog(`두더지 슬라임 게임 종료!`);
        }
    };


    const liberationCost = useMemo(() => LIBERATION_COST_BASE * Math.pow(LIBERATION_COST_MULTIPLIER, liberationCount), [liberationCount]);
    const equipmentGachaCost = useMemo(() => EQUIPMENT_GACHA_COST_BASE + playerStats.level * EQUIPMENT_GACHA_COST_LEVEL_MULTIPLIER, [playerStats.level]);
    
    if (!difficulty) {
        return <DifficultySelectionModal onSelect={handleSelectDifficulty} />;
    }

    return (
        <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center p-4 space-y-4">
            <div className="fixed top-4 left-4 z-10">
                <button onClick={handleResetGame} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg text-sm shadow-lg">
                    게임 초기화
                </button>
            </div>

            {(isJobSelectionOpen || !playerClass) && <JobSelectionModal onSelect={handleJobSelect} onClose={() => setIsJobSelectionOpen(false)}/>}
            {isDifficultyModalOpen && <DifficultyChangeModal currentDifficulty={difficulty} onSelect={handleChangeDifficulty} onClose={() => setIsDifficultyModalOpen(false)} />}
            <OfflineProgressModal progress={offlineProgress} onClaim={handleClaimOfflineProgress} />

            <header className="text-center">
                <h1 className="text-5xl font-bold text-green-400 drop-shadow-lg">슬라임 헌터</h1>
                <p className="text-gray-400">클릭하여 슬라임을 물리치고 최강의 헌터가 되세요!</p>
            </header>
            
            <main className="w-full max-w-7xl flex flex-col md:flex-row gap-4">
                <div className="w-full md:w-1/4 order-1 md:order-1 flex flex-col gap-4">
                   <PlayerStats 
                        stats={finalStats} 
                        playerClass={playerClass} 
                        onNameChange={handlePlayerNameChange} 
                        abilityStats={finalAbilityStats} 
                        liberationCount={liberationCount} 
                        rebirthCount={rebirthCount} 
                        onJobChangeClick={() => setIsJobSelectionOpen(true)}
                        difficulty={difficulty}
                        onDifficultyChangeClick={() => setIsDifficultyModalOpen(true)}
                        isAutoDropEnabled={isAutoDropEnabled}
                        onToggleAutoDrop={() => { setIsAutoDropEnabled(p => !p); needsSave.current = true; addLog(`장비 자동 판매가 ${!isAutoDropEnabled ? '활성화' : '비활성화'}되었습니다.`) }}
                    />
                   <EquipmentPanel equipment={equipment} onSelectItem={handleSelectForgeItem} />
                </div>
                <div className="w-full md:w-1/2 bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col items-center justify-start order-2 md:order-2 relative overflow-hidden">
                    <MonsterDisplay monster={monsterStats} onClick={handleMonsterClick} damagePopups={damagePopups} treasureGolem={treasureGolem} />
                    {playerClass && (
                        <div className="w-full mt-8">
                            <ActiveSkillButton 
                                skill={JOBS[playerClass].skill}
                                onClick={handleActiveSkill} 
                                cooldown={activeSkillCooldown} 
                                maxCooldown={finalAbilityStats.activeSkillCooldown}
                            />
                        </div>
                    )}
                </div>
                <RightPanel 
                    activeTab={activeTab}
                    setActiveTab={setActiveTab}
                    selectedForgeItem={selectedForgeItem}
                    upgrades={upgrades}
                    playerCoins={playerStats.coins}
                    playerStats={playerStats}
                    abilityStats={finalAbilityStats}
                    equipmentGachaCost={equipmentGachaCost}
                    inventory={inventory}
                    isSellMode={isSellMode}
                    sellList={sellList}
                    missions={missions}
                    ownedArtifacts={ownedArtifacts}
                    equippedArtifacts={equippedArtifacts}
                    handlers={{
                        onUpgradeClick: handleUpgradeClick, onUpgradeAutoAttack: handleUpgradeAutoAttack, onUpgradeAttackSpeed: handleUpgradeAttackSpeed,
                        onUpgradeCritChance: handleUpgradeCritChance, onUpgradeCritDamage: handleUpgradeCritDamage, onUpgradeGoldGain: handleUpgradeGoldGain,
                        onUpgradeXpGain: handleUpgradeXpGain, onUpgradeSkillDamage: handleUpgradeSkillDamage, onUpgradeHaste: handleUpgradeHaste,
                        onUpgradeLuck: handleUpgradeLuck, onUpgradeBossDamage: handleUpgradeBossDamage, onEquipmentGacha: handleEquipmentGacha,
                        onUpgradeArtifactPower: handleUpgradeArtifactPower,
                        onSelectItem: (item) => setSelectedInventoryItem(item),
                        onForgeItem: handleForgeItem, onUpgradeRarity: handleUpgradeRarity, onReforgeItem: handleReforgeItem,
                        onToggleSellMode: handleToggleSellMode, onToggleSellItem: handleToggleSellItem, onBulkSell: handleBulkSell,
                        onClaimMission: handleClaimMission,
                        onEquipArtifact: handleEquipArtifact, onUnequipArtifact: handleUnequipArtifact,
                        onArtifactGacha: handleArtifactGacha,
                        onSlotSpin: handleSlotSpin,
                        onSlimeWhackStart: handleSlimeWhackStart,
                        onSlimeWhackEnd: handleSlimeWhackEnd,
                    }}
                />
            </main>

            <footer className="w-full max-w-7xl flex flex-col items-center justify-center gap-4">
                 <div className="w-full grid grid-cols-1 md:grid-cols-2 gap-4">
                    <LiberationButton onLiberate={handleLiberation} cost={liberationCost} playerCoins={playerStats.coins} count={liberationCount} />
                    <RebirthButton onRebirth={handleRebirth} level={playerStats.level} count={rebirthCount} />
                 </div>
                 <GameLog log={gameLog}/>
            </footer>

            <NewItemDropModal 
                newItem={newItemDrop}
                currentItem={newItemDrop ? equipment[newItemDrop.type.toLowerCase()] : null}
                onEquip={() => handleEquipItem(newItemDrop)}
                onStore={handleStoreNewItem}
            />

            <InventoryItemDetailModal
                item={selectedInventoryItem}
                currentEquipped={selectedInventoryItem ? equipment[selectedInventoryItem.type.toLowerCase()] : null}
                onClose={() => setSelectedInventoryItem(null)}
                onEquip={handleEquipItem}
                onSell={handleSellItem}
                onSelectForge={handleSelectForgeItem}
            />
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
    </script>
  </body>
</html>